<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Jack's Digital Workbench - Software Quality</title><link href="https://jackdewinter.github.io/" rel="alternate"></link><link href="https://jackdewinter.github.io/feeds/software-quality.atom.xml" rel="self"></link><id>https://jackdewinter.github.io/</id><updated>2020-04-13T00:00:00-07:00</updated><entry><title>Markdown Linter - Adding Reference Links</title><link href="https://jackdewinter.github.io/2020/04/13/markdown-linter-adding-reference-links/" rel="alternate"></link><published>2020-04-13T00:00:00-07:00</published><updated>2020-04-13T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-04-13:/2020/04/13/markdown-linter-adding-reference-links/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The end of the main parser is in sight!  Two articles ago, the additional
of support for
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#why-inline-links"&gt;inline links&lt;/a&gt;
was documented, and the last article detailed the addition of support for
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;.
In terms of remaining work required to meet the GFM specification, only reference links
and …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The end of the main parser is in sight!  Two articles ago, the additional
of support for
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#why-inline-links"&gt;inline links&lt;/a&gt;
was documented, and the last article detailed the addition of support for
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;.
In terms of remaining work required to meet the GFM specification, only reference links
and image links are left.  As image links are just reference links with a slightly
different syntax and slightly different rules, it made sense to focus on reference
links first.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is The Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ed20bc4e38342b2c9e3fdebc691e2021c80c67b4"&gt;26 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="a-quick-aside"&gt;A Quick Aside&lt;a class="headerlink" href="#a-quick-aside" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I just wanted to take a moment to give some context on why I am providing a large number
of examples in this article.  If it feels like I am providing a lot of “extra”
examples, that is because I initially had a number of issues with the different link
types and their syntax.  For whatever reason, the different link types were just not
“clicking” inside of my head.  It was only after I started focusing equally on the rules
and the examples, that I was able to match the “abstract” text in the specification
with the “concrete” examples provided.  Together they provided the context that I
required to truly understand reference links.&lt;/p&gt;
&lt;p&gt;I hope that by providing good examples in this article, I am providing a similar amount
of clarity to help any readers who may encounter similar issues to what I encountered.&lt;/p&gt;
&lt;h2 id="what-are-shortcut-reference-links"&gt;What Are Shortcut Reference Links?&lt;a class="headerlink" href="#what-are-shortcut-reference-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the last article on
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;,
I briefly introduced a concept called a shortcut reference link.  As that article was
focusing on link reference definitions and not reference links, I introduced it only
as a way to show what link reference definitions were capable of
doing.  A good example of this is the following Markdown where the link reference
definition is specified on the first line and the shortcut reference link that utilizes
that definition is specified on the third line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Shortcut reference links like this are the easiest of the three reference link types to
understand as everything is kept simple.  As with all types of reference links,
shortcut reference links are taken care of in the inline processing stage, long after
any link reference definitions have been collected.
To use a link reference definition, the
normalized version of the link label from the shortcut reference link must match a
link label from a previously defined link reference definition.&lt;sup id="fnref:before"&gt;&lt;a class="footnote-ref" href="#fn:before"&gt;1&lt;/a&gt;&lt;/sup&gt;  To keep
things simple for now, I am going to assign
words like “normalized” to mean a case-insensitive comparison between two strings,
with no other modifications. While this is not completely accurate, it will help keep
things simple for now, and I promise to revisit it before the end of the article.&lt;/p&gt;
&lt;p&gt;If the link’s link label matches a link reference definition, the shortcut reference
link uses the link label as the text within the anchor.  In the case of the above
example, this produces the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When this HTML was generated, the text &lt;code&gt;link&lt;/code&gt; was used from the shortcut reference link
and the rest of the anchor tag (the text between &lt;code&gt;&amp;lt;a&lt;/code&gt; and
&lt;code&gt;&amp;lt;/a&amp;gt;&lt;/code&gt; excluding the text &lt;code&gt;link&lt;/code&gt;) was composed using information from the link
reference definition.  The benefit of this approach is that the “marker” for the link
is inline with the rest of the text while the more bulky link data is located
elsewhere in the document.   This benefit allows the author to better control their own
authoring experience by controlling where the link reference definitions occur in their
document: after the paragraph containing the link, at the end of the section, or at the
end of the document.&lt;/p&gt;
&lt;p&gt;Without exploring the normalization of link labels (yet!), each link label is parsed
to render inline processing for the link label.  A good instance of this is
&lt;a href="https://github.github.com/gfm/#example-566"&gt;example 566&lt;/a&gt;
from the GFM specification which adds inline emphasis to the link label:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[*foo* bar]&lt;/span&gt;

&lt;span class="na"&gt;[*foo* bar]: /url "title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is rendered as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key is that as long as the normalized link label of both the shortcut reference
link and the link reference definition match, everything works fine.  If the link
label does not match, the text is simply rendered as normal text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar]&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other than that, the only other special thing is that the link label for a shortcut
reference link cannot contain another link.  This is explicitly stated in the
definition of &lt;a href="https://github.github.com/gfm/#link-text"&gt;link text&lt;/a&gt; which states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Links may not contain other links, at any level of nesting. If multiple otherwise valid link definitions appear nested inside each other, the inner-most definition is used.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;A good example of this is obtained when the following Markdown text is fed through a
GFM compliant parser:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[foo[foo]]&lt;/span&gt;

&lt;span class="na"&gt;[foo]: /url "title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generating the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[foo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;]&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Looking at the HTML, the inner shortcut reference link &lt;code&gt;[foo]&lt;/code&gt; was interpreted and the
outer link &lt;code&gt;[foo[foo]]&lt;/code&gt; was deemed invalid, therefore being rendered normally.&lt;/p&gt;
&lt;h3 id="multiple-references-of-a-link-reference-definition"&gt;Multiple References of a Link Reference Definition&lt;a class="headerlink" href="#multiple-references-of-a-link-reference-definition" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt; there are instructions and examples
on what to do if there are multiple link reference definitions declared with the same
normalized link label.  However, after a couple of passes through the GFM specification,
I was unable to find any guidance on what to do if there are multiple reference links
that use a given link reference definition.  The closest that the specification gets to
this is near the start of the section on
&lt;a href="https://github.github.com/gfm/#full-reference-link"&gt;full reference links&lt;/a&gt;
(covered in the next section) which states:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;followed by a link label that matches a link reference definition elsewhere in the document.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Based on this information, along with testing against the CommonMark reference parser,
I can safely state that the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="err"&gt;\&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="ss"&gt;"title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on this information and the quote above, I feel that this is a good feature of
Markdown.  In certain cases where a link is used repeatedly, this behavior can be used
to have a single link reference definition to provide the link itself, and multiple
reference links pointed to that one definition.  In my mind, that is where full
reference links come in.&lt;/p&gt;
&lt;h2 id="what-are-full-reference-links"&gt;What Are Full Reference Links?&lt;a class="headerlink" href="#what-are-full-reference-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In
&lt;a href="https://daringfireball.net/projects/markdown/syntax#link"&gt;John Gruber’s original specification&lt;/a&gt;,
there were no shortcut links and full reference links were referred
to as “reference-style links”.  It was only with later parsers that the more compact
shortcut reference link was introduced.  In my mind, instead of the order in which
reference links were historically introduced, I prefer to see the hierarchy of
reference links in reverse chronological order, with the shortcut reference links first
and the full reference links second.&lt;/p&gt;
&lt;p&gt;My reasoning for this is as follows.  Based purely on efficiency, I typically start
with the clearest construct that has the least amount of effort to add. With reference
links, my first instinct is to add a shortcut reference link with the
link label matching the link reference definition that I need to add to complete it.
In 95% of the cases that I come across, I need a single link reference definition and a
single reference link, so a shortcut reference link is the best option.  For the
remaining 5%, I usually have a case where I have multiple reference links referencing a
single link reference definition, and I need a reference link that I can use there to
good effect.&lt;/p&gt;
&lt;p&gt;Consider the following example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;refers&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;

&lt;span class="n"&gt;Then&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;separate&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;must&lt;/span&gt; &lt;span class="n"&gt;still&lt;/span&gt; &lt;span class="n"&gt;refer&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When coming up with this example, I needed to take care to create my example second
paragraph in manner in which &lt;code&gt;[my link]&lt;/code&gt; would fit somewhat fluidly in the sentence.
It would be more useful to do the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;sentence&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;refers&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;

&lt;span class="n"&gt;Then&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;separate&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;I&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;refer&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For me, that is where the benefit of full reference links come in.&lt;/p&gt;
&lt;p&gt;As I alluded to
in the previous example, full reference links are of the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[text][link]&lt;/span&gt;

&lt;span class="na"&gt;[link]: /url "title"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Where the first set of square brackets encloses link text and the second set of brackets
encloses the link label.  Unlike the shortcut reference link, where the link label
serves as both the text to match and the text around which to link, a full reference
link assigns a block of text to each of those responsibilities.  This allows a single
link reference definition to be referred to by multiple reference links, each one
having tailored link text.&lt;/p&gt;
&lt;p&gt;The link text is defined in a manner very similar to link labels, including the
limitation that link text cannot include other links, demonstrated by the
&lt;a href="https://github.github.com/gfm/#example-541"&gt;example 541&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[foo *bar [baz][ref]*][ref]&lt;/span&gt;

&lt;span class="na"&gt;[ref]: /uri&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;]&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;ref&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similar to how the link-within-a-possible-link example was handled for shortcut
reference links, the inner reference link text &lt;code&gt;[baz][ref]&lt;/code&gt; is interpreted as a valid
link, with the rest of the possible-link’s link text being presented as plain text.
It is simply an act of serendipity that both the inner link and outer possible-link
used the link label &lt;code&gt;[ref]&lt;/code&gt;.  Because of this act of serendipity, when the inline
processor gets to the &lt;code&gt;[ref]&lt;/code&gt; text at the end of the line, it is interpreted as a
shortcut reference
link, in a completely separate context from the previous link.  As such, a second
link to the same URI is generated at the end of the HTML paragraph.&lt;/p&gt;
&lt;p&gt;While I found it easier to visually see the how the above example should be parsed by
working through it in my head, it was examples of this flavor that I really struggled
with before I combined looking at rule with looking at examples, as detailed above.
To be honest, to properly figure these out, I used a pencil and a sheet of paper to
visually break down the problem.  Only when I had those scribbled notes in front of me
did I really get this example.  Perhaps it is only me, but it was by literally working
through the example and showing my work that I was able to really understand what
the parser needed to do.  After that, coding the parser to do it was simple.  As
I have mentioned a number of times, figure out whatever works for you, and leverage
that.&lt;/p&gt;
&lt;h2 id="collapsed-reference-links"&gt;Collapsed Reference Links&lt;a class="headerlink" href="#collapsed-reference-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the inclusion of collapsed link references into the specification may seem like
an unnecessary element, it is an alternative that offers the author leeway on how
their Markdown article is constructed.  For some authors, the full reference link of
&lt;code&gt;[label][label]&lt;/code&gt; might be preferred.  For other authors, the shortcut reference link of
&lt;code&gt;[label]&lt;/code&gt; might be preferred.  If the author is looking for something in between, the
collapsed reference link and it’s format of &lt;code&gt;[label][]&lt;/code&gt; offers a middle ground.  All
three of the examples provided in this paragraph are semantically equal and will produce
the exacts same HTML.&lt;/p&gt;
&lt;p&gt;In the end, it is just a matter of preference which of the reference link formats
that the author prefers, and is comfortable with.&lt;/p&gt;
&lt;h2 id="normalizing-link-labels"&gt;Normalizing Link Labels&lt;a class="headerlink" href="#normalizing-link-labels" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Back in the section on
&lt;a href="https://jackdewinter.github.io/2020/04/13/markdown-linter-adding-reference-links/#what-are-shortcut-reference-links"&gt;What Are Shortcut Reference Links?&lt;/a&gt;,
I simplified
the term “normalized” to mean &lt;code&gt;case-insensitive comparison&lt;/code&gt;.  The full definition of
&lt;a href="https://github.github.com/gfm/#matches"&gt;normalized&lt;/a&gt;
is a bit more complicated, but not by much.  In order of operation:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;grab the link text in its unprocessed form&lt;/li&gt;
&lt;li&gt;remove the opening and closing brackets from the link label&lt;/li&gt;
&lt;li&gt;perform a Unicode case fold (the Unicode equivalent of reducing all letters to lower case)&lt;/li&gt;
&lt;li&gt;strip leading and trailing whitespace&lt;/li&gt;
&lt;li&gt;collapse consecutive internal whitespace to a single space&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Once these steps have been applied to the link label’s text, it is that text that is
used to determine if it matches an existing link reference definition.  In cases where
the link label is &lt;code&gt;[foo]&lt;/code&gt; or &lt;code&gt;[referenced document]&lt;/code&gt;, this process may seem weird or
superfluous.  But, in the case of
&lt;a href="https://github.github.com/gfm/#example-553"&gt;example 553&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[bar][foo\!]&lt;/span&gt;

&lt;span class="na"&gt;[foo!]: /url&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the parsed inline text is equivalent, but the link is not interpreted as a full
reference link.  This is because the normalized text for the reference link is &lt;code&gt;foo\!&lt;/code&gt;
while the normalized text for the link reference definition is
&lt;code&gt;foo!&lt;/code&gt;.  While both of these strings will be equivalent to &lt;code&gt;foo!&lt;/code&gt; after applying inline
parsing, their normalized values does not match, and as such, the above example is
rendered in HTML as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;[bar][foo!]&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="what-implementation-problems-did-i-have"&gt;What Implementation Problems Did I Have?&lt;a class="headerlink" href="#what-implementation-problems-did-i-have" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Between the work previously done for
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#why-inline-links"&gt;inline links&lt;/a&gt;
and
&lt;a href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/#what-are-link-reference-definitions"&gt;link reference definitions&lt;/a&gt;,
most of the required foundation work was already in place when I started with
reference links.  As I required a simple implementation of shortcut reference
links to properly test link reference definitions, it was only the introduction of
link text for full reference links that required any real block of new code.&lt;/p&gt;
&lt;p&gt;Even given that solid, tested foundation, there were two issues that gave me troubles
as I implemented reference links: using the correct text to determine matching and the
order of precedence between different types of reference links.&lt;/p&gt;
&lt;p&gt;Adding the parsing for shortcut reference links as part of the work for link
reference definitions, I naturally did the bare minimum required to get it working.  For
the link label matching algorithm, it was a simple &lt;code&gt;a == b&lt;/code&gt; comparison which worked
nicely for all of the link reference definition examples except two.  To get it working
with those two examples, both dealing with case insensitivity, I changed the
comparison to &lt;code&gt;a.lower() == b.lower()&lt;/code&gt; and then both examples parsed correctly.&lt;/p&gt;
&lt;p&gt;When I reached the reference link examples that dealt with link label matching,
things got a bit more tricky, but not too tricky.  Use &lt;code&gt;.casefold()&lt;/code&gt; instead of
&lt;code&gt;.lower()&lt;/code&gt;? No problem.  Stripping various forms of whitespace from the link label?
No problem.  Using the right text as a basis for those transformations?  That took a
bit of work.&lt;/p&gt;
&lt;p&gt;Given that link processing is handled in the inline processing phase, the easiest
solution was to add parallel text handling.  My thinking was that since the inline
processing is constrained to a single continuous grouping of text, I just needed
something simple that would only exist for the lifetime of that grouping.  To accomplish
this, I used the variable &lt;code&gt;current_string_unresolved&lt;/code&gt; to keep track of a raw,
unresolved version of the string that was being processed in the variable
&lt;code&gt;current_string&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While that
might seem a bit of a kludge&lt;sup id="fnref:kludge"&gt;&lt;a class="footnote-ref" href="#fn:kludge"&gt;2&lt;/a&gt;&lt;/sup&gt;, for me it was a simple solution that was
contained to the area most affected by the issue.  The other option, using an
unresolved stream and then resolving it later, seemed to have too many
issues to deal with in a manner that I was sure was going to cover all of the edge
cases.  I know this because I tried that first (and second and third), before sitting
back and rethinking what the best approach would be from a high level. After three
attempts with the unresolved stream and no success, the kludge solution worked on the
first try with no issues.  Guess it really wasn’t a kludge!&lt;/p&gt;
&lt;p&gt;Having found a decent solution for using the right text to match against, the only
issue I had left to deal with was in dealing with the order of precedence of reference
links with themselves and other elements.  Detailed in the examples between
&lt;a href="https://github.github.com/gfm/#example-572"&gt;example 572&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-579"&gt;example 579&lt;/a&gt;, these examples give very
specific guidance on the precedence to use for each combination.  While the examples
provided good guidance, the implementation wasn’t always so easy to get right.&lt;/p&gt;
&lt;p&gt;While getting the order in which to check for
the various types of reference links took a bit, it was complicated by the determination
of whether or not a given reference link referenced a valid link reference definition.
Out of the 4 days it took for me to complete reference links, one of those days was
spent just going over all of the combinations, making sure that the specification
detailed them (it did!), and then checking and rechecking each modification that made
another of the above examples work.  It was only then that I staged my changes and moved
on to the next example.  In the end, it was very tedious work, but it was worthwhile
because it worked.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For the most part, the implementation of the reference links was a good experience,
combining a bit of “reuse foundation” work with some “how do I get this to work
properly” challenges.  There was just one dark sport on the implementation of the
feature.&lt;/p&gt;
&lt;p&gt;I have already mentioned my issues with understanding the link specification in the
above sections, but I feel the topic is important enough topic to warrant more
discussion.  Unlike before where I was
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#what-was-my-experience-so-far"&gt;skipping parts&lt;/a&gt;
of the specification, this challenge was a genuine case of me reading the specification
and not getting a good understanding of it.  Even with the provided examples, there
were still times where I was unable to comprehend what the specification was doing.  It
was only after going “old school” and getting out a pencil and some paper did I work
through it.&lt;/p&gt;
&lt;p&gt;At one point, I remember thinking to myself:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Writing parsers for 30 years and you still need a pencil and paper?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It was not one of the brightest moments of the project, but it did happen. It
was after what I think was the 7th or 8th time of me trying to
understand the preventing the link within a link logic detailed in the section on
&lt;a href="https://jackdewinter.github.io/2020/04/13/markdown-linter-adding-reference-links/#what-are-full-reference-links"&gt;reference links&lt;/a&gt;.
Honestly, I am guessing it was the 7th or 8th time, I actually lost count of the number
of attempts. For whatever reason, it just wasn’t clicking for
me.  It’s times like those that I like to break a problem down to smaller components,
what I refer to the “boulders to pebbles” approach.  And for some reason, I needed to
break those pebbles down even smaller, and I was really hard on myself for it.&lt;/p&gt;
&lt;p&gt;No matter who you are, you are going to have good days, bad days, and a lot of in
between days.  The more that you take care of yourself, the better your chance of
being on the positive end of that spectrum.  I didn’t need a pencil and paper because
I wasn’t capable of figuring out the problem myself, I needed them as a tool to
help me figure it out myself on that day.  I now look back at the problem and my
scribbles and have the mental capacity to understand: it was just a bad day.  And
even if I am being more charitable about the day than it really was.  So what?
I used the tools that I needed to in order to solve the problem I faced.  Simple as
that.&lt;/p&gt;
&lt;p&gt;I started this project with a need and a desire to learn.  I completed this feature
learning that I still have what it takes to solve the issues that I need to.  I also
learned that I need to focus a bit more on taking better care of myself and nudging
myself towards the positive end of that spectrum.  Guess what? I stumble, I learn,
and I get up and try and not do the same thing again.  Well… not too often at least.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While I know there is some “optional” stuff I need to add to the parser before I
can use it on my own website, there is only one more feature that I need to complete
before the parser is complete and GFM compliant.  With a bit of a mental drum roll…
image links are next!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:before"&gt;
&lt;p&gt;As link reference definitions are parsed with the leaf blocks, and reference links are parsed later with inline processing, the term “previously defined” refers to any definition in the Markdown document that was parsed, and not “previously defined” with respect to the relative locations of the reference links and the definition within the Markdown document. &lt;a class="footnote-backref" href="#fnref:before" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:kludge"&gt;
&lt;p&gt;According to Merriam-Webster: “a haphazard or makeshift solution to a problem and especially to a computer or programming problem” &lt;a class="footnote-backref" href="#fnref:kludge" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Adding Link Reference Definitions</title><link href="https://jackdewinter.github.io/2020/04/06/markdown-linter-adding-link-reference-definitions/" rel="alternate"></link><published>2020-04-06T00:00:00-07:00</published><updated>2020-04-06T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-04-06:/2020/04/06/markdown-linter-adding-link-reference-definitions/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As detailed in
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#Why-Inline-Links?"&gt;the last article&lt;/a&gt;,
the remaining work left on the main parser consists of inline links,
link reference definitions, reference links, and image links.  Inline links were
covered in the last article.  While I could try and
come up with some grand reason for doing the link …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As detailed in
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#Why-Inline-Links?"&gt;the last article&lt;/a&gt;,
the remaining work left on the main parser consists of inline links,
link reference definitions, reference links, and image links.  Inline links were
covered in the last article.  While I could try and
come up with some grand reason for doing the link reference definitions next, the honest
truth is simple: they were next on the list.&lt;/p&gt;
&lt;h2 id="what-is-the-audience-for-this-article"&gt;What Is The Audience For This Article?&lt;a class="headerlink" href="#what-is-the-audience-for-this-article" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While detailed more eloquently in
&lt;a href="https://jackdewinter.github.io/2020/04/05/what-is-the-audience-for-my-blog/#what-is-the-audience-for-my-blog"&gt;this article&lt;/a&gt;,
my goal for this technical article is to focus on the reasoning behind my solutions,
rather that the solutions themselves.  For a full record of the solutions presented in
this article, please go to this project’s GitHub repository and consult the
commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/680e9d9fd7472e69232a191ca84ce9bc5ff4aaec"&gt;22 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="what-are-link-reference-definitions"&gt;What Are Link Reference Definitions?&lt;a class="headerlink" href="#what-are-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#what-is-an-inline-link"&gt;last article&lt;/a&gt;,
I introduced inline links and how they present the text to appear in the
link (link label), the link itself (link destination), and an optional title for that
link (link title).  Link reference definitions are a related concept in that they take
the link destination and link title parts of the link and store them in a map, to be
used at a different time.&lt;/p&gt;
&lt;p&gt;Basically, where an inline link uses the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;a link definition uses the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main difference between the two elements is that a link reference definition does
not add any elements into the HTML document by itself.  To utilize the link reference
definition, a reference link must be added to the document that has a
normalized &lt;sup id="fnref:normalized"&gt;&lt;a class="footnote-ref" href="#fn:normalized"&gt;1&lt;/a&gt;&lt;/sup&gt; link label that matches the normalized &lt;sup id="fnref2:normalized"&gt;&lt;a class="footnote-ref" href="#fn:normalized"&gt;1&lt;/a&gt;&lt;/sup&gt; link
label from a link reference definition present elsewhere in the same Markdown document.
For example, using the simplest form of reference links, a
&lt;a href="https://github.github.com/gfm/#shortcut-reference-link"&gt;shortcut reference link&lt;/a&gt;,
the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;creates a link reference definition and uses it, generating the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/uri"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the normalization rules&lt;sup id="fnref3:normalized"&gt;&lt;a class="footnote-ref" href="#fn:normalized"&gt;1&lt;/a&gt;&lt;/sup&gt; are somewhat complex, in most cases it just
means using the same link label in both the reference link and the link reference
definition.  Unless you happen to get into the more interesting aspects of the
normalization rules, both reference links and link reference definitions are easy to
use, by design.&lt;/p&gt;
&lt;h2 id="why-use-link-reference-definitions"&gt;Why Use Link Reference Definitions?&lt;a class="headerlink" href="#why-use-link-reference-definitions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#i-use-inline-links-almost-exclusively"&gt;last article&lt;/a&gt;,
I mentioned that I use inline links exclusively.  Now that I have introduced link
resource definitions and reference links, I can provide more context on the difference
between them. Using a simple
&lt;a href="https://lipsum.com/"&gt;lorem ipsum generator&lt;/a&gt;,
I came up with the following two examples.  This first example contains an inline link:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;turpis&lt;/span&gt; &lt;span class="n"&gt;ac&lt;/span&gt; &lt;span class="n"&gt;vestibulum&lt;/span&gt; &lt;span class="n"&gt;imperdiet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nulla&lt;/span&gt; &lt;span class="n"&gt;mi&lt;/span&gt; &lt;span class="n"&gt;mollis&lt;/span&gt; &lt;span class="n"&gt;erat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nec&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt; &lt;span class="n"&gt;nunc&lt;/span&gt;
&lt;span class="n"&gt;lorem&lt;/span&gt; &lt;span class="n"&gt;rutrum&lt;/span&gt; &lt;span class="n"&gt;metus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Vestibulum&lt;/span&gt; &lt;span class="n"&gt;dictum&lt;/span&gt; &lt;span class="n"&gt;lacinia&lt;/span&gt; &lt;span class="n"&gt;lacus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;ornare&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;consequat&lt;/span&gt; &lt;span class="n"&gt;ultrices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;leo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aliquet&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;luctus&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;lipsum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;
&lt;span class="n"&gt;Donec&lt;/span&gt; &lt;span class="n"&gt;tincidunt&lt;/span&gt; &lt;span class="n"&gt;augue&lt;/span&gt; &lt;span class="n"&gt;nisi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sed&lt;/span&gt;
&lt;span class="n"&gt;pellentesque&lt;/span&gt; &lt;span class="n"&gt;nisl&lt;/span&gt; &lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;vel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and this second example contains a reference link, specifically a shortcut reference
link:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;turpis&lt;/span&gt; &lt;span class="n"&gt;ac&lt;/span&gt; &lt;span class="n"&gt;vestibulum&lt;/span&gt; &lt;span class="n"&gt;imperdiet&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nulla&lt;/span&gt; &lt;span class="n"&gt;mi&lt;/span&gt; &lt;span class="n"&gt;mollis&lt;/span&gt; &lt;span class="n"&gt;erat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;nec&lt;/span&gt; &lt;span class="n"&gt;efficitur&lt;/span&gt; &lt;span class="n"&gt;nunc&lt;/span&gt;
&lt;span class="n"&gt;lorem&lt;/span&gt; &lt;span class="n"&gt;rutrum&lt;/span&gt; &lt;span class="n"&gt;metus&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Vestibulum&lt;/span&gt; &lt;span class="n"&gt;dictum&lt;/span&gt; &lt;span class="n"&gt;lacinia&lt;/span&gt; &lt;span class="n"&gt;lacus&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;at&lt;/span&gt; &lt;span class="n"&gt;ornare&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;consequat&lt;/span&gt; &lt;span class="n"&gt;ultrices&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;Nam&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt; &lt;span class="n"&gt;leo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;aliquet&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;luctus&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt; &lt;span class="n"&gt;Donec&lt;/span&gt; &lt;span class="n"&gt;tincidunt&lt;/span&gt; &lt;span class="n"&gt;augue&lt;/span&gt; &lt;span class="n"&gt;nisi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="n"&gt;pellentesque&lt;/span&gt; &lt;span class="n"&gt;nisl&lt;/span&gt; &lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;vel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;porttitor&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt; &lt;span class="n"&gt;quam&lt;/span&gt;&lt;span class="p"&gt;]:&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;lipsum&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From an HTML output point of view, both examples generate the exact same output.&lt;/p&gt;
&lt;p&gt;In both cases, the examples are presented as I would normally include them in my
articles, folding each line after the 90 characters that I keep my Markdown editor set
to.  Applying my own stylistics, when I add an inline link I ensure that it begins at
the start of a new line to ensure that I can clearly identify it as a link.  In
trying an equivalent example with a reference link instead of an inline link, the
style that I chose was to place the link label delimiters (&lt;code&gt;[&lt;/code&gt; and &lt;code&gt;]&lt;/code&gt;) around the link
label itself with no change in formatting, with the link reference definition following
later in the document.  While link reference definitions can precede or follow
any reference links that use them, to me this seemed like the right way to do it.&lt;/p&gt;
&lt;p&gt;From my point of view, I find that the inline reference provides better readability for
me and how I read my articles when authoring them.  Perhaps it is through having
authored and proofed many articles in this format, but to me, not having the link
information right in the paragraph feels like a grammatical or spelling error. And
while I didn’t really think about it before, when proofing the Markdown version of
my articles, I don’t really “see” the link destination and link title until I slow down
on my final passes.  Regardless of the reasoning behind it, I just find it works better
for me to read the Markdown version of articles with inline links.&lt;/p&gt;
&lt;p&gt;Please note that this view is solely my own.  When performing a similar evaluation for
yourself or your organization, it is important to consider your own criteria when
determining which options, reference links or inline links, is best for you.&lt;/p&gt;
&lt;h2 id="hitting-implementation-issues"&gt;Hitting Implementation Issues&lt;a class="headerlink" href="#hitting-implementation-issues" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having implemented inline links as documented in the
&lt;a href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/#implementing-the-algorithm"&gt;last article&lt;/a&gt;,
I started working on the link reference definitions thinking they would be easy.  In
the case of the first example,
&lt;a href="https://github.github.com/gfm/#example-161"&gt;example 161&lt;/a&gt;, it was in fact pretty easy.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A complete link label, followed by both a link destination and a link title.  All on
one line.  Then add a simple shortcut reference link to reference the previously added
link reference definition.  Nice. Compact.  Complete.&lt;/p&gt;
&lt;p&gt;It was when I moved on to
&lt;a href="https://github.github.com/gfm/#example-162"&gt;example 162&lt;/a&gt;
that all of the issues started:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="w"&gt;   &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;      &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;           &lt;/span&gt;&lt;span class="s1"&gt;'the title'&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The first important issue to understand is that link reference definitions are
processed as leaf nodes instead of inline text.  To keep the memory footprint of the
parser low, I made an early design decision to
only get the text from the input source one line at a time.&lt;sup id="fnref:lineByLine"&gt;&lt;a class="footnote-ref" href="#fn:lineByLine"&gt;2&lt;/a&gt;&lt;/sup&gt;  While the
proper implementation of that design is still in the future, that design limits the main
parsing function of the parser to only knowing about the current line, with no
built-in capacity for look-ahead or look-behind.  Remember this issue, as I will get
back to it in just a minute.&lt;/p&gt;
&lt;p&gt;The second important issue is that unlike all previous leaf node elements, it can take
multiple lines to determine if the current link reference definition element is valid.
In example 162, as provided above, it isn’t until the end of line following the second
&lt;code&gt;'&lt;/code&gt; character on line 3 that the link reference definition is determined to be valid.
To better highlight this problem, consider
&lt;a href="https://github.github.com/gfm/#example-165"&gt;example 165&lt;/a&gt;
which provides for an exaggerated example of this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;
&lt;span class="s1"&gt;title&lt;/span&gt;
&lt;span class="s1"&gt;line1&lt;/span&gt;
&lt;span class="s1"&gt;line2&lt;/span&gt;
&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the link reference definition as stated in example 165 is valid, it isn’t until
the 5th line, where the second &lt;code&gt;'&lt;/code&gt; character followed by the end of the line
closes off the link title, that the entire link reference definition is deemed valid.
By making one small change to the previous example, removing that previously mentioned
5th line, that entire link reference definition is rendered invalid, as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;line1&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="n"&gt;line2&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After that one small change, instead of a link reference definition followed by a valid
link reference, both elements are now just interpreted as plain text.&lt;/p&gt;
&lt;p&gt;Remember a couple of paragraphs ago when I mentioned “remember this issue” when talking
about processing link reference definitions as leaf nodes?  Here is the payoff.&lt;/p&gt;
&lt;p&gt;Because of my design choice to process the Markdown document one line at a time, I
needed to add extra logic to the parser to allow me to “rewind” those lines.  In the
case of the modified example 165, the entire link reference definition is rendered
invalid, and the parser must rewind to the start of the link reference definition.
However, when it starts parsing the lines again, care must be taken to inform the
parser that it cannot consider the newly rewound lines to be eligible for a valid
link reference definition.  Painful, but not too painful.&lt;/p&gt;
&lt;p&gt;Following along from that change, if we do a similar change to example 162 by removing
the final &lt;code&gt;'&lt;/code&gt; character
from the definition, it poses a different problem.  While the removal of the 5th line of
example 165 invalidates the entire link reference definition, removing the final &lt;code&gt;'&lt;/code&gt;
character from example 162 only invalidates the link title, leaving the rest of the link
definition valid.  To deal with this, I needed to not only have logic to go backwards
towards the start of the link reference definition, but to stop that rewinding if
whatever part of the definition that was not rewound turned out to be a valid
definition.  While the rewinding was a headache and somewhat obvious&lt;sup id="fnref:parsing"&gt;&lt;a class="footnote-ref" href="#fn:parsing"&gt;3&lt;/a&gt;&lt;/sup&gt;,
aborting the rewinding if a valid link reference definition “fragment” was found was
not obvious to me at all.&lt;/p&gt;
&lt;p&gt;That code was painful.  Honestly speaking, that logic alone took about half of the 5
days required to get the multiple-line aspect of link reference definition parsing
properly.  A decent amount of that time was taken up with rewriting the logic for
extracting the link
label, link definition, and link title to handle being straddled over multiple lines.
But the real “fun” was making sure that rewinding the lines would properly rewind the
token stream and token stack in the parser.&lt;/p&gt;
&lt;p&gt;While it took a lot of work to get there, it was personally fulfilling when I got it
right.  It wasn’t an easy issue to solve, and coming up with a clean solution wasn’t
easy.  As an added bonus, my dog stopped looking at me with a funny expression.  It
was pointed out to me that he did that when facepalmed myself whenever I got the
parsing wrong.  Personally, I considered that a 2-in-1 benefit!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There have only been a few issues that have taxed my experience to solve them, and
implementing link reference definitions was one of them.  That is both a good thing and
a bad thing.  On the good side, due to my experience and stubbornness, I was able to
modify my implementation to deal with the issue without having to change my design
decision.  On the bad side, there is only one test with a link reference definition
being within a container block, and that leaves a lot of questions about how to handle
failures within those containers.  While I noted the later down for subsequent testing,
it still leaves me feeling a bit uneasy that I had to modify the parser to handle that.&lt;/p&gt;
&lt;p&gt;Considering where I am with the parser, I am glad that I hit that issue now, and not
after I finished the parser.  While it was painful to go through, it did reinforce
a number of things about the design of the parser so far.&lt;/p&gt;
&lt;p&gt;The first thing that was
reinforced was that, with only one exception, my early decision to do line-by-line
parsing is viable.  While there may be parser extensions that change that, the
number of exceptions in the link reference definition category should be low.  If
I can then combine that with some Python generator logic, hopefully I can keep the
memory profile of the parser low.&lt;/p&gt;
&lt;p&gt;The second thing that was reinforced was that the general structure of the parser was
properly designed and implemented.  While I still need to take some time and refactor
individual
groups of functions into their own modules, the actual function themselves are pretty
durable.  With the exception of the link helper functions and a few core functions, I
did not have to change any other functionality to handle the failure rewind scenario.
In those few functions I changed, it was either to specifically handle that scenario
or to pass information back to the main parser function about how to handle the rewind.
Compared to past situations I have encountered, I consider it a benefit
that I only had to change the small amount of code that I did.&lt;/p&gt;
&lt;p&gt;Finally, my decision to use inline links over reference links was reinforced. In more
closely examining the difference between the
two types of links, I believe I better understand and appreciate both types of links.
While I agree that writing Markdown with reference links will more closely approximate
how the paragraphs will look when completed&lt;sup id="fnref:JohnGruberMarkdown"&gt;&lt;a class="footnote-ref" href="#fn:JohnGruberMarkdown"&gt;4&lt;/a&gt;&lt;/sup&gt;, the absence of the
link destination and link title reduce my comprehension of the paragraph as a whole.
So I find myself making the same decision as before, but now I believe I can more
clearly communicate the options for both types of links and why I chose inline links
over reference links.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The list of what is left to complete in the parser is getting shorter and shorter.
With inline links and link reference definitions tested and completed, only the
full implementation of reference links and image links remain.  While a lot of
foundation work has already been set up for these features, I am wary of declaring
that it will be an easy job from here on it.  But with only 2 features left, I know
the start of the real linting work in coming soon!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:normalized"&gt;
&lt;p&gt;Long winded version: To normalize a label, strip off the opening and closing brackets, perform the Unicode case fold, strip leading and trailing whitespace and collapse consecutive internal whitespace to a single space.  Shorter version: reduce or eliminate whitespace and do a case-insensitive comparison. &lt;a class="footnote-backref" href="#fnref:normalized" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref2:normalized" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref3:normalized" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:lineByLine"&gt;
&lt;p&gt;To keep the memory footprint of a parser low, the parser design should try and only keep the information that is required for parsing in memory.  By parsing the Markdown input line by line, I do not have to worry about having to load the entire Markdown input into memory before I can begin parsing it. &lt;a class="footnote-backref" href="#fnref:lineByLine" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:parsing"&gt;
&lt;p&gt;Except for a Lisp parser that I once wrote, I cannot think of a single parser where I didn’t have to rewind at least one complex entity out of the 25+ parsers that I have written. &lt;a class="footnote-backref" href="#fnref:parsing" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:JohnGruberMarkdown"&gt;
&lt;p&gt;As per John Gruber’s original intentions.  Go to &lt;a href="https://daringfireball.net/projects/markdown/syntax#em"&gt;this part&lt;/a&gt; of his original Markdown article and go to the paragraph preceding the start of the emphasis section.  For more complete information on why John felt that reference links were better, look further up in that section for more details. &lt;a class="footnote-backref" href="#fnref:JohnGruberMarkdown" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Adding Inline Links</title><link href="https://jackdewinter.github.io/2020/03/30/markdown-linter-adding-inline-links/" rel="alternate"></link><published>2020-03-30T00:00:00-07:00</published><updated>2020-03-30T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-30:/2020/03/30/markdown-linter-adding-inline-links/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having just implemented the
&lt;a href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/"&gt;Inline Emphasis&lt;/a&gt; feature
as documented in my last article, I was eager to move forward with the implementation
of the links feature.  As the group of features under links were the only ones
separating me from the completion of the project’s parser, I was …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having just implemented the
&lt;a href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/"&gt;Inline Emphasis&lt;/a&gt; feature
as documented in my last article, I was eager to move forward with the implementation
of the links feature.  As the group of features under links were the only ones
separating me from the completion of the project’s parser, I was happy when I noticed
that I was starting to think “when the parser is done” instead of
“if the parser is EVER done”. I have been working on this project for a while and it
was nice to know that in my mind, I could “see the light” with respect to this
project.&lt;/p&gt;
&lt;p&gt;In implementing the algorithm outlined in the section
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;Phase 2: inline structure&lt;/a&gt;,
I chose to implement the emphasis feature first, leaving the implementation of links
until the base algorithm and emphasis feature were implemented and tested.  Seeing as
both of those were accomplished, I felt that it was the right time to apply my
success in implementing the emphasis feature to the link feature.  I knew that the
work on the delimiter stack would easily carry over, but I was eager to see if the
implementation of the next part of links would be as easy as the implementation of
emphasis.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commit of
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/a0deb2e362adebd2bb65fd0095e5add160f1dfad"&gt;17 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="why-inline-links"&gt;Why Inline Links?&lt;a class="headerlink" href="#why-inline-links" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a quick peek ahead, I observed that the link feature in the specification is
broken down into four groups:
&lt;a href="https://github.github.com/gfm/#inline-link"&gt;inline links&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#link-reference-definitions"&gt;link reference definitions&lt;/a&gt;,
&lt;a href="https://github.github.com/gfm/#reference-link"&gt;reference links&lt;/a&gt;, and
&lt;a href="https://github.github.com/gfm/#images"&gt;image links&lt;/a&gt;.
Based on a quick reading of each section, it was obvious to me that for reference links
to work properly, link reference definitions would be needed.  Image links are
variations on the inline link type and reference link type, the only difference being a
different start
delimiter.  As such, I didn’t see any benefit to implementing image links
before those other two link types are completed.  This leaves inline links. Inline
links are self-contained, allowing them to be implemented separately from the other
three groups.  Being somewhat impatient to get the parser done, I decided to go for the
sub-feature that was more immediately available: inline links.&lt;/p&gt;
&lt;h2 id="i-use-inline-links-almost-exclusively"&gt;I Use Inline Links (Almost) Exclusively&lt;a class="headerlink" href="#i-use-inline-links-almost-exclusively" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When writing my articles and documentation, I personally find it more readable to
include any
links in my documents as a complete unit.  This means that when I add a link, I will
typically add it in the form shown in the GFM specification at
&lt;a href="https://github.github.com/gfm/#example-494"&gt;example 494&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a concrete example of this, the above link to example 494 that precedes the sample
link format was created with the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt; &lt;span class="mi"&gt;494&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;gfm&lt;/span&gt;&lt;span class="o"&gt;/#&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;494&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the form can be augmented as such:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to provide a title, I cannot remember a case where I have used that form.
While I do not have a strong reason for or against this format, I believe that I just
have not encountered a case where I believe that a title for the link was either
desired or required.  On the other hand, I have used the following form a number of
times before:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as an alternative to the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;my&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While my use of the angle bracket form is rare, it was useful in a couple of cases
where I needed to provide a space character as part of an URI.  While different
Markdown-to-HTML processors will handle the space character differently, I just wanted
something that read well and was mostly universal.&lt;/p&gt;
&lt;h2 id="what-is-an-inline-link"&gt;What is an Inline Link?&lt;a class="headerlink" href="#what-is-an-inline-link" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For a well documented answer to this question, please look at the
&lt;a href="https://github.github.com/gfm/#inline-link"&gt;inline link section&lt;/a&gt; of the GFM for
a word-for-word answer, complete with helpful examples.  My own summarization of
this section is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;an inline link occurs on a single line and comprised of the link text, a left parenthesis, an optional link destination followed by an optional whitespace and an optional link title, and a right parenthesis&lt;/li&gt;
&lt;li&gt;if in doubt about any punctuation characters in the below constructs, backslash escape them&lt;/li&gt;
&lt;li&gt;the link text is any text that appears between the opening square brackets (&lt;code&gt;[&lt;/code&gt;) and the closing square brackets (&lt;code&gt;]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;the link destination is any non-space, non-control characters, with special rules for the &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;(&lt;/code&gt;, and &lt;code&gt;)&lt;/code&gt; characters&lt;/li&gt;
&lt;li&gt;the link title, if included, is contained within a single-quoted string (&lt;code&gt;'&lt;/code&gt;), double-quoted string (&lt;code&gt;"&lt;/code&gt;), or a parenthesized string (&lt;code&gt;(&lt;/code&gt; and &lt;code&gt;)&lt;/code&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;After 5 revisions to try and keep my answer “minimal”, that is it!  While I could leave
it in a more complicated state, that summary is what I believe I have it broken down
to in my head.  For me, the first two points are the pivotal ones, setting up the link
component order and exclusions needed to create valid inline links.  The last three
rules are just simplifications of what is needed to represent each of the three
components, rounding out the definition for inline links.&lt;/p&gt;
&lt;p&gt;Keeping to those rules, when I am picturing Markdown links in my head, I usually think
of these two forms:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;"title"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Between the 5 rules stated above and these two examples, I believe I am keeping it
simple and minimal, ensuring my consistent use of links.  Let me dive into those
a bit more.&lt;/p&gt;
&lt;p&gt;In terms of the order of components, the link text and both outer parentheses are
required for the inline links, but both the link destination and link title are
optional.  However, due to how they are documented, if a link title is desired, a link
destination must precede it.  Basically, the component order is always: the text that
shows up inside of the link’s anchor, the link URI itself, and a title to use when the
link is traversed.  Once again, I keep it simple to make it easy to use.&lt;/p&gt;
&lt;p&gt;For remembering when to use punctuation characters and backslashes to escape them,
I once again try to keep it simple.  The second rule is the embodiment of that.  My
definition of “if in doubt”, as stated in the second rule, is that if I have to think
“is this punctuation part of the link or not?”, I have doubt.  Therefore, if I am
authoring a
link and am not sure if I should backslash escape punctuation within a link, I escape
it.&lt;/p&gt;
&lt;p&gt;Those first two rules are specifically tailored for me and to how I write my articles.
My primary
goal in coming up with those rules is to allow me to author rough drafts of
my articles as I go, links included.  During the rough draft phase, as efficiently as
possible, I need to leave
enough information in the added links to allow me to finish each link in subsequent
passes through the document. While the “as I go” element isn’t present in the
subsequent passes when I clean up the link, I do need
to make sure that I keep those passes as efficient as possible.  By keeping those rules
simple, I reduce the amount of friction incurred by adding links to the documents,
therefore keeping those passes efficient.&lt;/p&gt;
&lt;p&gt;An additional benefit to using those rules is the simplification of the specification’s
acceptable rules.  Specifically, the wording of my two first points helps me avoid a
lot of the weird cases included in the 41 test cases for inline links.  The two most
frequent reasons for the examples containing weird cases are the inclusion of newline
characters
and the inclusion of extra punctuation characters.  The “single line” part of the first
rule
helps me avoid any of those newline cases, and the “if in doubt” part of the second rule
helps me avoid any of the cases with extra punctuation.&lt;/p&gt;
&lt;p&gt;My conservative estimate is
that by adding those extra words to my personal rules, I was able to reduce the number
of “applicable” cases for links that I am authoring in half, if not a bit more.  While
that might sound like a weird statement to make, for me it means that I when am
authoring a document and adding a link, I can keep my focus on the what I am adding to
the document, and not focus on trying to remember all of the weird cases for links and
how to avoid them.  For me, that is a plus.&lt;/p&gt;
&lt;h2 id="implementing-the-algorithm"&gt;Implementing the Algorithm&lt;a class="headerlink" href="#implementing-the-algorithm" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having constructed and tested the delimiter stack and emphasis parts of the algorithm,
as documented in the last article on
&lt;a href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/"&gt;Inline Emphasis&lt;/a&gt;,
it was time to implement the &lt;code&gt;look for link or image&lt;/code&gt; part of that algorithm.  Once
again, in an effort to keep things simple, I added very minimal support for image links
(as detailed in the algorithm), but that support also added &lt;code&gt;assert False&lt;/code&gt; statements
to ensure
that any scenarios with images were clearly identifiable and not executable.  This
helped to prevent me
from accidentally working on testing image link features before adding the real support
for them in a subsequent feature.&lt;/p&gt;
&lt;p&gt;While the link part of algorithm doesn’t have as many special cases as the 17 rules for
emphasis, there are a decent number of elements to keep track of when implementing the
links portion of the algorithm.  I found that by following the examples and the
algorithm as stated,
I was able to quickly isolate the changes for each example.  This isolation allowed me
to to cleanly implement each small change with a
clear idea of what was needed to be accomplished.  As I am human, there were a number of
issues I initially had in following various portions of the algorithm.  In all of those
cases, a
quick re-read of
the section helped me get the proper information I needed to implement that portion of
the links.&lt;/p&gt;
&lt;p&gt;Out of the 41 total examples for inline links, only the first 6 are ones that I would
consider normal examples, the remaining 35 testing special cases and boundary
conditions.  As such,
I started with the first example,
&lt;a href="https://github.github.com/gfm/#example-493"&gt;example 493&lt;/a&gt;,
and added the code necessary to do a simple parsing of each of the components of that
example: link text, link destination, link title, link format separators and link
whitespace.  Then I simply started working my way down the list of examples,
refining each implementation with each example that I worked on.  With each example
that I cleared, the implementation visibly got closer to it’s final implementation.&lt;/p&gt;
&lt;p&gt;I am not too proud to admit that on my first reading of a lot of the examples, I
questioned what their worth to the feature was.  However, as I worked down the list of
examples, the questioning changed into enjoyment.  Each new example added a small layer
of complexity to the implementation, like a piece of a puzzle cleanly fitting into
place.  Even concepts that I worried about, like new lines
and backslashes, were given enough examples to clearly and properly demonstrate how
they worked.
There were a couple of times where I questioned whether or not an example was really
needed, but those instances were few and far between.&lt;/p&gt;
&lt;h2 id="where-i-had-problems"&gt;Where I had problems&lt;a class="headerlink" href="#where-i-had-problems" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The addition of inline links to the project went without too many issues.  The most
prominent of these were the proper encoding of special characters in the links and the
interactions between links and emphasis.&lt;/p&gt;
&lt;p&gt;In terms of the special characters, the main problem that I had was in selecting an
interpretation of the term “special characters” that was consistent with the GFM
specification, and
hence the CommonMark implementation.  The first group of characters, the ones to
replace with named HTML entity names is small, so examples such as
&lt;a href="https://github.github.com/gfm/#example-514"&gt;example 514&lt;/a&gt;
and
&lt;a href="https://github.github.com/gfm/#example-517"&gt;example 517&lt;/a&gt;
were easy to implement and get right on the first try.  From an HTML author’s point
of view, it was pretty obvious that the following Markdown from example 517:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s1"&gt;'title "and" title'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;should produce the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"/url"&lt;/span&gt; &lt;span class="na"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"title &amp;amp;quot;and&amp;amp;quot; title"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Taking that a bit further, the next groups was still pretty simple.  Any characters that
are represented by more than 7 bits needed Unicode encoding, which I also thought was
pretty obvious.  Once again, from an HTML author’s point of view, the following
Markdown from
&lt;a href="https://github.github.com/gfm/#example-511"&gt;example 511&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;auml&lt;/span&gt;&lt;span class="p"&gt;;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;would obviously translate into the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"foo%20b%C3%A4"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;link&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Verifying this was correct was pretty simple.  I had to look at the project’s
&lt;code&gt;entities.json&lt;/code&gt; file for the information on
the &lt;code&gt;&amp;amp;auml;&lt;/code&gt; symbol.  From there I quickly verified that it is represented by the
Unicode sequence
&lt;code&gt;\u00E4&lt;/code&gt;, which becomes the sequence &lt;code&gt;%C3%A4&lt;/code&gt; when encoded with &lt;code&gt;utf-8&lt;/code&gt;.  This was all
done with Python’s &lt;code&gt;urllib&lt;/code&gt; module, specifically with the &lt;code&gt;urllib.parse.quote&lt;/code&gt;
function, and it got all of these right on the first try.&lt;/p&gt;
&lt;p&gt;The issue came to the proper encoding of characters with an ordinal value below 127
(or 7F hex) that were not control characters and not alphanumeric characters. By
default, the only character that is considered safe according to the
&lt;code&gt;urllib.parse.quote&lt;/code&gt; function is the &lt;code&gt;/&lt;/code&gt; character.  When the parser
emitted the HTML for those many of those remaining characters, it replaced the actual
character with the percent-form of that character.  While both approaches are usually
syntactically equivalent, the
comparison failed because the URI was not exactly the same as the example’s output. It
was only over the course of a number of examples that the punctuation character safe
list from above was constructed.&lt;/p&gt;
&lt;p&gt;The second group of issues came around the interaction between normal inline processing
and the processing used for links.  In cases such as
&lt;a href="https://github.github.com/gfm/#example-524"&gt;example&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;link&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="o"&gt;`#`*&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;all of the inline processing occurs within the link text section, and is pretty
unambiguous to what the intent is.  However, in the cases of
&lt;a href="https://github.github.com/gfm/#example-529"&gt;example 529&lt;/a&gt; to
&lt;a href="https://github.github.com/gfm/#example-534"&gt;example 534&lt;/a&gt;,
it is not as clear as to what the intent of the author was.  In the case of
&lt;a href="https://github.github.com/gfm/#example-530"&gt;example 531&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;](&lt;/span&gt;&lt;span class="n"&gt;baz&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it is not clear to me at all what the author would have intended with this Markdown.
Can you figure it out?
The good news is that the GFM specification is really clear on the precedence of each
of the inline processes, but even still, it took me a bit to get that precedence
properly implemented.  &lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the exception of adding a metadata feature and a table of contents feature, both
which are unofficial extensions, every other feature that I normally use when writing
articles is now implemented and tested.  Having hit that personal milestone, it is a
good feeling knowing that I am THAT close to being able to run PyMarkdown against my own
articles to lint them.  The only other core feature that I sometimes use is the
image link feature, and I know that is just a couple of features away.&lt;/p&gt;
&lt;p&gt;In terms of the feature implementation and testing for this feature, the issues
I had were either caused by my misreading of the specification or caused by trying to
skip forward in the examples, and not
following the example order set out in the GFM specification.  As I have mentioned
numerous times in this section of past articles, the GFM specification is well thought
out and battle tested from many implementations.  While I do recognize that and heap
praise on them, at the same time I seem to think that I either know better than they
do or know where they are going, hence my skips forward.  I need to stop that, as it
seems to be keep getting me in trouble.&lt;/p&gt;
&lt;p&gt;Except for a couple of “didn’t I learn this already?” moments, things went fine. My
guess is that I will learn to trust this specification properly just before I finish
the last example.  Go figure.  In all seriousness, I am going to try and put more
effort into following the specification and it’s examples in their proper order for
the next feature, and try and get it locked in.  If I had a great specification, I
need to learn to lean into it for support, and not fight against it.&lt;/p&gt;
&lt;p&gt;At the start of this article, I expressed an interest to see if the implementation of
inline links would be as easy as the implementation for emphasis.  While there are
differences, the 17 rules around emphasis and the looking for a complete inline link
after having found the link label itself, I am pretty convinced that the effort
required to implement each of them was pretty similar.  As an added bonus, having taken
a quick look at all of the features in the link group, I am pretty sure that the work
for inline links will be heavily leveraged to complete the link group itself.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Emphasis and link support and delimiter stack?  Done and tested.  Inline support for
links?  Done and tested.  Before going on to reference links and image links, it only
made sense to do link reference definitions next, so that is where I implemented next,
though not without a lot of difficulties.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Adding Inline Emphasis</title><link href="https://jackdewinter.github.io/2020/03/23/markdown-linter-adding-inline-emphasis/" rel="alternate"></link><published>2020-03-23T00:00:00-07:00</published><updated>2020-03-23T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-23:/2020/03/23/markdown-linter-adding-inline-emphasis/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have been reading and implementing specifications for a long time.  I truly
believed that I had seen with and dealt with every situation presented in any
specification. I was therefore surprised when I started reading the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
and I noticed an entry in the table of contents …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I have been reading and implementing specifications for a long time.  I truly
believed that I had seen with and dealt with every situation presented in any
specification. I was therefore surprised when I started reading the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
and I noticed an entry in the table of contents labelled
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;Phase 2: inline structure&lt;/a&gt;.
Thinking “if it is in the table of contents as a separate entry, it must be important”,
I started reading that section, waiting for some big revelation to appear.&lt;/p&gt;
&lt;p&gt;That Phase 2 section starts with an example which is an extension of the example used
in the preceding section in the document.  After a bit of comparison with the
previous example, it should be obvious that the string &lt;code&gt;\n&lt;/code&gt; was changed to &lt;code&gt;softbreak&lt;/code&gt;
and the string &lt;code&gt;"Qui *quodsi iracundia*"&lt;/code&gt; was changed to
&lt;code&gt;str "Qui " emph str "quodsi iracundia"&lt;/code&gt;.  Going back to my article on
&lt;a href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/"&gt;Autolinks, Raw HTML, and Line Breaks&lt;/a&gt;,
the translation from &lt;code&gt;\n&lt;/code&gt; to the soft line break (or soft-break) is easy to see,
the inline parser code to perform that translation having just been implemented.  And
looking at the provided example, emphasis looked like it was going to be easy.  So why
include implementation notes on it if it was so easy?&lt;/p&gt;
&lt;p&gt;On the surface, the translation of emphasis markers to emphasis would seem to be easy
to understand, if not for the start of the next section of Phase 2:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By far the trickiest part of inline parsing is handling emphasis, strong emphasis, links, and images. This is done using the following algorithm.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I was kind of skeptical, but I continued reading… and reading… and reading.
After a couple of thorough reads of the section in the GFM specification on
&lt;a href="https://github.github.com/gfm/#emphasis-and-strong-emphasis"&gt;Emphasis and strong emphasis&lt;/a&gt;,
I started to understand why emphasis is not as easy as it seems. At it’s root it is
pretty simple: use one &lt;code&gt;*&lt;/code&gt; for emphasis and &lt;code&gt;**&lt;/code&gt; for strong emphasis.  No problems
there.  If you need a subtle change in the emphasis rules, primarily around intra-word
use and use around punctuation, use &lt;code&gt;_&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt;. Okay…why do I need so many
rules?&lt;/p&gt;
&lt;p&gt;Isn’t it &lt;em&gt;as easy&lt;/em&gt; as &lt;strong&gt;this&lt;/strong&gt;?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Isn&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;easy&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="o"&gt;**?&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It took a bit more reading, but for me, it was when the finally some questions from
the specification that made me understand.  The big revelation finally hit me in
the form of those questions and the ambiguity that they raised.&lt;/p&gt;
&lt;p&gt;How are the following cases from the specification of strong emphasis interpreted?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;***strong emph***
***strong** in emph*
***emph* in strong**
**in strong *emph***
*in emph **strong***
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;How about the following cases of nested emphasis?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*emph *with emph* in it*
**strong **with strong** in it**
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And finally, how about intra-word emphasis?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;internal emphasis: foo*bar*baz
no emphasis: foo_bar_baz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For most of those examples, I could come up with at least 2-3 different ways that
they could be parsed.  As such, it is probably a good idea that there are 17 rules to
help out with emphasis.  But before I could work on the implementation, I needed to
do some more research.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/ad66340685ba128fa522a6d275ae55348951c96c"&gt;10 March 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/23e77f98d9ab4a7a8d05285cbc11293a96c9ed11"&gt;13 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="emphasis-is-hard-and-not-always-consistent"&gt;Emphasis is Hard and not always Consistent&lt;a class="headerlink" href="#emphasis-is-hard-and-not-always-consistent" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For any readers that have been following this series, it might be apparent that I have
veered away from my usual habits.  Usually I label all of my Markdown code blocks
properly to allow my
&lt;a href="https://jackdewinter.github.io/2019/08/25/static-websites-setting-up-the-pelican-static-site-generator/"&gt;static site generator&lt;/a&gt;
to take care of the proper coloring. However, for the above examples, I just marked
them as normal text blocks without any language specified.  This
was not a mistake, it was a conscious decision.&lt;/p&gt;
&lt;p&gt;When I started entering the fenced code
block for the text, everything looked normal. However, once I added the &lt;code&gt;Markdown&lt;/code&gt;
language tag at the start of the block, that all changed.  What I saw in my VSCode
editor was the following:&lt;/p&gt;
&lt;p&gt;&lt;img alt="python logo" src="https://jackdewinter.github.io/images/linter-12/vscode.png"/&gt;&lt;/p&gt;
&lt;p&gt;Publishing the page and looking there, I saw that same text rendered as:&lt;/p&gt;
&lt;p&gt;&lt;img alt="python logo" src="https://jackdewinter.github.io/images/linter-12/chrome.png"/&gt;&lt;/p&gt;
&lt;p&gt;And finally, running it through my favorite GFM test link, the following was generated:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;strong emph&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;
&lt;em&gt;&lt;strong&gt;strong&lt;/strong&gt; in emph&lt;/em&gt;&lt;br/&gt;
&lt;strong&gt;&lt;em&gt;emph&lt;/em&gt; in strong&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;in strong &lt;em&gt;emph&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;
&lt;em&gt;in emph &lt;strong&gt;strong&lt;/strong&gt;&lt;/em&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;Three different platforms and three different ways to interpret the emphasis.
To me, it was then that it was really apparent why a consistent way to implement
emphasis was needed in order to produce consistent results.&lt;/p&gt;
&lt;h2 id="utilizing-the-wisdom-of-others"&gt;Utilizing the Wisdom of Others&lt;a class="headerlink" href="#utilizing-the-wisdom-of-others" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Instead of trying to figure everything out myself, tempting as that can be sometimes,
I decided to implement the algorithm as stated in the GFM specification with one small
change: no links for now. To accomplish this, I kept to the algorithm’s recipe as
described, but I left the implementation of the &lt;code&gt;look for link or image&lt;/code&gt; section for
later.  My plan was to focus on the emphasis itself before moving on to
links, which I still believe was a very good decision on my part.&lt;/p&gt;
&lt;p&gt;In looking at the algorithm through a bit of a sideways lens, I observed that there were
two main tasks that the algorithm accomplishes: building the delimiter stack and
resolving that same delimiter stack.  Without taking a two phase approach to the
algorithm, I determined that I would be multitasking two separate objectives, and not
doing either of them very well.  I just felt strongly that it was better to split the
task in two and focus on each one until it’s completion.  In the end, I was going to
finish both part of the algorithm, so as long as both tasks were done, emphasis would
be implemented.&lt;/p&gt;
&lt;p&gt;The first task: building the delimiter stack.&lt;/p&gt;
&lt;h2 id="building-the-delimiter-stack"&gt;Building The Delimiter Stack&lt;a class="headerlink" href="#building-the-delimiter-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Taking a high level look at the algorithm, I came up with the following two
observations. In cases where a delimiter is not used in a special way, it needs to be
represented by a simple text node.  Where it is used in a special way, it may need to
be removed and properly replaced with the tokens that the delimiters represent. The
“may” part of that last statement is there as, after looking at some of those examples,
it may be possible to have a case where the parser only uses some of the emphasis
delimiters, but not all of them.  Once such example is the string &lt;code&gt;this **is* my text&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To accomplish this, I created a new class &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; that is a child
of the &lt;code&gt;TextMarkdownToken&lt;/code&gt; class.  In cases where the delimiter is not completely
consumed, this allows the new token to be easily consumed by existing code, without
any modifications needed.  Supporting the additional parsing requirements, the new
&lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; tokens adds the &lt;code&gt;repeat_count&lt;/code&gt;, &lt;code&gt;active&lt;/code&gt;, &lt;code&gt;preceding_two&lt;/code&gt;,
and &lt;code&gt;following_two&lt;/code&gt; fields, enabling the algorithm to be implemented properly.
Finally, but most importantly, to ensure the algorithm works properly, that new token
is added to the delimiter stack.&lt;/p&gt;
&lt;p&gt;To properly test that I had produced the correct tokens and delimiter stack,
I started by enabling one of the emphasis tests and examining the resulting tokens.
I compared those tokens against the tokens that were there before, looking for
changes that I expected to be induced by the presence of the emphasis delimiters.  As I
was only building the delimiter stack at this point in the process, this was easy to
verify.&lt;/p&gt;
&lt;p&gt;A solid example of this is the emphasis test for
&lt;a href="https://github.github.com/gfm/#example-364"&gt;example 364&lt;/a&gt;,
which is the example that I selected as my initial test.  That example contains the
string &lt;code&gt;foo*bar*&lt;/code&gt; to test against and is a pretty easy example. Before the delimiter
stack was built, I verified that the string was represented by a single
&lt;code&gt;TextMarkdownToken&lt;/code&gt; token containing the string &lt;code&gt;foo*bar*&lt;/code&gt;.  After the delimiter stack
was built, that same string was represented by 4 tokens:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;code&gt;TextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;TextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;bar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;a &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt; token with the string &lt;code&gt;*&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In addition, the delimiter stack contained both of the &lt;code&gt;SpecialTextMarkdownToken&lt;/code&gt;
tokens in the order that they appear.  At this point in the process, that was the
expected token output, and I was happy to see it work so well.&lt;/p&gt;
&lt;p&gt;As one good test wasn’t solid proof to me, I continued to make sure that I had decent
results after building the delimiter stack by repeating this examination with 5-6
other tests.  While there were a couple of small issues along the way, I was able to
quickly get to the part where I had a high degree of confidence that the delimiter
stack was correct.  Now it was on to the resolution of that stack.&lt;/p&gt;
&lt;h2 id="resolving-the-delimiter-stack"&gt;Resolving the Delimiter Stack&lt;a class="headerlink" href="#resolving-the-delimiter-stack" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Skipping past the &lt;code&gt;look for link or image&lt;/code&gt; section of the GFM specification, I sat down
with my headphones on and poured over the section on &lt;code&gt;process emphasis&lt;/code&gt; a couple of
times, taking notes as I went.  I then went back to the
&lt;a href="https://github.github.com/gfm/#emphasis-and-strong-emphasis"&gt;emphasis scetion&lt;/a&gt;
of the GFM and started pairing each of the 17 rules to each note that I made and was
happy to find a 1-to-1 mapping between the two lists.&lt;/p&gt;
&lt;p&gt;And yes, that’s right… 17 rules.  It did take a while, but I validated each step
in the specification against each of the rules, making detailed notes as I went.  While
it was slow to emerge, by the time I reached the last rule I had a plan to follow.
To implement each rule, I would implement the tests in order of the rules that they
support, with a slightly irregular start order.  Basically, instead of starting with a
“1 2 3 4” order, I started with a “3 1 4 2” order.  The reason for this weird ordering
is because the algorithm starts by identifying eligible closing emphasis, then trying
to locate a matching start emphasis.  To accommodate that, I decided to start with the
close and start pair for the normal emphasis (&lt;code&gt;*&lt;/code&gt; character) following that same pattern
with the strong emphasis (&lt;code&gt;_&lt;/code&gt; character).&lt;/p&gt;
&lt;p&gt;While I was thankful for the examples in the GFM specification before implementing
emphasis, having the emphasis examples, rules, and examples-by-rule-groups made me
even more thankful.   Starting with rules 3 and 1, I was able to get solid code written
to implement what was needed to support those rules.  The next two rules, rules 4
and 2, were added using the first two rules as a building block.  For the remaining
13 rules, I just felt that each rule and the examples to support it just naturally
flowed, each one adding another small piece of the puzzle.  While it did take some
time to get all 17 rules implemented and the tests for all 130 examples passing, it
all felt like just another step.  It was a nice feeling.&lt;/p&gt;
&lt;h2 id="emphasis-the-base-cases"&gt;Emphasis - The Base Cases&lt;a class="headerlink" href="#emphasis-the-base-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I progressed with the rules, it was nice to see the natural progressing in the
sequences that I was enabling for the parser.  This progression was so natural
and straightforward, I want to take the time to show how things progressed over
the course of the 17 rules.  The honest truth is that when I was finished, it felt
more like 4-5 rules than 17 rules.&lt;/p&gt;
&lt;p&gt;In order of enablement, first there were
the simple sequences enabled in rules 1 to 4:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;This is *my* emphasis.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;This is &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;my&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; emphasis.&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; emphasis.&lt;/p&gt;
&lt;p&gt;Rules 5 to 8 added strong emphasis:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;This is *my* **strong** emphasis.
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;This is &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;my&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;strong&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; emphasis.&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This is &lt;em&gt;my&lt;/em&gt; &lt;strong&gt;strong&lt;/strong&gt; emphasis.&lt;/p&gt;
&lt;p&gt;Rules 9 and 10 added clarity on how to handle nested emphasis:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*foo**bar**baz*
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em&gt;foo&lt;strong&gt;bar&lt;/strong&gt;baz&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Rules 11 and 12 add clarity on escaping delimiters and how excess delimiters are
handled:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;***foo**
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;*&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;*&lt;strong&gt;foo&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="emphasis-resolving-the-ambiguity-of-complex-cases"&gt;Emphasis - Resolving the Ambiguity of Complex Cases&lt;a class="headerlink" href="#emphasis-resolving-the-ambiguity-of-complex-cases" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Using just the prior rules, there were a number of representations that could be
inconsistent from parser to parser.  These rules are used to resolve that ambiguity.
As these rules resolve ambiguity, I am only showing the HTML output in a code block
instead of showing the HTML output in a code block and the actual HTML itself.&lt;/p&gt;
&lt;p&gt;Rule 13 adds the concept that one &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; is preferred to &lt;code&gt;&amp;lt;em&amp;gt;&amp;lt;em&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;******foo******
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 14 adds the concept that the &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; tags should always deeper than the &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;
tags, if used together:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;***foo***
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 15 adds the concept that in a case of overlapping emphasis spans, the emphasis
span that ends first overrides the interpretation of the second possible emphasis
span as an actual emphasis span.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*foo _bar* baz_
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo _bar&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt; baz_&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 16 adds the concept that if two emphasis spans have the same closing delimiter,
the shorter of those two emphasis spans is interpreted as an actual emphasis span.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;**foo **bar baz**
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;**foo &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;strong&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Rule 17 adds a clarification that number of inline elements are more tightly grouped
that emphasis spans, meaning that the parsing of those inline elements takes precedence
over the parsing of the emphasis spans.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*a `*`*
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;a &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;*&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="emphasis-rule-summary"&gt;Emphasis - Rule Summary&lt;a class="headerlink" href="#emphasis-rule-summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Without actually implementing a Markdown parser, it might be hard to appreciate how
natural the process of building the emphasis support into the parser was.  But please
believe me, it was a thing of beauty.  The best way to describe it was that as I
was implementing each section, I jotted down notes for myself that usually started
with “what about…”.  It was usually within a rule or two that I scratched off that
note as it was no longer an issue.  By the time I got to the end of the emphasis
implementation, all of the notes were scratched off.  That kind of progression when
implementing a specification are rare, and it was just really wonderful to witness.&lt;/p&gt;
&lt;h2 id="what-were-the-bumps-on-the-road"&gt;What were the bumps on the road?&lt;a class="headerlink" href="#what-were-the-bumps-on-the-road" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the implementation to support inline emphasis, other than “fat man finger”
typing errors, there were only a couple of issues that impeded it’s addition to the
parser.  The first was because I got impatient and tried to implement one of the rules
ahead of time and the second was caused by a subtle change I made to the algorithm
and the side effects that I needed to abate. Other than those two issues, the
development just flowed easily from the rules and their examples.&lt;/p&gt;
&lt;p&gt;The impatience issue occurred when I was trying to take care of a side-effect of rule
11, but I was trying to take care of it when implementing rule 1.  It side tracked me
for a couple of hours without any resolution.  It wasn’t until I double checked that it
was indeed part of rule 11 that I abandoned it until later.  The “funny” thing is that
when I did get to implementing rule 11 in the proper order, it was implemented with
almost no friction in less than 5 minutes. Because of the way the rules build on
each other, in hindsight it makes perfect sense that I ran into issues trying to
implement part of rule 11 at the beginning.&lt;/p&gt;
&lt;p&gt;The change issue was caused by a subtle change that I made to the algorithm to better
deal with Python’s data structures.  To simplify the implementation in Python, the
references in the
delimiter stack were made with indices (or “indexes” for Americans) instead of pointers.
In the “if one is found” section of the algorithm there are two cases where the
algorithm calls for the removal of nodes from the delimiter stack.  Instead of removing
the elements of the delimiter stack and recomputing the indices, I just altered the
algorithm to work better with the &lt;code&gt;active&lt;/code&gt; field.  While this did cause a number of
small issues that needed to be resolved, in the end I believe it still was a better
course of development to take.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having taken time to do my research and to have a solid plan emerge, it was nice to see
that the plan paying off after the code for the first couple of rules were
implemented.  Often when you plan an approach for a project, in your head you always
think things like “I’ll have to switch to plan B if I see…”.  In this case, while
I still thought that, I was able to stick with my first plan the entire way through.
That was nice and gratifying.&lt;/p&gt;
&lt;p&gt;I also cannot stress how impressed I am with the authors of the GFM specification and
the effort they took to specify the emphasis elements.  Not only did they work hard
to resolve any ambiguity with 17 rules, but they provided a solid road map for
implementers to follow with a suggested approach.  For me, the beauty of those two
part of the specification is how they weave together, each one reinforcing the other
one.  In it’s simplest form, they took something that I was sure was going to be
a headache and made it very easy to implement correctly.&lt;/p&gt;
&lt;p&gt;Basically, I started this part of the parser with a feeling of dread, thinking that
I would plan an approach and have to switch to plan B, or even up to plan F.  But
with some good planning on the behalf of the authors of the GFM specification, it
went off without any major issues.  It was cool to see that happen.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having had a really smooth time implementing emphasis, it was very tempting to just dive
in and tackle all of the link support at the same time.  However, in looking at the
different types of links in the specification, I decided that inline links would be
a good place to start.  That is where I will pick up in my next article!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Verifying Base Scenarios</title><link href="https://jackdewinter.github.io/2020/03/16/markdown-linter-verifying-base-scenarios/" rel="alternate"></link><published>2020-03-16T00:00:00-07:00</published><updated>2020-03-16T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-16:/2020/03/16/markdown-linter-verifying-base-scenarios/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the wrap up for
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#what-was-my-experience-so-far"&gt;my last article&lt;/a&gt;,
I provided extra information on my decision to write a Markdown parser as part of
the PyMarkdown project.  My belief
is that the writing of an effective Markdown linter requires a parser that emits an
intermediate set of tokens instead of …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the wrap up for
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#what-was-my-experience-so-far"&gt;my last article&lt;/a&gt;,
I provided extra information on my decision to write a Markdown parser as part of
the PyMarkdown project.  My belief
is that the writing of an effective Markdown linter requires a parser that emits an
intermediate set of tokens instead of the usual HTML output. Accordingly, from the
start of the project, all of the scenario tests for the parser have dealt with those
generated tokens and not the usual HTML output.  Based on my experience to date,
both the belief in a non-HTML parser and the decision to test the tokens have proven to
be the right choices.  During the project development to date, I have not
observed a specific case where I believe that there would have been a substantial
benefit in comparing the output to HTML instead of the intermediate tokens. However,
even with that in mind, the lack of a direct comparison between the output specified in
the
&lt;a href="https://github.github.com/gfm"&gt;GFM specification&lt;/a&gt;
and the output of the parser started to erode my confidence, even if just fractionally.&lt;/p&gt;
&lt;p&gt;The questions that came to mind were simple ones.  Did I keep the right information
when parsing the Markdown to enable a HTML transformation of the tokens?  Did I pick
the right token to represent a Markdown element in the token stream?  Do the tokens
contain enough information in them to allow me to write linting rules off of them?  For
me, these questions are relevant given the nature of the project.&lt;/p&gt;
&lt;p&gt;Taking a look at those three questions, I quickly realized that answering that last
question was impossible until I start writing the linting rules.  Sure I could take
a guess, but that is all it would be.  However, I realized that I could probably
answer the first two questions and that there was significant benefit to be gained
from doing so.  If I am able to write a token-to-HTML translator and apply it to that
token stream, when the HTML output for all scenarios match, I have answered the first
question.  And while I can’t answer the second question completely, if the translation
to HTML is simple enough, I will have proven that I am headed in the right direction
with respect to making good choices for the representative tokens. While I cannot prove
that those choices are not perfect choices until the rules are written, I can at least
prove to myself that my token choices are in the right direction.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/f9a0e31d0abb8bb22ae071250986f0925f2b7bcb"&gt;29 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/256432757e9a9b2ceca423cf228c5cb362ea61bc"&gt;06 March 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="finishing-up-the-scenario-tests"&gt;Finishing Up The Scenario Tests&lt;a class="headerlink" href="#finishing-up-the-scenario-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For me, this task was essentially a bookkeeping issue.  As the remaining features were
the emphasis elements and the link elements, it felt like the
right time to march through the remaining scenarios and implement them as scenario
tests.&lt;/p&gt;
&lt;p&gt;These scenario tests fell into two categories.  In the first category,
if the scenario needed to test a failure using already implemented features, I copied
over an existing test, changed the Markdown input, executed the new test, and copied
the tokens from the newly executed test output in that test, manually verifying the
tokens as I copied them.
Basically, I figured that if the scenario test is failing in a manner that will not
change even when the owning feature is implemented, then completing the test was the
best choice for the project.
In the second category, I did the same thing except I stopped before the execution step,
instead adding a &lt;code&gt;@skip&lt;/code&gt; tag to the test’s definition.  In this way, I was able
to add the bulk of the remaining tests without having tests that would obviously fail
getting in the way.&lt;/p&gt;
&lt;p&gt;While this may have seemed like busy work, it was meant to give me a realistic picture
of how close I was to finishing the parser, and it worked.  By executing
&lt;code&gt;pipenv run pytest&lt;/code&gt;, I executed every test and was able to look for entire modules
with skipped tests, getting a good indication of what features and testing was left.
From a wholistic point of view, it was good to see that out of the
875+ tests in the project so far, there were only just over 100 tests left to go before
the parser would be completed.  Being able to see how close I was to finishing the
parser was definitely a boost! Definitely worthwhile.&lt;/p&gt;
&lt;h2 id="adding-test-grouping"&gt;Adding Test Grouping&lt;a class="headerlink" href="#adding-test-grouping" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I knew from the start that this would be the monotonous part, so I tried to make sure
that I could stage the changes as I brought more scenario tests online.  The first
thing I did was to add a new marker for PyTest to the project by adding this line to
the &lt;code&gt;setup.cfg&lt;/code&gt; file for the project:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;markers=gfm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This change allowed me to use one of PyTest’s grouping features:
&lt;a href="https://docs.pytest.org/en/latest/mark.html"&gt;marking&lt;/a&gt;.  By changing
a scenario test’s definition from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@pytest.mark.gfm&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I included that test into the &lt;code&gt;gfm&lt;/code&gt; group.  While I can still execute that test by
itself by entering &lt;code&gt;pipenv run pytest -k 032&lt;/code&gt;, I could now execute all tests in
the &lt;code&gt;gfm&lt;/code&gt; group by entering &lt;code&gt;pipenv run pytest -m gfm&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This command was invaluable during development of the parser.  After adding HTML
translation support to a scenario test, I ensured that it was added to this group,
thereby staging the scenario test with it’s owning feature.
After completing the change to make the test pass, I then executed
all of the tests in the &lt;code&gt;gfm&lt;/code&gt; group to ensure that I didn’t break anything else in the
process.  While it caused me some issues from time to time, it was an extra watch over the
completed work, one that I appreciated.&lt;/p&gt;
&lt;h2 id="adding-translating-into-html"&gt;Adding Translating into HTML&lt;a class="headerlink" href="#adding-translating-into-html" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Translating any stream into something requires a loop to process through each element
in the stream, with some mix of emitting data and altering state.
I created the &lt;code&gt;TransformToGfm&lt;/code&gt; class to handle that translation, with the &lt;code&gt;transform&lt;/code&gt;
entry point to facilitate the transformation.  At this point in the implementation,
this class was very simple.  As each token was seen in the loop, it’s data was emitted
with only minor additional processing required.&lt;/p&gt;
&lt;p&gt;Adding this support into existing tests was pretty easy, just monotonous.  Using the
same test 32 that was used in the prior example, that test changed from:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@pytest.mark.gfm&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 032:  Simple headings&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;tokenizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""some markdown"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@pytest.mark.gfm&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_atx_headings_032&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 032:  Simple headings&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;tokenizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;transformer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TransformToGfm&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""some markdown"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="n"&gt;expected_gfm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""&amp;lt;p&amp;gt;some markdown&amp;lt;/p&amp;gt;"""&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;actual_gfm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;transformer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_strings_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_gfm&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_gfm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order of appearance, an instance of the &lt;code&gt;TransformToGfm&lt;/code&gt; class was added, the
&lt;code&gt;expected_gfm&lt;/code&gt; variable was set to the expected HTML, the &lt;code&gt;transform&lt;/code&gt; function was
called, and then the contents of the &lt;code&gt;expected_gfm&lt;/code&gt; variable were compared against
the output from the &lt;code&gt;transform&lt;/code&gt; function.  Except for the expected changes to the
&lt;code&gt;expected_gfm&lt;/code&gt; variable for each test, this transformation was repeated for each test
as support for the feature it enabled was added.&lt;/p&gt;
&lt;h2 id="translating-the-leaf-blocks"&gt;Translating the Leaf Blocks&lt;a class="headerlink" href="#translating-the-leaf-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Translating the leaf block tokens added in
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;this article&lt;/a&gt; and
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/"&gt;this article&lt;/a&gt;
proceeded quickly, encountering only a few unexpected issues.  These issues
fell into two categories: the handling of HTML blocks and code blocks, and the handling
of newlines in the HTML output.&lt;/p&gt;
&lt;p&gt;Most of the issues that were uncovered for leaf blocks dealt with the processing of
HTML blocks and code blocks. As mentioned in previous articles,
these two leaf blocks are special in that they maintain firm control over the formatting
of their content.  To accommodate these two leaf block types, the handling of the
&lt;code&gt;TextMarkdownToken&lt;/code&gt; was changed to accommodate the more strict output requirements of
those blocks, mostly ensuring that whitespace was preserved.  Other than that, the only
other changes needed for processing was to change most of the tokens to expose
certain fields, allowing the translator to access the token’s attributes cleanly.&lt;/p&gt;
&lt;p&gt;From a rendering viewpoint, I had guessed that any newlines in the HTML output were
going to be a problem from the start and I was right.
While the GFM is purposefully vague on when to add newlines in the
translation from Markdown to HTML, it was a vagueness that I couldn’t avoid.  As the
main push for this article’s work was to add proper comparisons of the GFM’s HTML
output for each example, I had a hard choice to make.  Either I make modifications to
each of the the 673 scenarios as I copied their HTML output into the scenario tests,
or I needed to ensure that the translation replicated the HTML &lt;em&gt;exactly&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;After a lot of thinking, I decided to go with the exact HTML output path, hopefully
removing any possible errors that may have occurred during the translation of the
HTML output for each scenario test.
When I thought about both options, I just felt that I would almost instantly regret
making any changes to the HTML output, as it would no longer be synchronized to the
GFM specification. In light of that, I figured it was better
to be consistent and do a bit more work on the project than to
start changing the scenarios.&lt;/p&gt;
&lt;p&gt;My current focus was on enabling the HTML comparisons, and I knew it was going to take
more effort and time to get them right. As such, I decided to add a fair number of “if
this look like” conditions to add or not add newlines, with plans to later refactor the
code to look for better groupings down the road.  I don’t like adding technical debt
just for the sake of expediency, but I just felt it was the right decision at the time.
I figured by adjusting the translator with little tweaks here and there would give
me a more complete picture on what needed done for a proper refactor later.  It wasn’t
a perfect decision, but it was one that I felt I could live with.&lt;/p&gt;
&lt;p&gt;When all of the leaf blocks were completed, I did notice a decent boost in my
confidence.  Except for some issues with getting newlines right, the translation of
leaf blocks was pretty straightforward.  Knowing that I had made good decisions
so far gave me that boost… something that I would need sooner rather than later.&lt;/p&gt;
&lt;h2 id="translating-the-container-blocks"&gt;Translating the Container Blocks&lt;a class="headerlink" href="#translating-the-container-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the translation of the leaf blocks went smoothly, I hit a number of issues dealing
with the container blocks added in
&lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/"&gt;this article&lt;/a&gt;.
While the block quotes themselves were not
really an issue, the list blocks that caused me a lot of trouble.&lt;/p&gt;
&lt;p&gt;In implementing the list block support in the translator, I was able to quickly get
to a point where the tags themselves were being emitted properly, but the whitespace
around the tags were off, especially with the newlines.  That was frustrating, but with
some helpful observations and experimentation, I was able to get that taken care of
relatively quickly.&lt;/p&gt;
&lt;p&gt;Following that triumph, I spent a number of aggravating
days trying to figure out why some list items contained &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags and why some list
items didn’t contain &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags.  I tried a number of approaches based on
the surrounding tags and tokens, but each of them failed.  It wasn’t until I was looking
at the specification again, when I took another look at the lists section and noticed
the following paragraph in the
&lt;a href="https://github.github.com/gfm/#lists"&gt;lists section&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A list is loose if any of its constituent list items are separated by blank lines, or if any of its constituent list items directly contain two block-level elements with a blank line between them. Otherwise a list is tight. (The difference in HTML output is that paragraphs in a loose list are wrapped in &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tags, while paragraphs in a tight list are not.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;That was the information I was searching for!  While the actual implementation is a bit
more complicated than just that, that is the essence of when I needed to add the
paragraph tags.&lt;/p&gt;
&lt;p&gt;The complications in implementation arose as the examples became more complex.  For
example, based on the above description, it is easy to see that this modified
&lt;a href="https://github.github.com/gfm/#example-294"&gt;example 294&lt;/a&gt;
is a strict list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and this unmodified
&lt;a href="https://github.github.com/gfm/#example-294"&gt;example 294&lt;/a&gt; is a loose list:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From the above lists section quote, since there is a blank line that separates
two of the list elements, it is a loose list.  Pretty easy and straight forward.
Implementing this aspect of looseness was decently easy, but did require some
non-trivial extra code. Basically, go back to the start of the current list, then go
through each list element in the list, looking to see if the Markdown element before it
is a blank line.  If so, mark the entire list as loose and apply that throughout the
list.&lt;/p&gt;
&lt;p&gt;However, when dealing with lists and sublists, it wasn’t so simple.  For example,
consider the Markdown from
&lt;a href="https://github.github.com/gfm/#example-299"&gt;example 299&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;

    &lt;span class="k"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Understanding the Markdown list blocks can be nested and following the guidance from
the above quote, you can deduce that the outer list is tight and the sublist is loose.
To make the leap from handling the previous 2 examples to this example would mean that
I needed to find a way to add scoping to the translation. Without scoping, when the
translator processed the above example, it saw 3 items in the same list, with the
second element making the entire list loose.  Scoping was required to allow the
translator to determine that the &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; items were in one list and the &lt;code&gt;b/c&lt;/code&gt; item
was in it’s own list, therefore determining the correct looseness for both lists.&lt;/p&gt;
&lt;p&gt;The code itself to handle scoping was fairly simple, but the tradeoff was that the
translator was slowly becoming more complicated, something that I was not happy
about.  It wasn’t in dangerous territory yet, but it was something to keep a watch out
for.  In addition, while the difference between a list being lose or strict is pretty
obvious in hindsight, at the time it was very annoying.  It took me the better part of
4 days to do something that was pretty obvious.  Even better than obvious was the fact
that it was plainly spelled out in the specification.  But as I had to do a number of
other times during this project, I picked myself up, dusted myself off, an continued on
with the inline translations.&lt;/p&gt;
&lt;h2 id="translating-inlines-backslash-escapes-character-references-and-code-spans"&gt;Translating Inlines - Backslash Escapes, Character References, and Code Spans&lt;a class="headerlink" href="#translating-inlines-backslash-escapes-character-references-and-code-spans" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During this translation process, first I hit a high, then I hit a low, and then I saw
the payoff of both with the translation of these inline elements into HTML.  These
elements consist of
the backslash escapes, character references, and code spans elements, and were added in
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/"&gt;this article&lt;/a&gt;. With the exception of
a couple of typos and the code spans, adding support for these features flew past
quickly. The backslash escapes and character references were already being processed
along with the
text tokens, which in turn were already tested with the leaf blocks.  The only new
code needed was for code spans, but those additions were quickly made by copying the
work done for code blocks and simplifying it a bit.  Other than a couple of typos that
I also needed to correct, the entire body of this work was completed in just under 3
hours.  And to be honest, that included me grabbing some well deserved dinner.&lt;/p&gt;
&lt;p&gt;Based on the days of trying to figure out list blocks and paragraph tags from the
last section, it was nice to get a real easy set of changes.  It wasn’t anything
challenging, just… nice.&lt;/p&gt;
&lt;h2 id="translating-inlines-raw-html-autolinks-and-line-breaks"&gt;Translating Inlines - Raw Html, Autolinks, and Line Breaks&lt;a class="headerlink" href="#translating-inlines-raw-html-autolinks-and-line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Rounding out the series of translations were the tests for raw html, autolinks, and
line breaks.  With features just added in the
&lt;a href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/"&gt;last article&lt;/a&gt;,
the tests for these features were added with only a couple of issues, similar in
severity to the issues from the leaf blocks.&lt;/p&gt;
&lt;p&gt;The largest group of issues encountered were issues with character encodings in
the autolinks feature.  Some of those issues were due to Unicode characters being
present in the Markdown, but needing to be properly encoded and escaped when present
in URIs.  Some of the issues were because the characters present in the URIs are
special characters, and had to be escaped to prevent them from being encoded twice.&lt;/p&gt;
&lt;p&gt;However, the most annoying issues were differences in the language libraries that
caused the translator to URI-encode a different set of characters than in the
GFM specification.  Specifically, it looks like the Commonmark parser uses the
Javascript libraries to encode URIs, while the PyMarkdown project uses the Python
libraries.  I wasn’t too concerned with these issues at the current time, so I made
sure to add some notes to address these concerns later, and kept on marching forward.&lt;/p&gt;
&lt;p&gt;The big catch with these changes was with the scenario test for the GFM specification’s
&lt;a href="https://github.github.com/gfm/#example-641"&gt;example 641&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While it might seem like a small difference when looking at a web page, the
PyMarkdown parser emitted a HTML block and a tag as content instead of
emitting a simple paragraph containing text, as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;&lt;span class="ni"&gt;&amp;amp;lt;&lt;/span&gt;a href='bar'title=title&lt;span class="ni"&gt;&amp;amp;gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Taking a look at the HTML output in the example, it is very clear that it should be a
paragraph containing text,
but somewhere in the copy-and-paste process I had accepted the wrongs tokens as
correct.  Digging into this issue, I quickly found out that a single omission in one of
the functions of the &lt;code&gt;HtmlHelper&lt;/code&gt; module was not checking for whitespace between the
tag’s attributes, therefore thinking that it was a valid tag when it wasn’t.  Within 5
minutes, I had a fix implemented, and the test corrected, and the last scenario test
that was currently implemented was now complete!&lt;/p&gt;
&lt;p&gt;As a strange aside, I may not have the only parser that has made this mistake. When
I was writing this article in VSCode, as usual, I had to check the example’s Markdown
a number of times.  The Markdown in the above section was generated with the following
fenced code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;&lt;span class="n"&gt;Markdown&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'bar'&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;title&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It’s a pretty simple example, and I typed it in as I usually do.  Create the fenced
block, add in the text from it’s source, verify it a couple of times, and then add in
the language specifier.  As soon as I typed in &lt;code&gt;Markdown&lt;/code&gt;, a strange thing happened.
The &lt;code&gt;a&lt;/code&gt; for the tag name turned into a deep blue, as expected.  But then both of the
attribute names, &lt;code&gt;href&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt;, turned light blue while the attribute values,
&lt;code&gt;`bar`&lt;/code&gt; and &lt;code&gt;title&lt;/code&gt; turned red.  I added a space before &lt;code&gt;title&lt;/code&gt; and then deleted
it, repeating
this experiment a couple of times, looking for color changes.  There were none.  For
whatever reasons, the coloring library that VSCode is using to color Markdown text
seems to believe that example 641 contains valid Markdown.  Weird!&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In writing automation tests as part of my professional job, I have a clear distinction
in my responsibility to my team.  I am not there to break their code or to find flaws
in it, I am there to help them find issues before they become problems.  If at all
possible, I stress automated tests over manual tests, and I also stress being able to
adopt consistent processes to shine a very focused light on anything that is different.&lt;/p&gt;
&lt;p&gt;The mere fact that I found a number of small issues with the parser, even at this
late stage of the project is fine with me.  I am helping my team (me) find these issues
before the code is released and impacts other people and their processes.  While it was
a large pain to go through, I felt that I closed part of the testing the loop by
consistently adding HTML output verification to each parser scenario test.  The mere
fact that the issues were found proves its own worth.  In addition, there was a small
efficiency and confidence boost because I don’t have to guess anymore as to whether or
not I chose the right tokens.  The HTML output from the examples proved that I made the
right choices.&lt;/p&gt;
&lt;p&gt;In the end, what it boils down to for me is that while adding the HTML output
verification to each test was painfully monotonous at times, it paid off.  While
only a handful of issues were uncovered, it did find at least one issue, which itself
boosted my confidence in the project.
Regardless of whether any issues were actually found, knowing that the tokens that
the parser was generating were being properly translated into the GFM specification’s
HTML output was worth it.  No more questioning whether or not the tokens would
translate into the proper HTML… I now had proof they did!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Whenever a protocol specification states something similar to “and here is a suggested
way of…”, it usually means that at least 2-3 groups of people implementing the
protocol specification had issues.  So it was with a bit of dread and a bit of
confidence that I started looking at dealing with inline emphasis, the topic of the
next article.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Autolinks, Raw HTML, and Line Breaks</title><link href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/" rel="alternate"></link><published>2020-03-09T00:00:00-07:00</published><updated>2020-03-09T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-09:/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed another refactoring session, I have confidence that the PyMarkdown
project code has been
returned back to what I feel is a healthy amount of technical debt.  After taking
a deep breath and a good look at the features left to implement, I realized that the
list is …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed another refactoring session, I have confidence that the PyMarkdown
project code has been
returned back to what I feel is a healthy amount of technical debt.  After taking
a deep breath and a good look at the features left to implement, I realized that the
list is now
pretty short: emphasis, links, autolinks, raw HTML, and line breaks.  Rechecking the
section on
&lt;a href="https://github.github.com/gfm/#phase-2-inline-structure"&gt;inline structure&lt;/a&gt;
in the GitHub Flavored Markdown (GFM) specification, it is hard to miss the fact that
the emphasis and link elements have their own “here is a suggested approach to
implementation” section while the implementation for parsing the
other elements are left up to the reader.  Deciding that the authors of the GFM
were trying to tell me something, I decided to focus on autolinks, raw HTML, and line
breaks first, leaving the emphasis and links for the last chunk of features.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/6ea7929d95468e28170671dc19214bd09507f04c"&gt;22 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/dffd948cf8e4066121dbb11ae68c385370a20877"&gt;27 February 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="my-take-on-html-in-markdown"&gt;My Take On HTML in Markdown&lt;a class="headerlink" href="#my-take-on-html-in-markdown" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Back in the article
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/"&gt;Markdown Linter - Adding HTML Blocks&lt;/a&gt;,
I provided
&lt;a href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/#my-recommendation"&gt;a recommendation&lt;/a&gt;
as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;When it comes to HTML blocks, I implemented them as part of the parser because they are part of the specification. But because of the complexity in understanding HTML blocks, I whole heartedly recommend avoiding using HTML blocks if at all possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The big problem I have with HTML blocks is that there are 7 types of HTML blocks, and
each one has a different ending condition.  As an author that heavily uses Markdown,
I want any documents that I create to be simple and easy to read.  In my opinion,
without a lot of memorization, HTML blocks are not simple at all.  &lt;/p&gt;
&lt;p&gt;Raw HTML elements are on the complete other end of the spectrum.  If I had my way
with the GFM specification, I would demote and remove HTML blocks entirely and replace
them with raw HTML.  Raw HTML is exactly as it sounds: what you type is what you get.
The good news is that if you follow a couple of easy to memorize rules, you can do this:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NEVER start a line with a HTML tag&lt;/li&gt;
&lt;li&gt;Markdown is an authoring language, and should only use HTML sparingly&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In support the first rule, my reading of the start conditions of each of the
&lt;a href="https://github.github.com/gfm/#html-blocks"&gt;HTML block types&lt;/a&gt;
in the GFM concludes with the observation that all start conditions begin with the text
“line begins…”.  Thus, I created the first rule to ensure that I never inadvertently
trigger a HTML block.  Any non-whitespace text and then any HTML is fine, just not
by itself at the start of the line.&lt;/p&gt;
&lt;p&gt;My second rule may seem like my own opinion, but I believe it is a solid rule.  While
it is useful to read the GFM section on
&lt;a href="https://github.github.com/gfm/#what-is-markdown-"&gt;What is Markdown?&lt;/a&gt;,
that section boils down to this one quote from that section by John Gruber:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The overriding design goal for Markdown’s formatting syntax is to make it as readable as possible. The idea is that a Markdown-formatted document should be publishable as-is, as plain text, without looking like it’s been marked up with tags or formatting instructions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;There is little question that having the ability to add a HTML tag where needed is a
good feature of Markdown.  However, I would contend that any HTML tags that are added
are contrary to Gruber’s stated goal for a document to not be marked up with tags. As
such, unless Gruber’s readability goal is dismissed, anything more than sparing use of
HTML in a Markdown document is harmful.&lt;/p&gt;
&lt;p&gt;Don’t get me wrong, but there are good use cases for HTML, but they are rare.  In the
5-6 years that I have been authoring documents in Markdown, there are only two times
I have ever used HTML tags in Markdown documents.  The first time is in the writing of
these articles on the Markdown parser for the PyMarkdown project and the other time was
for a project that used the &lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;/ul&amp;gt;&lt;/code&gt; tags to satisfy a legal documentation
requirement for text underlining.  From talking with other developers using Markdown
parsers that underling text is a popular request along with a blanket request to
disable all HTML tag support in Markdown, mostly for security reasons.&lt;/p&gt;
&lt;p&gt;So, for what it is worth, that is my take on HTML in Markdown, and my reasons for that
opinion.  Your mileage may vary.&lt;/p&gt;
&lt;h2 id="raw-html"&gt;Raw Html&lt;a class="headerlink" href="#raw-html" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unlike the rules that an author needs to memorize to properly use HTML blocks, using raw
HTML in Markdown is very simple: it’s either a legal HTML tag or it gets interpreted
as normal text.  No “if it’s a blah tag, then…” rules.  Just valid or invalid.  No
ending conditions as raw HTML is inline processing of text.  Simple. Easy. Clean.&lt;/p&gt;
&lt;p&gt;The reason that I can be comfortable in saying that raw HTML is simple is the following
block of Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;Start&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="k"&gt;End&lt;/span&gt; &lt;span class="nv"&gt;Tags&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;link&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nv"&gt;link&lt;/span&gt; &lt;span class="nv"&gt;text&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nv"&gt;a&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Self&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nv"&gt;Closing&lt;/span&gt; &lt;span class="nv"&gt;Start&lt;/span&gt; &lt;span class="nv"&gt;Tag&lt;/span&gt;  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;br&lt;/span&gt; &lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Alternate&lt;/span&gt; &lt;span class="nv"&gt;Parameter&lt;/span&gt; &lt;span class="nv"&gt;Enclosing&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;b2&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;foo&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Simple&lt;/span&gt; &lt;span class="nv"&gt;Alternate&lt;/span&gt; &lt;span class="nv"&gt;Parameter&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;c3&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;bar&lt;/span&gt; &lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;  \
&lt;span class="nv"&gt;Gratuitous&lt;/span&gt; &lt;span class="nv"&gt;Parameter&lt;/span&gt; &lt;span class="nv"&gt;Example&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nv"&gt;d4&lt;/span&gt; &lt;span class="nv"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="s"&gt;bar&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="nv"&gt;bam&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;'&lt;/span&gt;&lt;span class="s"&gt;baz &amp;lt;em&amp;gt;"&amp;lt;/em&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;'&lt;/span&gt; &lt;span class="nv"&gt;_boolean&lt;/span&gt; &lt;span class="nv"&gt;zoop&lt;/span&gt;:&lt;span class="mi"&gt;33&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;zoop&lt;/span&gt;:&lt;span class="mi"&gt;33&lt;/span&gt; &lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the grammar is broken down in the
&lt;a href="https://github.github.com/gfm/#raw-html"&gt;Raw HTML&lt;/a&gt; section of the GFM specification,
it follows the
&lt;a href="https://www.w3.org/TR/html52/syntax.html#writing-html-documents-elements"&gt;HTML 5&lt;/a&gt;
specification for how to construct the tag and which tag formats are valid.  From
a document author point of view, this is simple.  When adding HTML to a Markdown
document, the author either knows how to author a web page in HTML or has a person
or web page that tells the author what HTML to insert into the document.  In either
case, assuming that those tags are valid, those tags are emitted exactly as added,
with no extra baggage added during the translation.&lt;/p&gt;
&lt;p&gt;In adding these HTML samples to the above Markdown example, I am also following my own
rules: never start a line with a tag and use it sparingly.  None of the lines start
with a tag, ensuring that none of the text is parsed as a HTML block.  And while
I went a bit overboard with the HTML specifically as it is an example, I can honestly
say it is one of the less-than-5 times I have used HTML in Markdown.  I think that
qualifies as sparingly.&lt;/p&gt;
&lt;p&gt;The raw HTML inline processing was very easy to add, as the rules are very simple:
it’s either a valid HTML tag, or not.  Not much to add.&lt;/p&gt;
&lt;h2 id="autolinks"&gt;Autolinks&lt;a class="headerlink" href="#autolinks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Until I started reading the specification, I had no idea that Markdown was capable of
a lot of things.  In this case, I wasn’t aware that it can make a decent attempt at
creating links with very little effort.  As far as using them in my articles and
documents, I am not sure about them yet, but at the very least they are an interesting
concept for Markdown to include.&lt;/p&gt;
&lt;p&gt;The concept is simple.  An URI contained within the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; characters is
interpreted as a link to that URI, with both the link and the link text being set to
that value.  There is also a variation of autolinks that uses any email address that
matches the email address
&lt;a href="https://html.spec.whatwg.org/multipage/forms.html#e-mail-state-(type=email)"&gt;regular expression in the HTML5 specification&lt;/a&gt;.  For email address autolinks, the link is set
to a &lt;code&gt;mailto&lt;/code&gt; scheme for the link and the email address for the link text.&lt;/p&gt;
&lt;p&gt;Real simple examples of these autolinks are contained within the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;website&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;email&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;honcho&lt;/span&gt;&lt;span class="nv"&gt;@example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;My website: &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"http://example.com"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;http://example.com&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;My email: &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="na"&gt;href&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"mailto:head.honcho@example.com"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;head.honcho@example.com&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To make sure they are not interpreted as HTML blocks, they are prefaced with text,
according to the rules I established in the last section.  While a properly
created autolink should not be interpreted as either of the HTML elements, I prefer to
keep things simple.  “NEVER start a line with a HTML tag unless it is a validly formed
autolink” just seemed to much.  As mentioned before, your mileage may vary.&lt;/p&gt;
&lt;p&gt;The actual HTML output is simple, as denoted in the second paragraph of this section.
In looking at autolinks a couple of times for this article, my feeling about autolinks
as a document author is that there is not enough control of the output.  Unless
I am missing something, the following Markdown is equivalent to the above HTML, and
it gives me more control of the document:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;website&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;http://example.com&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="n"&gt;My&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nl"&gt;email&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;head.honcho@example.com&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;mailto&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;head&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;honcho&lt;/span&gt;&lt;span class="nv"&gt;@example&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the end, while autolinks were as trivial to add as raw HTML, I think I’ll stick
with my explicit links.&lt;/p&gt;
&lt;h2 id="line-breaks"&gt;Line Breaks&lt;a class="headerlink" href="#line-breaks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Wrapping things up for this group of features are the line breaks: hard breaks and soft
breaks. At 14 examples for
hard line breaks and 2 examples for soft line breaks, only the indented code
blocks (11), the tabs (11), and the paragraphs (8) are in the same ball park for the
low number of examples needed to adequately demonstrate that given structural element
of Markdown.  In addition, if you really look at the 14 examples for hard line breaks,
there is a good argument to be made that there is large amount of replication between
the two character sequences, reducing the “actual” number of examples down
into the same 8-11 examples range.&lt;/p&gt;
&lt;p&gt;As indicated by the number of examples, line breaks in Markdown are really simple to
use, inheriting it’s line break rules from HTML.  In both languages,
if the author wants to specifically break a line after some text, they must use an
element that forces a line break before it’s content, use an element that preserves line
breaks within it’s content, or specify a hard line break itself.&lt;/p&gt;
&lt;p&gt;A good example of the first case are the grouping of Markdown lines into a paragraph by
separating them with a blank line.  This is best shown in the following Markdown from
&lt;a href="https://github.github.com/gfm/#example-190"&gt;example 190&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;aaa&lt;/span&gt;
&lt;span class="n"&gt;bbb&lt;/span&gt;

&lt;span class="n"&gt;ccc&lt;/span&gt;
&lt;span class="n"&gt;ddd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;aaa
bbb&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;ccc
ddd&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is displayed as the following:&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;p&gt;aaa
bbb&lt;/p&gt;
&lt;p&gt;ccc
ddd&lt;/p&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;In this example, the (soft) line break that occurs in the Markdown between &lt;code&gt;aaa&lt;/code&gt; and
&lt;code&gt;bbb&lt;/code&gt;, and then again between the &lt;code&gt;ccc&lt;/code&gt; and &lt;code&gt;ddd&lt;/code&gt;, is kept as it is translated into
HTML.  However, when the HTML is rendered, that line break is not displayed.  When
displayed, the first pair of characters are displayed, followed by a line break, and
then the second set of characters.  As a general default rule, Markdown blocks
force a hard line break before displaying their contents, to ensure that the content is
understood to be different.&lt;/p&gt;
&lt;p&gt;For the second case, a good example of it is a slightly modified version of the
Markdown from &lt;a href="https://github.github.com/gfm/#example-110"&gt;example 110&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;bam&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;baz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which generates the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;bar
bam
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;baz&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is displayed as the following:&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;p&gt;foo&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;bar
bam&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;baz&lt;/p&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;The first thing to notice is that, as described in the last example, when a new
Markdown block is started, the default rule for displaying HTML forces a hard line
break to be rendered, keeping it’s content distinct from the previous content.  As such,
in this example both the &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; tag and the &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; tag are displayed with a line break
before them.  While this behavior can sometimes be overridden with styles and style
sheets, it tends to make things more confusing and is mostly avoided by HTML authors.  &lt;/p&gt;
&lt;p&gt;The second thing to notice is that the line breaks within the code block are
preserved as-is.  Both code blocks and HTML blocks maintain a very tight control on
how their data is translated and displayed, being the only two block elements that
preserves any line breaks within it’s content.  In terms of other elements, it should
be no surprise that code spans and raw HTML are the only two inline elements that also
preserve line breaks within their content.&lt;/p&gt;
&lt;p&gt;That leaves the final use case, where a Markdown author wants to force a hard line
break outside of any of the previously mentioned constructs.  But, how does an author
do that?&lt;/p&gt;
&lt;p&gt;The often used and not-so-visible option is to end a
line with 2 or more spaces that is also not at the end of a block.  Merging examples
&lt;a href="https://github.github.com/gfm/#example-657"&gt;657&lt;/a&gt; and
&lt;a href="https://github.github.com/gfm/#example-666"&gt;666&lt;/a&gt; together produces the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="k"&gt;space&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;generating the following HTML:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;foo&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;br&lt;/span&gt; &lt;span class="p"&gt;/&amp;gt;&lt;/span&gt;
bar
foo&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and is displayed as the following:&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;p&gt;foo&lt;br/&gt;
bar
foo&lt;/p&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;Note that for the sake of clarity with this example, the string &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; is used in
place of the actual
space character itself.  The two spaces at the end of the first line cause the HTML
hard break tag &lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; to be inserted into the data, generating a line break not only
in the generated HTML, but also in the displayed HTML.  In contrast, since the two
spaces at the end of the third line closes off the paragraph block, they are simply
stripped away and not replaced with a hard break.  This was a smart move as any Markdown
following that paragraph will be in a new block, the starting of the new block will,
by default, force a hard break in the display of that block, as noted above.&lt;/p&gt;
&lt;p&gt;In contrast, the second way to force a hard line break is to end the line with the
&lt;code&gt;\&lt;/code&gt; character, as shown in the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;
     &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While there are changes in the Markdown from the previous example, the generated HTML
remains the same.  After my initial confusion between Python’s &lt;code&gt;\&lt;/code&gt; line continuation
character and the Markdown’s &lt;code&gt;\&lt;/code&gt; hard line break character (as
&lt;a href="https://jackdewinter.github.io/2020/03/02/markdown-linter-taking-time-to-refactor-post-easy-inlines/#issue-2-python-markdown-and-line-continuation-characters"&gt;documented here&lt;/a&gt; ),
the explicit hard line break character grew on me.  &lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If I am being honest with myself, I was not sure at the beginning of the project if
I would ever get to this point.  With only 2 inline elements left to process, not
including the link definitions deferred from before, the parser is getting pretty close
to being able to handle a full and rich Markdown document.  As the GRM specification
contains over 673 scenarios, there were times that I thought I would just give up
or use a “mostly” complete parser… something that was just barely good enough.  But
getting to this point, close to having a solid parser completed feels great!&lt;/p&gt;
&lt;p&gt;Sure, there have been cases where it took me a day or two to figure out how to do
something properly, such as list blocks and block quotes.  Those were tough.  And
as I am writing this article at a 2-3 week delay from when I made the actual changes
to the project, I know that there are some more bumps in the row yet to come.
(No Spoilers!)  But
the important thing is that while those things are hard, I face them with the mentality
that I talk about in my article on
&lt;a href="https://jackdewinter.github.io/2019/08/18/embracing-something-hard/"&gt;Embracing Something Hard&lt;/a&gt;.
Maybe
it’s just how I am, but for me part of the challenge is to embrace something hard
and work my way though it.&lt;/p&gt;
&lt;p&gt;It was when I was thinking about some of hard stuff that I had tackled previously
and how easy this block of features was that I started wondering.  Looking back
in the project at anything written before
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/dffd948cf8e4066121dbb11ae68c385370a20877"&gt;this commit on 27 February 2020&lt;/a&gt;,
it is hard to find any test that compares the output to HTML, though all of scenario
test output from the GFM specification is written as HTML.  What’s with that?&lt;/p&gt;
&lt;p&gt;Going back to my article on
&lt;a href="linter-1.md#what-are-the-requirements"&gt;Collecting Requirements&lt;/a&gt;,
I determined that to properly write a Markdown linter, I needed to be able to take
the output from a parser as a set of tokens, not output as HTML.  The entire reason
that I have taken steps to write this Markdown parser is that there are no current
parsers that do not output interpreted Markdown as HTML.  Furthermore, the previous
section on
&lt;a href="https://jackdewinter.github.io/2020/03/09/markdown-linter-autolinks-raw-html-and-line-breaks/#autolinks"&gt;autolinks&lt;/a&gt;
is proof of that need.  Producing a simple link
to a web page, I can generated it using an autolink, a raw HTML tag, and a HTML block.
Tokenizing the output before that translation to HTML is the only way to ensure that I
am linting the Markdown properly.&lt;/p&gt;
&lt;p&gt;To get me this far, testing against the tokenized output of the parser was the right
thing to do.  The linter is going to observe and consume the tokens from the parser,
so they are the right thing to test.  But the questions of whether or not I was
generating the correct tokens started to bounce around my mind…&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last section, I had some concerns about whether or not the
tokenization of the Markdown was correct, so I decided to go all out for the next
section and add the remaining scenario tests from the GFM specification.  To close
the loop on the testing, I also went through all of the existing tests and added
a new class that transforms the PyMarkdown tokens into HTML, comparing that output
directly against the GFM specification.  Stay tuned!&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Taking Time to Refactor -- Post-Easy Inlines</title><link href="https://jackdewinter.github.io/2020/03/02/markdown-linter-taking-time-to-refactor-post-easy-inlines/" rel="alternate"></link><published>2020-03-02T00:00:00-08:00</published><updated>2020-03-02T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-03-02:/2020/03/02/markdown-linter-taking-time-to-refactor-post-easy-inlines/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I was working on implementing the
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#code-spans"&gt;inline code spans&lt;/a&gt;,
as detailed in the last article,
I performed
a thorough scan of the scenario tests and their source data, noting down any issues I
found.  I knew that I had missed the mark on how to internally represent Atx …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I was working on implementing the
&lt;a href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/#code-spans"&gt;inline code spans&lt;/a&gt;,
as detailed in the last article,
I performed
a thorough scan of the scenario tests and their source data, noting down any issues I
found.  I knew that I had missed the mark on how to internally represent Atx Headers,
and I was curious about how many other things I had missed.  Having found a
decent handful of issues to fix,  I decided to spend some time to address those issues
before adding more of the inline processing.  In my mind, it was
better to take a week and try and keep the issue count low than to continue forward,
possibly compounding the cost of fixing those issues.  As I am in a somewhat ideal
scenario, with nobody pressuring me for features or issue fixes, I figured it was best
if I took advantage of that to the best of my abilities and “do it right”.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/5102bfd8a3b2616eb6c3147f9416e3d7b308e523"&gt;14 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/62127eb46d5b03a781ba85fbcf3a397221716eb2"&gt;20 February 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="why-refactor-now"&gt;Why Refactor Now?&lt;a class="headerlink" href="#why-refactor-now" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As the owner and sole developer on the project, my decision to stop and refactor was
any easy one to make.  It also didn’t escape my attention that making a decision like
that isn’t always that simple for larger projects.  If this was a work project
or a team project, the group working on the project would have to meet to figure things
out. The team itself usually plays a critical role in assessing the cost and benefit of
each task, but
in the end it is a balancing act for managers and directors to figure out which tasks
are the best ones to focus on at any given time. As it’s only me on the PyMarkdown
project, I get to conveniently shortcut those conversations in favor of simple
decisions based on my own experience.&lt;/p&gt;
&lt;p&gt;From my years of experience, I find that there are usually two driving forces that make
me support a decision to refactor a project.  The first driving force is the cost of
any applicable technical
debt on product code.  As I consider tests integral to a project’s quality, my
definition of the term “product code” includes all source code and resources required
to execute the project normally and to perform testing used to certify that same
project as shippable.  With almost 700 scenario tests for
PyMarkdown’s parser, even a small change can generate large ripples through the
code base, especially the scenario tests.  As the scenarios for a feature are only added
when that feature itself is added, each feature added therefore adds a significant
amount of product code for any change to ripple through.  It also follows that each
extra test impacted by an issue means an increased cost to fix that issue before
proceeding.  Therefore, if the goal is to keep overall costs down, refactoring more
frequently during development seems logical.&lt;/p&gt;
&lt;p&gt;The second driving force is less quantifiable, but equally important to any type of
project.  That force is the flow of the team working on the project.  Based on past
projects, I know that I work more efficiently if
I focus on a group of similar things for a while, then shift to another group when done.
The larger the difference is in the skill sets between the two groups of work, the more
relaxed I feel about the work.  This sense of relaxation allows me to get into a better
flow.  As this project is being
written by me in the evenings and on the weekends, keeping a good flow for the project
keeps me focused and energized about the project.  As I am the sole developer on the
project at the time, keeping myself motivated in a necessity!&lt;/p&gt;
&lt;p&gt;While one force is more empirical and the other is more feelings based, both of these
forces worked together to convince me that it was yet again time to refactor the
PyMarkdown project.&lt;/p&gt;
&lt;h2 id="issue-1-setext-headers-paragraphs-and-block-quotes"&gt;Issue 1:  SetExt Headers, Paragraphs, and Block Quotes&lt;a class="headerlink" href="#issue-1-setext-headers-paragraphs-and-block-quotes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I needed one of the smaller issues to get me warmed up, so after looking over the list
of possible issues to work on, I decided on
this one.  During the review of active scenario tests, I noticed that the text &lt;code&gt;===&lt;/code&gt;
was in the paragraph tags for the specification’s example, but the tokens that the
parser were omitting had them outside of the paragraph.  It seemed simple enough,
but looks were deceiving.&lt;/p&gt;
&lt;p&gt;It took me a bit of digging to find two possible reasons for the string &lt;code&gt;===&lt;/code&gt; to be kept
inside of the paragraph: laziness and non-interrupts.  Working backwards, the
concept of laziness with block quotes and list items is that you can omit any of
the leading characters if the next non-whitespace character after the omitted
characters is text that continues the paragraph.  In essence:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;quote&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is equivalent to&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt; &lt;span class="n"&gt;quote&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That got me halfway there, but there was still the question of how the &lt;code&gt;===&lt;/code&gt; would be
kept as part of the paragraph and not as an SetExt header indicator.  I read the
section on SetExt a couple of times before the following lines clicked:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;However, it cannot interrupt a paragraph, so when a setext heading comes after a paragraph, a blank line is needed between them.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Bingo!  I wish it didn’t take multiple reads through that part of the specification,
but specifications are sometimes like that.  Based on those discoveries, I temporary
rewrote the scenario for scenario 63 to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The goal of this was to remove the laziness out of the equation while working on the
interrupt issue.  When I reran scenario test 63, I correctly got a single paragraph
with 3 lines in it.  So whatever the issue was, it was not just simple parsing of
paragraphs.  Taking a step forward, I added the block quotes back into the picture,
changing that scenario text to:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It was at this point that the scenario broke, apparently thinking that the third line
was a
SetExt header, and should close off the paragraph.  Issue reproduced!  To be sure, I
applied the laziness concept to the block quote, reverting the scenario back to
its original text of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;===&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and validated that the behavior was the same.&lt;/p&gt;
&lt;p&gt;Armed with a good reproduction case for the issue, good debug output, and a general
area in the source code for the cause of the issue, the issue was identified and
fixed in quick order.  This issue was very specific, so only the one scenario test
was impacted, which was a good thing.  The problem was that during the development
of block quotes, something made me think that anything looking like a
SetExt header should close off a paragraph, hence I added code to do just that. I
checked the code a couple of times, and that was the only scenario test referencing
that code, so I just deleted it.&lt;/p&gt;
&lt;p&gt;While the research on the issue was
a bit more effort than I originally thought, fixing this issue was a great warm up
to the next couple of issues.  One issue, one scenario test impacted, and I was
refactoring.&lt;/p&gt;
&lt;h2 id="issue-2-python-markdown-and-line-continuation-characters"&gt;Issue 2: Python, Markdown, and Line Continuation Characters&lt;a class="headerlink" href="#issue-2-python-markdown-and-line-continuation-characters" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The next issue for me to work on was a subtle copy-and-paste error, one that flew
under my radar until I took a solid look at it.  This issue didn’t show any indications
of failure until I started my scan of the scenario tests.  In essence, the only
reason I found this one was that I went looking for any error, not something specific.&lt;/p&gt;
&lt;p&gt;In Markdown, the &lt;code&gt;\&lt;/code&gt; character at the end of the line is used to denote a hard line
break, not yet to be implemented in the PyMarkdown project.  In Python, the &lt;code&gt;\&lt;/code&gt;
character at the end of the line is used as a line continuation character, telling the
Python interpreter to treat the text before the character and the text after the
character as a single line.  Hopefully any readers see where I am going with this.&lt;/p&gt;
&lt;p&gt;When I added the scenario test for
&lt;a href="https://github.github.com/gfm/#example-60"&gt;scenario 60&lt;/a&gt;,
I did a copy-and-paste on the Markdown input to the new scenario test, a process I
have done for 99% of the scenario tests in the project.  To accomplish this, I pasted
the following Markdown text between the &lt;code&gt;"""&lt;/code&gt; characters denoting the Markdown to use
as input:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;
&lt;span class="c1"&gt;----&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resulting in the Python code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""Foo&lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="s2"&gt;----"""&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After pasting each scenario’s Markdown into the scenario test, I try to ensure that
I replace every instance of the &lt;code&gt;\&lt;/code&gt; character with the &lt;code&gt;\\&lt;/code&gt; characters to properly
represent the backslash character in a Python string.  As I am
only human, there are times that I forget to do this.  Luckily for me, if a &lt;code&gt;\&lt;/code&gt;
character is not paired up with a valid character to escape, the Python interpreter
will generate a warning similar to the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;======================================================== warnings summary ========================================================
test\test_markdown_setext_headings.py:346
  C:\old\enlistments\pymarkdown\test\test_markdown_setext_headings.py:346: DeprecationWarning: invalid escape sequence \&amp;gt;
    expected_gfm = """&amp;lt;h2\&amp;gt;Foo\\&amp;lt;/h2&amp;gt;"""

-- Docs: https://docs.pytest.org/en/latest/warnings.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As the backslash character in Markdown is used with punctuation characters and the
backslash character in Python is used with alphabetic characters, this is usually a
very solid detection scheme for finding copy-and-paste misses.  In this case, that
check failed.&lt;/p&gt;
&lt;p&gt;The good news here is two-fold: an easy fix and a very localized fix.  This fix was
easy as I just had to apply the missed substitution.  It was localized mainly because
I had not yet implemented hard line breaks.  And yes, it meant that when I did implement
hard line breaks, I triple checked my line endings to avoid this issue showing up again.&lt;/p&gt;
&lt;p&gt;Momentum was increasing, so it was time to step things up!&lt;/p&gt;
&lt;h2 id="issue-3-code-blocks-indenting-and-blank-lines"&gt;Issue 3: Code Blocks, Indenting, and Blank Lines&lt;a class="headerlink" href="#issue-3-code-blocks-indenting-and-blank-lines" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having resolved a couple of warm-up issues, I felt it was time to tackle some larger
issues.  Each issue in
this group either deals with vertical space issues or leading space issues within a code
block.  The vertical space issue was that blank lines were not being folded into the
text blocks properly, causing foreseeable issues with  parsing complete blocks of text
in the near future.  Given some Markdown text, such as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;
&lt;span class="n"&gt;abc&lt;/span&gt;

&lt;span class="n"&gt;def&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I expected that the output tokens would include a fenced code block with a single text
block inside of it with three lines present.  Instead, there were three tokens present,
the first and last were text tokens with strings and the token in the middle was a blank
line token.  While the token representation was technically correct, parsing it would
be awkward.  For the specific case of blank lines within a code block, it made sense to
merge the blank line tokens into the surrounding text tokens.&lt;/p&gt;
&lt;p&gt;The leading space issue was a bit more subtle but equally simple.  To properly parse
text blocks within a code block, an appropriate amount of whitespace may need to be
removed from each line as it is combined together.  As always, it is the details that
matter, and it is easy to gloss over them.  In the opening part of the indented code
block section of the specification, the following line is present:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The contents of the code block are the literal contents of the lines, including trailing line endings, minus four spaces of indentation.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The similar line for fenced code blocks reads:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the leading code fence is indented N spaces, then up to N spaces of indentation are removed from each line of the content (if present).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, this means that the following indented code block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="n"&gt;fred&lt;/span&gt;
     &lt;span class="n"&gt;frank&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;should produce a code block with the text &lt;code&gt;fred&lt;/code&gt; on the first line and the text
&lt;code&gt;&amp;lt;space&amp;gt;frank&lt;/code&gt;&lt;sup id="fnref:Space"&gt;&lt;a class="footnote-ref" href="#fn:Space"&gt;1&lt;/a&gt;&lt;/sup&gt; on the second line, having had the first 4 spaces removed.  The fenced
code blocks are
a bit more nuanced, in that:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="n"&gt;fred&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is parsed as &lt;code&gt;&amp;lt;space&amp;gt;&amp;lt;space&amp;gt;fred&lt;/code&gt;&lt;sup id="fnref2:Space"&gt;&lt;a class="footnote-ref" href="#fn:Space"&gt;1&lt;/a&gt;&lt;/sup&gt; and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="o"&gt;```&lt;/span&gt;
  &lt;span class="n"&gt;fred&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is parsed as &lt;code&gt;fred&lt;/code&gt;, based on the extra indenting of the fenced code block start.
While the line containing the text &lt;code&gt;fred&lt;/code&gt; is the same in both cases, the number of
leading spaces before the fenced code block are different, resulting in the different
outputs.&lt;/p&gt;
&lt;p&gt;Prior to fixing this issue, text lines were combined in a simple manner and no
whitespace was removed from the start of any lines within code blocks.  To properly
address this issue, not only did these two rules need to be followed, but the existing
code to properly remove leading spaces for each line within a normal paragraph needed
to be preserved.  It took a bit to get it right, but with a good number of scenario
tests to keep things honest, it was easy to get it right quickly.&lt;/p&gt;
&lt;p&gt;My original estimates for the impact of this issue was 15-20 tests, and it thankfully
remained within that range.  While the initial number of scenarios covered by these
issues was 15, I expected other scenarios to use code blocks to show how their feature
worked with code blocks, adding another 3-7 scenario tests in the process.  Looking
back, I think I got off pretty nicely with the scope of these changes.&lt;/p&gt;
&lt;h2 id="issue-4-paragraphs-and-indenting"&gt;Issue 4: Paragraphs and Indenting&lt;a class="headerlink" href="#issue-4-paragraphs-and-indenting" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Feeling energized from fixing the issues documented in the previous sections, I decided
to keep with the theme and attack the issue with leading spaces in normal paragraphs.
Similar in essence to the prior issue, the rule for normal paragraphs is that all
leading whitespace is
removed as the text for the paragraph is pasted together.  While it is hard to point
to an exact quote from the specification for this rule&lt;sup id="fnref:Missing"&gt;&lt;a class="footnote-ref" href="#fn:Missing"&gt;2&lt;/a&gt;&lt;/sup&gt;,
&lt;a href="https://github.github.com/gfm/#example-192"&gt;example 192&lt;/a&gt; clearly shows this as the
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="n"&gt;aaa&lt;/span&gt;
 &lt;span class="n"&gt;bbb&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is translated into the HTML text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;aaa
bbb&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The fix for this was similar to the change made for the code blocks issue, but instead
of specifying a fixed number of whitespace to remove, the &lt;code&gt;combine&lt;/code&gt; function was
changed to accept a value that indicates the removal of all whitespace.  The original 9
cases were quickly tested with the fix, and things looked solid.&lt;/p&gt;
&lt;p&gt;Originally, it looked like the changes would be confined to the original 9 cases, but
I suspected that the number would at least be double that, as this fix would affect any
scenario involving a paragraph with multiple lines. While an number of the cases were
simple cases, when all was said and done, there were 59 changes to scenario
tests in the commit for this issue.  Even so, those changes were quickly made and the
scenario tests were re-verified.&lt;/p&gt;
&lt;p&gt;While this took a lot of work to get right, it felt good to get this one resolved.  It
was hard for me to quantify this to myself, but the parsing of the paragraphs always
looked like they had too many spaces.  It was nice to finally figure out why!&lt;/p&gt;
&lt;h2 id="issue-5-trailing-spaces-in-scenarios"&gt;Issue 5: Trailing Spaces in Scenarios&lt;a class="headerlink" href="#issue-5-trailing-spaces-in-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the early development phase of the project, I wanted to get going with the
scenarios as quickly
as possible, so I copied each scenario’s Markdown text from the GFM specification
exactly as-is.  This wasn’t a
problem, except that in a small number of cases, there were lines in the scenarios that
ended in one or more whitespaces.  These trailing whitespaces raised the
&lt;code&gt;trailing-whitespace&lt;/code&gt; warning when I ran the PyLint program over the project’s
code base, as I do with each set of changes. Determined to deal with the issue later,
I added a number of comments like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# pylint: disable=trailing-whitespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to disable the Pylint warnings that occurred, knowing I would have to fix
them later.  At this point in the project, it seemed like a good time to deal with this.&lt;/p&gt;
&lt;p&gt;As this issue was largely out of sight, everything was fine.   That is, everything was
fine until I hit a
number of problems in a row that did involve these scenarios.  Instead of immediately
noticing the trailing whitespace and the comment, I started debugging each issue
without noticing either the comment or the whitespace, and was dumfounded by why the
parsing was not as was suggested
by the Markdown text that was clearly visible.
When I took a step back to really read the scenario tests, I then noticed
the comment at the top of each of the problem test functions, and then it clicked.  But
it took a lot longer than it should have.  Instead of “just dealing with it”, I decided
that refactoring was a better solution.&lt;/p&gt;
&lt;p&gt;The fix was an easy one too, something I should have thought of earlier.  The ASCII BELL
character is represented by &lt;code&gt;\a&lt;/code&gt; in Python strings, and to the best of my knowledge is
seldom used in most Python programs or Markdown text.  As it has a very low probability
of being used in any scenarios, I replaced the
terminating whitespace characters with &lt;code&gt;\a&lt;/code&gt; characters, then added &lt;code&gt;.replace("\a", " ")&lt;/code&gt;
at the end of the sample string.  It was then a simple matter of going through the
other 6 scenarios with trailing whitespaces and repeating this fix.&lt;/p&gt;
&lt;p&gt;While issues like this may seem small, having to disable a PyLint warning didn’t feel
right, even if it helped me maintain momentum at the time.  It just felt really good
to solve this issue properly.&lt;/p&gt;
&lt;h2 id="issue-6-getting-atx-headers-right"&gt;Issue 6: Getting Atx Headers Right&lt;a class="headerlink" href="#issue-6-getting-atx-headers-right" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the last article, I started looking for issues after wondering if a code span
could work within an Atx Header, realizing that the specification allowed it but
my current implementation did not allow it. As stated in the preamble for
&lt;a href="https://github.github.com/gfm/#example-36"&gt;scenario 36&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The raw contents of the heading are stripped of leading and trailing spaces before being parsed as inline content.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, my decision was based on my usage patterns, not the specification.
In my experience, I have only ever done Atx Headers in the form:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;###&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;so when I read the specification, I glossed over that section, only thinking
of Atx Headers as containers for normal text.  However, based on the specification,
the following text is also allowed:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;### This *is* `my` header&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As a result, instead of the header text &lt;code&gt;This is my header&lt;/code&gt; being generated by the
first sample, I can use the second sample to generate the header text of
&lt;code&gt;This &amp;lt;em&amp;gt;is&amp;lt;/em&amp;gt; &amp;lt;code&amp;gt;my&amp;lt;/code&amp;gt; header&lt;/code&gt;.  Neat!&lt;/p&gt;
&lt;p&gt;The change itself was pretty simple, and confined to the &lt;code&gt;parse_atx_headings&lt;/code&gt; function.
As it was a simple change, the accompanying change in each test was also pretty
simple:  take a single Atx Header token with text, replace it with an Atx Header token
without the text, a Text token with the text, and an End token for the Atx Header.&lt;/p&gt;
&lt;p&gt;While I was concerned that the fix for this issue was going to be more widespread,
it was confined to 22 scenario tests, and was really easy to verify.&lt;/p&gt;
&lt;h2 id="issue-7-bringing-the-tabs-back"&gt;Issue 7:  Bringing The Tabs Back&lt;a class="headerlink" href="#issue-7-bringing-the-tabs-back" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Looking for something to finish the refactoring session with, I decided to tackle one
of the longstanding fixes that I had some reservations about: the bulk conversion
of tabs to spaces.  While it was a good fix at the time, I suspected that there
might be problems with the code blocks where all text is supposed to be preserved
literally, including tab characters.&lt;/p&gt;
&lt;p&gt;In a stroke of luck, all of the affected scenario tests are in the
&lt;code&gt;test_markdown_tabs.py&lt;/code&gt; file
and the places where tabs are important can be grouped into 2 distinct groups.
In the Markdown specification, there is a distinction between whether there is enough
whitespace for an indented code block with 4 spaces, or not with less then 4 spaces.
To address those cases, I simply added the &lt;code&gt;is_length_greater_than_or_equal_to&lt;/code&gt; and
&lt;code&gt;is_length_less_than_or_equal_to&lt;/code&gt; functions.  While I could have simply used a &lt;code&gt;not&lt;/code&gt;
modifier to get the same effect, I thought it was more readable to simply spell it
out.  For cases where the actual length was needed, the &lt;code&gt;calculate_length&lt;/code&gt; function
determines the length of the string, allowing for the length of a tab to be 4
characters while every other character is assigned a length of 1.&lt;/p&gt;
&lt;p&gt;While this wasn’t a very technical issue to fix, it helped me return things to a known
good state, with confidence that tabs were being treated properly.  Before this fix,
I was always concerned that the bulk translation of tab characters to spaces would
introduce a hard to diagnose issue.  With that translation removed, that concern went
away.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;At various points in the development of PyMarkdown, I have wondered if my thinking
should be more realistic with a “two steps forward, one step back” feel to it.  Maybe
it’s just who I am, but with a few exceptions, I see almost all of this development as
stepping forward with quality, and hence, all positive.  I actually like the fact that
I am implementing some new features, then doing some refactoring, and repeating.  It
gives me a solid perception that the project is on stable footing at every stage,
accumulating little technical debt along the way.&lt;/p&gt;
&lt;p&gt;Something that struck me at this point was how easily I seemed to fall into a rhythm
that works well for me and the project:  implementing a couple of features, noting down
any issues as I implement, and then fixing a couple of the more pressing issues before
repeating the pattern.  I am not sure if that kind of a pattern that everyone else
works well with, but it seems to work well for me.  To a certain extent, it also helps
me write these articles, as writing about quality software is very different than
the development of that software.  For me, I find that they compliment each other
very well.&lt;/p&gt;
&lt;p&gt;In terms of energy, keeping that rhythm going and writing these articles is
helping to keep me charged up about the project.  While I have written my share of
parsers in my career, they have almost always been for work projects with a specific
goal and deadline to achieve.  Being freed from those restrictions does come with
it’s benefits, but not having someone looking over your shoulder means that you have
to take on that role yourself.  These articles, while initially created to talk about
my approach in creating quality software, also server the purpose of keeping me
honest and responsible to any readers.  Call it a backup plan, but it seems to be
working well!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Going back to the specification for features to implement, I decided to start at the
end and get the line breaks, autolinks, and raw html inline processing taken care of.
While I don’t use them frequently myself, they are interesting aspects to the
GFM specification, and perhaps learning about them will increase my use of them in
my everyday Markdown usage.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:Space"&gt;
&lt;p&gt;The string &lt;code&gt;&amp;lt;space&amp;gt;&lt;/code&gt; represents a space character, which by it’s very nature, is invisible. &lt;a class="footnote-backref" href="#fnref:Space" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;a class="footnote-backref" href="#fnref2:Space" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:Missing"&gt;
&lt;p&gt;The specification states “The paragraph’s raw content is formed by concatenating the lines and removing initial and final whitespace.”  This is the closest reference that I could find to removing whitespace.  Perhaps initial means per line? &lt;a class="footnote-backref" href="#fnref:Missing" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Starting Inline Processing</title><link href="https://jackdewinter.github.io/2020/02/24/markdown-linter-starting-inline-processing/" rel="alternate"></link><published>2020-02-24T00:00:00-08:00</published><updated>2020-02-24T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-24:/2020/02/24/markdown-linter-starting-inline-processing/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Maybe it’s just me, but I love the feeling of completing a good round of refactoring
where I really get to focus on making sure that the foundations of the project are
stable.  If it helps any readers, I imagine it as a spa day for your project …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Maybe it’s just me, but I love the feeling of completing a good round of refactoring
where I really get to focus on making sure that the foundations of the project are
stable.  If it helps any readers, I imagine it as a spa day for your project where the
project just gets some personalized attention and cleaning up.  While the project isn’t
in a perfectly clean state, I know that I performed a decent amount of tidying up in
that direction, work that will help the project as it grows.&lt;/p&gt;
&lt;p&gt;With the project cleaned up, and with the new changes to make the text blocks
continuous, it was time to start on
the inline processing.  The first three inline elements to be implemented were the
first three elements in the
&lt;a href="https://github.github.com/gfm/"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;:
backslashes, character references, and code spans.  These elements allow Markdown to
escape certain characters, replace a text sequence with a single Unicode character,
or indicate that some text is literal code.  Each of these elements has it’s own
special use, and are used very frequently when writing Markdown documents.  And if those
reasons weren’t good enough, they just happen to be the first three sections in the
specification’s inline processing section.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/5c175f68fbe182d052a83d43061443921aae7bc9"&gt;08 February 2020&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/235c0c63f6ee5cb41e1f8e71fa4081b36ba1beef"&gt;14 February 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="inline-processing"&gt;Inline Processing&lt;a class="headerlink" href="#inline-processing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In Markdown processing, there are two main types of processing that occur: processing
to sort the text into blocks and the processing of the contents for those blocks.
Courtesy of
&lt;a href="https://github.github.com/gfm/#blocks-and-inlines"&gt;the specification&lt;/a&gt;,
another good explanation is as follows:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We can think of a document as a sequence of blocks — structural elements like paragraphs, block quotations, lists, headings, rules, and code blocks. Some blocks (like block quotes and list items) contain other blocks; others (like headings and paragraphs) contain inline content — text, links, emphasized text, images, code spans, and so on.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;While it was not readily apparent on my first read of the specification, inline
processing occurs only on the content of leaf blocks that do not strictly govern their
content.  As code blocks contain the literal content for their output and HTML blocks
contain the literal HTML content for their output, inline processing is not applied to
those blocks.  Inline processing is applied to the content of the remaining blocks, the
headings blocks and the paragraph blocks, which just happen to be the most frequently
used blocks in most Markdown documents.&lt;/p&gt;
&lt;h3 id="backslash-escapes"&gt;Backslash Escapes&lt;a class="headerlink" href="#backslash-escapes" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having completed most of the processing required for the leaf blocks and container
blocks, it was
time to move on to the inline processing of the content within those blocks.
The first of the inline processes to be worked on: the backslash escapes.&lt;/p&gt;
&lt;p&gt;For readers familiar with backslashes in modern programming languages, Markdown’s
usage of backslashes are similar, but with a twist.  In modern programming languages,
a backslash character is used in strings to escape the character following the
backslash, using that next character to denote a special character. For each special
character to be represented, a distinct backslash escape sequence is used to represent
it.  For example, most languages include the escape sequence &lt;code&gt;\n&lt;/code&gt; for a line feed or
end-of-line character.  This backslash escape is used so often that many programmers
use the terms “slash-en” or “backslash-en” instead of referring to the &lt;code&gt;\n&lt;/code&gt; character
sequence as the new-line character it represents.&lt;/p&gt;
&lt;p&gt;The twist that I mentioned earlier is that Markdown, unlike programming languages,
uses backslash escapes to only escape the following ASCII punctuation characters with
themselves:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;!"#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;For example, the string &lt;code&gt;\!&lt;/code&gt; will emit the sequence ‘!’, but the string &lt;code&gt;\a&lt;/code&gt; will emit
the sequence &lt;code&gt;\a&lt;/code&gt;.  Coming from a programming background, this took a bit of getting
used to, but it makes sense.  As Markdown is used to create a human readable document,
authors should not be concerning themselves with control characters, but with how the
content is organized.  From that point of view, escaping the punctuation characters
used to denote organization makes a lot of sense.&lt;/p&gt;
&lt;p&gt;It then follows that each processing character is included in that string of
characters, and that the most prominent use of backslash escapes in Markdown is to
avoid block and inline processing.  Because a backslash escaped character is emitted as
part of the backslash processing in the parser, any other processing of that character
by the parser is effectively short-circuited. This simply allows the punctuation
character to be represented without the parser mistaking it for any kind of processing
instruction.&lt;/p&gt;
&lt;p&gt;For
example, to include the text &lt;code&gt;&amp;amp;amp;&lt;/code&gt; in your document the sequence &lt;code&gt;\&amp;amp;amp;&lt;/code&gt; can be
used to escape the ‘&amp;amp;‘ character.&lt;sup id="fnref:escapingAmp"&gt;&lt;a class="footnote-ref" href="#fn:escapingAmp"&gt;1&lt;/a&gt;&lt;/sup&gt;  Another example is that the
following text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;will generate the text &lt;code&gt;- this is a paragraph&lt;/code&gt; as part of a paragraph, instead of
creating a list item containing the paragraph &lt;code&gt;this is a paragraph&lt;/code&gt;.  In both cases,
the backslash escapes are used to tell the parser to just treat the escaped character
as itself and not to perform any further processing.  As useful as that
is, backslashes escapes cannot be used in code blocks, which have been covered
previously, code spans, which are covered later in this article, or autolinks and raw
HTML, which are covered in a future article.&lt;/p&gt;
&lt;p&gt;Implementing support for backslash escapes was pretty easy, as it just required a
change in how the characters were interpreted.  As the text was still contained within
a single text block, it was just a matter of making sure the right characters were
emitted.  This was relatively easy as the processing was easy:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;is the next character a backslash?&lt;/li&gt;
&lt;li&gt;if not, emit a backslash and resume normal processing&lt;/li&gt;
&lt;li&gt;if so, check to see what character follows&lt;ul&gt;
&lt;li&gt;if that character is not in the escape list above, emit a backslash and resume normal processing&lt;/li&gt;
&lt;li&gt;if so, consume that character and emit that character&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Basically, if there is a valid backslash sequence, emit the second character and consume
it, otherwise, emit first character (the backslash character) and continue.  The limits
on where backslashes can be used was pretty easy to implement, as there were only a few
places where they were not allowed.&lt;/p&gt;
&lt;h3 id="character-references"&gt;Character References&lt;a class="headerlink" href="#character-references" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Character references are an important part of HTML, and as such, Markdown has solid
support for them built in.  Character references allow for the
inclusion of special characters into the document, without the need to rely on the
file editor to support Unicode characters.  In addition, the document’s writability and
readability is often enhanced by presenting the reader with the text &lt;code&gt;&amp;amp;copy;&lt;/code&gt; instead
of the symbol ‘©‘.&lt;/p&gt;
&lt;p&gt;Think about it this way. As a document author, you want to add the copyright symbol to
your document. Where do you find it on your keyboard?  If it is not there,
what is the clearest and easiest way to add it to the document that is not tied to a
specific editor?  Markdown addresses this issue by reusing the HTML5 method of
specifying character references.&lt;/p&gt;
&lt;p&gt;For each character reference, it starts with the ‘&amp;amp;‘ character
and ends with the ‘;’ character, with characters between to denote the type of
character to reference and what the actual reference is.  Named character entity
references are the easiest to
read, as they contain some form of the name of the character they represent, such as
&lt;code&gt;&amp;amp;copy;&lt;/code&gt; for the copyright symbol.  The full list of
named character references that are supported is at the
&lt;a href="https://html.spec.whatwg.org/multipage/entities.json"&gt;HTML5 entity names document&lt;/a&gt;. &lt;sup id="fnref:namedEntities"&gt;&lt;a class="footnote-ref" href="#fn:namedEntities"&gt;2&lt;/a&gt;&lt;/sup&gt;
As an alternative to the &lt;code&gt;&amp;amp;copy;&lt;/code&gt; named reference, the equivalent numeric references
&lt;code&gt;&amp;amp;#169;&lt;/code&gt; or &lt;code&gt;&amp;amp;#x00A9&lt;/code&gt; may be used instead.  While the end result on the rendered page
is the same, I feel that the named references are more readable than the numeric
references.
However, in cases where there is no named reference for a given Unicode character, the
numeric references are very handy.&lt;/p&gt;
&lt;p&gt;Similar to the way in which backslash escapes are
handled, there are certain blocks that the character references cannot be used in.  In
particular, they are not recognized in code blocks and code spans, but are recognized
in most other locations.  For example&lt;sup id="fnref:refExample"&gt;&lt;a class="footnote-ref" href="#fn:refExample"&gt;3&lt;/a&gt;&lt;/sup&gt;, given the following Markdown text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;```&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;ouml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;the character references in the fenced blocks’s info string are recognized, but the
character references within the code block are not recognized.  As such, after
translating this Markdown into HTML, the following HTML is expected:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt; &lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;"language-föö"&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;f&lt;span class="ni"&gt;&amp;amp;ouml;&amp;amp;ouml;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;code&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;pre&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the example, as expected, the character references that feed the &lt;code&gt;class&lt;/code&gt; attribute
for the &lt;code&gt;code&lt;/code&gt; tag were translated, while the character references within the bounds of
the &lt;code&gt;code&lt;/code&gt; tag, which are used to denote a code block, are left alone.&lt;/p&gt;
&lt;p&gt;Similar to my experience in processing the backslashes, the implementation for all
three character references were processed in roughly the same manner.  Instead of a
single character to look for with backslash escapes, character references have a
set of allowable character sequences, but otherwise the processing is the same.  Once
again, the processing was really simple, just follow simple rules.&lt;/p&gt;
&lt;p&gt;However, while it was not particularly difficult in itself, determining the proper
handling of the &lt;code&gt;entities.json&lt;/code&gt; file used as a reference for HTML named entities took a
bit of thinking to get right.  The main decision was whether or not to download it
each time, cache it somewhere once downloaded, or just do a “one-time” include of it
into the project as a resource.  In the end, I
decided to take the later path, placing the file in the &lt;code&gt;pymarkdown/resources/&lt;/code&gt;
directory.  My assumption is that file does not change that often, perhaps once a month
at it’s worst.  As I added the file exactly as it was downloaded from the source at
&lt;a href="https://html.spec.whatwg.org/entities.json"&gt;the HTML5 home page&lt;/a&gt;, I believe I can check
on it from time to time, updating the file when required.  With that decision made, I
just needed to do some research on the best way to include resources into a project,
and the rest was once again just following well documented instructions.&lt;/p&gt;
&lt;h3 id="code-spans"&gt;Code Spans&lt;a class="headerlink" href="#code-spans" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Code spans are similar to code blocks, in that they both protect the characters that are
within their confines.  However, while code blocks are designed to protect multiple
lines of text, such as source code examples, code spans are designed to protect text
within a single paragraph.  To create
a code span, the text to be protected is simply surrounded by one or more backtick (‘`’)
characters on each side, making sure that the number of starting backticks and closing
backticks are the same.&lt;/p&gt;
&lt;p&gt;As a simple example, the Markdown &lt;code&gt;`foo`&lt;/code&gt; produces the text &lt;code&gt;foo&lt;/code&gt; within a special
HTML tag that has special styling associated within it. Similar to how code blocks
protect blocks of text that are already formatted in a specific way,  these code spans
use that styling  are used to specify targeted text that
already has meaning attached to it.  In my articles, as with other blog authors that
I have read, I use code spans to indicate that certain strings have literal meaning to
them, such as the literal text to type in at a keyboard.&lt;/p&gt;
&lt;p&gt;One good example of this from the previous section are the examples of the various
Markdown sequences needed to produce the copyright symbol.  If I had simply added
the text &lt;code&gt;&amp;amp;copy;&lt;/code&gt; to the Markdown document, it will be interpreted as a character
sequence, and the ‘©‘ symbol will be generated.  By placing backticks around
that text, such as &lt;code&gt;`&amp;amp;copy;`&lt;/code&gt;, those characters are contained within a code span
and the text is preserved literally.  And for that last sentence where I needed to
include the literal text including backticks, I just made sure to include more
backticks around the text than were contained within the text,
such as &lt;code&gt;`` `&amp;amp;copy;` ``&lt;/code&gt;.&lt;sup id="fnref:doubleBacktick"&gt;&lt;a class="footnote-ref" href="#fn:doubleBacktick"&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;I knew that the parsing and rendering of the tokens was about to get more complex in
order to properly implement the code span processing.  To keep the code span, the
text before it, and the text after it in the right order, I changed the inline parsing
to allow for a markdown token to be emitted.  When the new code span Markdown token is
emitted, the surrounding code first adds a new text block containing any text
collected up until that point, emits the new token, and then resets the
collected text back to the empty string.  This correctly ordered the tokens, and
is generic enough to hopefully future-proof similar parsing in the future.&lt;/p&gt;
&lt;p&gt;There were only a small number of issues with the existing scenarios that needed to be
addressed, now that code spans were handled properly.  Fixing those tests was simple
and just required resampling the parser’s output.  But during that testing, I realized
I had made a mistake with the handling of one of the header blocks.  When I wrote the
original code for the Atx Header blocks, as documented in the article on
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/#group-2-headers"&gt;Parsing Normal Markdown Blocks&lt;/a&gt;,
I hadn’t thought about code spans or other more complex inline elements as part of an
Atx header.  As such, I therefore I wrote a simple implementation that represented the
header text as a simple string within the token.&lt;/p&gt;
&lt;p&gt;Double checking the specification, I verified that there were no restrictions on using
code spans within a SetExt or Atx header block.  As such, I needed to rewrite the
parsing code to support having Atx header blocks contain text blocks, instead of
simply including the enclosed text in the Atx Markdown token.  Instead of tackling
that as part of this group of code, I decided to look to see if there were any other
“little” things that I missed, and I found a number of them.&lt;/p&gt;
&lt;p&gt;Basically, of the issues that I found, most of them were small variations of the
scenarios, things that just got lost in the shuffle or lost in the translation.  As
such, I thought it would be best to take some time, try and note them all down, and
then tackle them together before continuing.  As the only scenario test that was
affected was example 339, I believe that temporarily skipping that test and taking the
time to fix those issues was the right call.  It would mean that I would have to
wait a bit before I could say that code spans were done, but when they were done, I
would know that I did them the right way.  That was, and still is, important to me.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I usually read a specification thoroughly and identify most of the edge cases on my
first pass.  However, I must admit that I dropped the ball with that on this project.
And to be totally honest, I don’t expect that it will be the last time either.  It’s
a big specification, and there are going to be hits and misses along the way.  What
matters to me is not whether I make the mistakes, but that I don’t have enough use
cases, scenarios, and tests to help me identify any mistakes.  With 673 scenarios
already identified in the specification, I know the coverage for scenario will be good,
but there will be gaps that I will still need to address.  So whether it is my dropping
the ball or the specification dropping the ball, the work on the these three inline
elements has improved my confidence that I am prepared to deal with any such issues
that come up.&lt;/p&gt;
&lt;p&gt;A good example of this is my reading of the specification around the use of Atx headers.
I know I missed the part where the specification, in the preamble to
&lt;a href="https://github.github.com/gfm/#example-36"&gt;example 36&lt;/a&gt; says:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Contents are parsed as inlines:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In retrospect, not only is this one of the few times inlines with Atx headers was
mentioned, but there is also only one scenario that covers them, example 36. So, from
one point of view, the specification could have more scenarios dealing with inlines
and Atx headers.  From an additional point of view, it was mentioned and I just
missed it.  From my personal point of view, it doesn’t matter either way.  What matters
is that I had sufficient process and tools in place to catch it.  And once I saw that
issue, it helped me take a deeper look at some of the other tests, finding small issues
with the output from those tests.&lt;/p&gt;
&lt;p&gt;From a quality point of view, my confidence was actually holding steady or increasing.
As I mentioned a couple of paragraph ago, I don’t expect to be perfect, I just hope
to have the right tools and processes in place to help me figure out when I miss
something or get something wrong.  Sure, I realized that taking some time to work on
fixing these issues was going to put my work on the linter on hold for another week.
But my confidence that the linter was on solid footing actually increased because I
found some issues.&lt;/p&gt;
&lt;p&gt;For me, quality is not about being perfect, it’s about movement in the right direction.
And finding those issues, was a step in that right direction.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After documenting those issues at the end of the &lt;code&gt;test_markdown_list.py&lt;/code&gt; file, I
thought it was best to do a quality pass and resolve those issues before moving on to
other inline processes.  As such, the next article focuses on what bugs I found in the
scenario tests, and how I addressed them.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:escapingAmp"&gt;
&lt;p&gt;Just to be complete, the character escapes in the next section also provide a way to include the ‘&amp;amp;‘ sequence in Markdown.  Using character references, this is by using the text &lt;code&gt;&amp;amp;amp;amp;&lt;/code&gt; instead of &lt;code&gt;\&amp;amp;amp;&lt;/code&gt;.  While both produce identical output, I prefer the first for it’s clarity.  Your mileage may vary. &lt;a class="footnote-backref" href="#fnref:escapingAmp" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:namedEntities"&gt;
&lt;p&gt;To keep things simple for parsers, this file is maintained as a JSON file that is easily interpreted with a small amount of code in most current languages. &lt;a class="footnote-backref" href="#fnref:namedEntities" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:refExample"&gt;
&lt;p&gt;Note that this example is a slightly modified version of &lt;a href="https://github.github.com/gfm/#example-330"&gt;example 330&lt;/a&gt; from the GFM specification. &lt;a class="footnote-backref" href="#fnref:refExample" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:doubleBacktick"&gt;
&lt;p&gt;For a good example of this, see &lt;a href="https://github.github.com/gfm/#example-339"&gt;example 339&lt;/a&gt; in the GFM specification. &lt;a class="footnote-backref" href="#fnref:doubleBacktick" title="Jump back to footnote 4 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Taking Time to Refactor -- Post-Block Implementation</title><link href="https://jackdewinter.github.io/2020/02/17/markdown-linter-taking-time-to-refactor-post-block-implementation/" rel="alternate"></link><published>2020-02-17T00:00:00-08:00</published><updated>2020-02-17T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-17:/2020/02/17/markdown-linter-taking-time-to-refactor-post-block-implementation/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The title of the article is not very glamorous, but it describes the changes I made to
the project after the block processing and before the inline processing.  From a project
completeness viewpoint, all of the block elements were done except for table blocks and
link reference definitions, and …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The title of the article is not very glamorous, but it describes the changes I made to
the project after the block processing and before the inline processing.  From a project
completeness viewpoint, all of the block elements were done except for table blocks and
link reference definitions, and those were temporarily shelved.  The big decision before
me was whether or not to plow ahead with inline processing or take some time to clean
things up before continuing.&lt;/p&gt;
&lt;p&gt;After weighing the options in my head for a while, I decided to take some time to tidy
up my work on my PyScan script and document it in
&lt;a href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/"&gt;this article&lt;/a&gt;.
Part of that decision was based on the time of year (it was the holiday season) and the
other part of the decision was based on timing for the PyMarkdown project.  At this
point, the blocks were mostly finished and the inline processing was the next feature
to be implemented.  To me, it just made good sense to clean up the PyScan tool, write
an article or two on it, and refactor some of the PyMarkdown project before moving
forward with inline processing.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/98b479816d74d04715a1f2c23c6941836ad1a70c"&gt;20 December 2019&lt;/a&gt; and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/eebbf07d72836f14fb3b20ef2d3c1e0139e942a2"&gt;31 January 2020&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="refactor-1-extracting-function-groups"&gt;Refactor #1: Extracting Function Groups&lt;a class="headerlink" href="#refactor-1-extracting-function-groups" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first things that I wanted to refactor were the generic helper functions used for
parsing and the helper functions used for dealing with HTML.  While the parsing helper
functions were already at the end of the &lt;code&gt;tokenized_markdown.py&lt;/code&gt; file, it made sense to
move the HTML helper functions down to the same location at the end of the file.  Once
that was accomplished, it took me about 2 milliseconds to figure out that they should
be in their own modules.  Hence, the parsing helper functions were moved out into the
&lt;code&gt;parser_helper.py&lt;/code&gt; file and the HTML helper functions were moved out into the
&lt;code&gt;html_helper.py&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;Along the way, proper unit tests were added for these functions.  As part of the normal
process of parsing the Markdown document, they had been battle tested by their usage,
but having their own dedicated unit tests was the right thing to do.  The unit tests
for the parsing helper functions were all added with filenames that are the string
&lt;code&gt;test_&lt;/code&gt; followed by the name of the distinct function that they test.  As the HTML
helper functions more tightly coupled that the parser functions, I kept their unit
tests coupled by added all of them to the &lt;code&gt;test_html_tags.py&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;This refactoring was performed to reduce the complexity and maintenance of the main
module.  By moving these functions to well-defined modules of their own, I instantly
found that it was easy to find functions in either module, instead of search for them
at the end of the main file.  For me, that feedback is always a good sign that the
refactor was the right thing to do.&lt;/p&gt;
&lt;h2 id="refactor-2-reducing-complexity-with-is_character_at_index_one_of"&gt;Refactor #2: Reducing Complexity with &lt;code&gt;is_character_at_index_one_of&lt;/code&gt;&lt;a class="headerlink" href="#refactor-2-reducing-complexity-with-is_character_at_index_one_of" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I was looking through the code for the previous refactoring, I noticed that there
were a number of functions that were “too big”.  From experience, I find that these
type of functions usually have more than one responsibility, and reducing those
responsibilities reduces their complexity.  The first example of this that I found was
the &lt;code&gt;is_fenced_code_block&lt;/code&gt; function, which included the following series of lines:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;skip_whitespace_check&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"~"&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"`"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While the first two lines were specific to the function, the last two lines followed a
pattern that happened again and again in that module.  Because those last two lines are
really checking to see if the next character is one of the two values, I extracted
that logic into a new &lt;code&gt;is_character_at_index_one_of&lt;/code&gt; function for the &lt;code&gt;ParserHelper&lt;/code&gt;
module, and added tests into &lt;code&gt;test_is_character_at_index.py&lt;/code&gt; module.&lt;/p&gt;
&lt;p&gt;This refactoring had a noticeable impact on the complexity of each of the modules that
used the new function.  This impact was a reduction in the number of branches in each
function, with each count decreasing by one for each character to look for.  As an
example, the &lt;code&gt;is_fenced_code_block&lt;/code&gt; code above went from the snippet above to the
following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;extracted_whitespace&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;skip_whitespace_check&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_character_at_index_one_of&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fenced_code_block_start_characters&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That is a reduction from 5 branches down to 3 branches, making that function and that
module less complex in the process.  In addition, instead of reading those two lines
and trying to figure out what they are doing, the function call to the
&lt;code&gt;is_character_at_index_one_of&lt;/code&gt; function eliminates the “what is it doing” step, making
it easier for someone reading the code to understand those lines.&lt;/p&gt;
&lt;h2 id="refactor-3-simplifying-the-close_open_blocks-function"&gt;Refactor #3: Simplifying The &lt;code&gt;close_open_blocks&lt;/code&gt; Function&lt;a class="headerlink" href="#refactor-3-simplifying-the-close_open_blocks-function" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This refactoring was a simple one, but for me it had a noticeable impact on helping
me get a clearer understanding of the function.  Prior to the change, the
&lt;code&gt;close_open_blocks&lt;/code&gt; function had 2 distinct responsibilities: determine if the element
on the top of the stack needed to be closed, and if so, remove that element from the
top and close the block. While I was able to read the function and use it properly,
I often had a little question in my head about whether or not I was using the
function properly.&lt;/p&gt;
&lt;p&gt;After the refactoring, the code containing the first responsibility remained in the
&lt;code&gt;close_open_blocks&lt;/code&gt; function and the code for the second responsibility was placed in
the new &lt;code&gt;remove_top_element_from_stack&lt;/code&gt; function.  When I looked at those two functions
during the writing of this article, I was able to see a very clear picture of what each
function is doing, with clear delineations of those responsibilities.  The
&lt;code&gt;close_open_blocks&lt;/code&gt; implements a while loop with 4 distinct ways to exit out of the
loop, and the &lt;code&gt;remove_top_element_from_stack&lt;/code&gt; function remove the top element, adding
the appropriate tokens to the document’s token stream.  Clear and concise, hence easy
to read.&lt;/p&gt;
&lt;p&gt;This function is core to the processing of the blocks, and making it clearer was
important to me.  While it was a small refactor, it increased my confidence that the
function, and any functions that called it, were operating properly.  I believe that my
confidence increased because it went from one “messy” function to two separate
functions with very clear intentions.  By rewriting the code into two functions and
keeping each function simple, the messiness vanished.&lt;/p&gt;
&lt;h2 id="refactor-4-cleaning-up-the-determine_html_block_type-function"&gt;Refactor #4: Cleaning Up the &lt;code&gt;determine_html_block_type&lt;/code&gt; Function&lt;a class="headerlink" href="#refactor-4-cleaning-up-the-determine_html_block_type-function" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I’ll admit, the next candidate, the &lt;code&gt;determine_html_block_type&lt;/code&gt; function was a mess.
At 88 lines long and 24 branches, it was definitely a function with too many
responsibilities.  Similar to the work documented in the previous section, I started to
take a look at this function and try and figure out what it was doing.  When I finished,
I came away with three responsibilities that the function was performing:
handling the special case (html block types 1 to 5), handling the normal cases (html
block types 6 and 7), and some cleaning up of the results for html block type 7.  That
was two responsibilities too many.&lt;/p&gt;
&lt;p&gt;Similar in essence to the work above, the &lt;code&gt;determine_html_block_type&lt;/code&gt; function was
broken up along the identified lines of responsibility.  The
&lt;code&gt;check_for_special_html_blocks&lt;/code&gt; function was created to handle the special cases, the
&lt;code&gt;check_for_normal_html_blocks&lt;/code&gt; function was created to handle the normal cases, and the
&lt;code&gt;determine_html_block_type&lt;/code&gt; function contained orchestration logic for calling those
two functions, plus the special cleaning up for the html block type 7 logic.&lt;/p&gt;
&lt;p&gt;While this function isn’t as core to the parser as the &lt;code&gt;close_open_blocks&lt;/code&gt; function,
its refactoring had a similar effect.  Each of the added functions contained a single
responsibility, this making the usage of all three functions together easy to determine.
For me, that was good progress.&lt;/p&gt;
&lt;h2 id="refactor-4-clearing-pylint-warnings"&gt;Refactor #4: Clearing PyLint warnings&lt;a class="headerlink" href="#refactor-4-clearing-pylint-warnings" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the writing of this article, the first thought that came to mind when writing
this section was that I should be ashamed that it took me until this point to address
the PyLint warnings on the project.  Taking a bit of a deeper look into how I
felt about this, I believe it had to do with where I draw the line between
“just playing around” and “real code”.  For me, I believe this transition is when a
project moves from a Proof-Of-Concept project to a Real™ project.  I am not 100%
sure, but I believe that it was at this point, give or take a couple of days, that I
felt that this was a real project.  While it is hard to pin down why, I believe that
having the block section of the specification done helped my mind crystalize that
the project is going to happen.  It was as if someone had whispered “This is going
to happen” in my ear, and that I needed to tidy things up.  Once I figured that out,
it just felt like a natural transition, nothing to be ashamed about.&lt;/p&gt;
&lt;p&gt;Now that this was a Real™ project, I needed to ensure that any PyLint
warnings were addressed or suppressed.  While I prefer to address these issues, some of
the warnings, such as the &lt;code&gt;too-many-arguments&lt;/code&gt; warning, occupy one of my grey areas.
Especially
with parsers, a lot of state information needs to be passed around, to ensure the
parsing is performed properly.  This often results in functions that take too many
arguments.  At this stage of the project, I decided to suppress those warnings, with a
number of &lt;code&gt;too-many-locals&lt;/code&gt; warnings until later in the project, when I have a better
sense of how to optimize those function calls for this parser.&lt;/p&gt;
&lt;p&gt;This refactoring helped me remember an old adage a friend taught me about software:
“It isn’t if there is a problem with your code, it is a question of how often the
problems within your code occur.”  More of a realist than a pessimist, he figured that
each line of code brought a new set of issues and bugs with it, and it was our job to
discover and handle those issues that our users would find before they found them.
For me, it was a good refresher in humility when developing software.&lt;/p&gt;
&lt;h2 id="refactor-5-reducing-complexity-with-the-92at_index92-functions"&gt;Refactor #5: Reducing Complexity with the \&lt;em&gt;at_index\&lt;/em&gt; Functions&lt;a class="headerlink" href="#refactor-5-reducing-complexity-with-the-92at_index92-functions" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Ever since the section above on
&lt;a href="https://jackdewinter.github.io/2020/02/17/markdown-linter-taking-time-to-refactor-post-block-implementation/#bob"&gt;parser functions&lt;/a&gt;,
I had been slowly searching for other patterns that I could refactor.  In the process, I
found a group of patterns that weren’t complex, but would benefit from a small
refactor.  Basically, a refactoring of that pattern wouldn’t make a lot of
difference in reducing the number of branches, but it would reduce the complexity of
the functions by making them easier to read.&lt;/p&gt;
&lt;p&gt;The group of patterns that I found all centered around finding out whether or not a
character or a string was at a given location in the string.  Specifically, the parser
contained three of these patterns that I felt were worth extracting into their own
functions: &lt;code&gt;is_character_at_index&lt;/code&gt;, &lt;code&gt;are_characters_at_index&lt;/code&gt;, and
&lt;code&gt;is_character_at_index_not&lt;/code&gt;.  None of these functions would facilitate a large
improvement, but the change from the following text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;start_index&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="s2"&gt;"0"&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="s2"&gt;"9"&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;to this text:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="n"&gt;ParserHelper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;is_character_at_index_one_of&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;line_to_parse&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start_index&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digits&lt;/span&gt;
        &lt;span class="p"&gt;):&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;produces more readable code by simply stating the intent of those lines, instead of
leaving the reader to interpret them.&lt;/p&gt;
&lt;p&gt;While I admit that it wasn’t a big change, to me this refactoring provided some extra
confidence that the project was getting to a cleaner place.  Sometimes refactoring
produces big, measurable impacts, and sometimes they produce little ripples that are
barely noticeable.  However, sometimes those little ripples can mean a lot, and worth
a lot.&lt;/p&gt;
&lt;h2 id="refactor-6-increasing-code-coverage"&gt;Refactor #6: Increasing Code Coverage&lt;a class="headerlink" href="#refactor-6-increasing-code-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;After a number of refactors to do with parsing, I noticed that the PyScan numbers
for code coverage were in the high nineties, which is very good for a number of
projects.  However, in a project that was designed from the ground up for high
code coverage numbers, such as the PyMarkdown project, there is almost always room
to do a bit better.&lt;/p&gt;
&lt;p&gt;In the case of the implementation of the HTML blocks, I implemented defensive
programming to try to ensure that edge cases were protected against.  In re-reading
the HTML block specification a couple of times, the focus of the specification seemed
to be focused on the main use cases, not the edge cases.  As such,
the code coverage report gave me good input on how to add 4 new use cases that helped
ensure that the edge cases for HTML blocks were fully covered.&lt;/p&gt;
&lt;p&gt;This type of refactoring is a difficult one for me to justify to some people, but I
feel strongly about it.  The justification centers around what level of code coverage
is considered “good enough”.  For myself, there are 2 main factors that weigh into my
decision on what is good enough with code quality: was the project designed with
testing in mind and what is the effort required to address the next issue.  In this
case, as minimal effort was required to add the 4 simple scenario tests to address the
issue, I would easily argue that it wasn’t good enough.  From my point of view, the
small cost easily justified the benefit.&lt;/p&gt;
&lt;h2 id="refactor-7-translating-token-strings-to-actual-tokens"&gt;Refactor #7: Translating Token Strings to Actual Tokens&lt;a class="headerlink" href="#refactor-7-translating-token-strings-to-actual-tokens" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having made the jump in my head from a Proof-of-Concept project to a Real™
project, I decided it was time to change the stack tokens and Markdown tokens from
simple text strings to actual token objects.  Up to this point, I was more concerned
that the tokens looked right in the output stream, and there were only a relatively few
number of cases where that output needed to be interrogated later.  With inline
processing on the horizon, which would heavily make use of token content, it made sense
to me to undergo this change before the inline processing started.&lt;/p&gt;
&lt;p&gt;The two places where I had made this tradeoff were the stack tokens and the Markdown
document tokens.  The stack tokens denote where in the processing the parser is and
the Markdown document tokens denote what was found during the processing.  In both
cases, it was more important to me to see the right patterns being parsed than to tie
them down to a given structure.  Based on experience, I wanted to do the least possible
work to get to this point, and then have the structure for each object emerge.&lt;/p&gt;
&lt;p&gt;For the &lt;code&gt;StackToken&lt;/code&gt; object, the structure that emerged was pretty simple.  Each class
is responsible for any of it’s own variables, but also for providing a read-only, text
version of these variables, assigned to the base class’s &lt;code&gt;extra_data&lt;/code&gt; variable.  In this
way, the base class can include a number of the useful functions without requiring any
knowledge about the child classes.  By implementing the &lt;code&gt;__str__&lt;/code&gt;, &lt;code&gt;__repr__&lt;/code&gt;, &lt;code&gt;__eq__&lt;/code&gt;,
and &lt;code&gt;generate_close_token&lt;/code&gt; in this way, each child class was kept very simple and
straightforward.  In addition, instead of using Python’s &lt;code&gt;isinstance&lt;/code&gt; function to figure
out the type of token, I added &lt;code&gt;is_*&lt;/code&gt; methods for each token type to make the code
referencing the tokens more readable.&lt;/p&gt;
&lt;p&gt;The refactoring for the &lt;code&gt;MarkdownToken&lt;/code&gt; object was almost the same as for the
&lt;code&gt;StackToken&lt;/code&gt; object, but with a couple
of key differences.  With the &lt;code&gt;StackToken&lt;/code&gt;, the token itself was the main focus of the
object, whereas with the &lt;code&gt;MarkdownToken&lt;/code&gt;, it is the data contained within the token
that is key.  The other big difference is that &lt;code&gt;MarkdownToken&lt;/code&gt; objects are the artifacts
that will be consumed and analyzed by the PyMarkdown project, not just an internal
representation.  As I had a lot of positive success with the design and use of the
&lt;code&gt;StackToken&lt;/code&gt; class, I modelled the &lt;code&gt;MarkdownToken&lt;/code&gt; class in a similar fashion, keeping
in mind the differences and altering the design to properly accommodate them.  From a
design point of view, things didn’t change things that much, but I needed to make sure
those objects look and function right, as they are very visible.&lt;/p&gt;
&lt;p&gt;This refactor was a long time coming, but I felt that it was the right time to do it.
As I mentioned in previous sections, the project felt more like a Real™ project
and not a proof of concept.  With a good bulk of the parsing completed, and with a
solid opinion of how I was going to orchestrate the remaining pieces, it was the right
time to nail down how those tokens would look to users of the project.  While I could
have done that earlier in the project, I believe that I wouldn’t have been able to
do so with the same confidence that I made the right choice.  For this project, I
believe that leaving the tokens in the raw form to this point was the best move
possible.&lt;/p&gt;
&lt;h2 id="refactor-8-consolidating-text-blocks"&gt;Refactor #8: Consolidating Text Blocks&lt;a class="headerlink" href="#refactor-8-consolidating-text-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Of all the refactors that I have talked about in this article, this refactor was the
one that I really needed to do.  Inline processing addresses the group of features that
expand on Markdown text within the blocks, and a lot of those processes assume that the
text within their blocks is one long string to process.  Currently, the text tokens
were distinct and disjoint, each one added in the order they were processed.  To get
ready for inline processing, those text tokens needed to be consolidated.&lt;/p&gt;
&lt;p&gt;There were two possible paths to take to accomplish this:  deal with the processing as
the text tokens were added or deal with them in a subsequent processing step.  As I want
to keep the processing logic as simple as possible, I decided that a follow-up step to
consolidate those tokens was the best course of action.  To accommodate this change, I
added the &lt;code&gt;coalesce_text_blocks&lt;/code&gt; function to simply go through the document tokens,
look for 2 text tokens beside each other, and append the second token’s text to the
first token.  Then, in the &lt;code&gt;transform&lt;/code&gt; function, instead of just returning the results
from the &lt;code&gt;parse_blocks_pass&lt;/code&gt; function, those results were passed to the
&lt;code&gt;coalesce_text_blocks&lt;/code&gt; and those were returned.&lt;/p&gt;
&lt;p&gt;While this change was a relatively small change, it impacted the token output for a lot
of the test cases.  In a meaningful way, that impact increased my confidence that
tackling it was the right choice to complete before inline processing started.  The
impact of the change on the test cases validated that it was a far reaching change,
one that was better to have happen before the next stage of processing.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unlike the other articles in this series, this article was about how I took a bit
of a breather and focused on improving the quality of the PyMarkdown project.  As
the next set of features involves inline processing of text blocks, I believe
whole heartedly that taking that break to focus on refactoring increased my confidence
that I was on the right track with the parser.  &lt;/p&gt;
&lt;p&gt;Why do I feel that way?&lt;/p&gt;
&lt;p&gt;Looking into the near future, I know that inline processing will increase the
complexity to the project, and any effort to reduce the project’s complexity ahead of
that will directly help reduce the complexity of the inline processing.  Further into
the future, there are extensions to
Markdown that I will need to add that will also increase the complexity of the
project.  Add to that my plans to comply with other Markdown specifications, such as
the CommonMark specification, which will also increase the complexity.&lt;/p&gt;
&lt;p&gt;Why refactor? I want to keep the project simple and uncomplicated.  From a software
quality point of view, each refactor makes the project more simple and more
uncomplicated.  While some of the changes didn’t move the needle on the software
quality meter much, each change helps.&lt;/p&gt;
&lt;p&gt;In the end, I refactor projects to keep them simple.  As Einstein said:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Make everything as simple as possible, but not simpler.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having teased the addition of inline processing to the project for most of this
article, the next article will be on the implementation of the first 3 aspects of
inline processing that I tackled.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Adding HTML Blocks</title><link href="https://jackdewinter.github.io/2020/02/10/markdown-linter-adding-html-blocks/" rel="alternate"></link><published>2020-02-10T00:00:00-08:00</published><updated>2020-02-10T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-10:/2020/02/10/markdown-linter-adding-html-blocks/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed most of the Markdown block elements, as documented
in the last two articles on
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;leaf blocks&lt;/a&gt; and
&lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/"&gt;container blocks&lt;/a&gt;,
I wanted to go back and revisit the HTML blocks that I deferred.  For anyone following
this series, in the
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/#group-4-stopping-at-a-good-place"&gt;Stopping At A Good Place section&lt;/a&gt;
of the …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having completed most of the Markdown block elements, as documented
in the last two articles on
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;leaf blocks&lt;/a&gt; and
&lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/"&gt;container blocks&lt;/a&gt;,
I wanted to go back and revisit the HTML blocks that I deferred.  For anyone following
this series, in the
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/#group-4-stopping-at-a-good-place"&gt;Stopping At A Good Place section&lt;/a&gt;
of the “Parsing Normal Markdown Blocks” article, I determined that there were 3 types
of leaf blocks that would be difficult to implement, so I deferred them.  Between
my lack of use most of those deferred features and my distinct status as the first
user of the parser, I thought this was a decent trade off in the short run.  With
increased confidence from implementing the other block types, I thought it was
a good time to deal with this block type.&lt;/p&gt;
&lt;p&gt;Before continuing, I believe it is important for me to highlight some information about
HTML blocks in Markdown.  I have never needed to use HTML
blocks or raw HTML (covered in a later article) in any of my own Markdown documents.
Quick research revealed that there are some interesting cases where injecting HTML
blocks is a benefit.  However, that same research also noted that allowing either type
of HTML in Markdown is a potential security issue, and as such, may be disabled for a
given Markdown-to-HTML generator.  Regardless of my usage patterns or security patterns,
I wanted to be sure to include it in the PyMarkdown project for completeness.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commit for
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/24fd972aef725bc55659ad3c2e7c1b93737a1874"&gt;20 December 2019&lt;/a&gt;.
This work includes implementing the parsing logic for the HTML Blocks as documented in
the GFM specification and implementing the parsing to pass all of the scenario tests
for HTML blocks that were previous entered.&lt;/p&gt;
&lt;h2 id="why-did-i-defer-html-blocks"&gt;Why Did I Defer HTML Blocks?&lt;a class="headerlink" href="#why-did-i-defer-html-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The HTML blocks were one of those 3 deferred types because a quick reading of the
specification lead me to believe the HTML block implementation would be tricky.&lt;/p&gt;
&lt;p&gt;Why?  Take a minute and read or browse the
&lt;a href="https://github.github.com/gfm/#html-blocks"&gt;HTML blocks section&lt;/a&gt; of the
GitHub Flavored Markdown (GFM) Specification.  Don’t worry, I’ll wait while you do that.&lt;/p&gt;
&lt;p&gt;Done?  What did you think?  My initial read of the specification made me think that it
was going to be a complete mess to figure out properly.  After a walk to clear my head,
I took another look at the section.  When I factored in the work I did to implement the
container blocks, this section looked like it would be tedious, but not too bad.  After
handling container blocks within container blocks, the straight parsing of a leaf block
wouldn’t be too bad. Right?&lt;/p&gt;
&lt;p&gt;I admit, it still looked kind of daunting to me.  From my observations, the 42 use
cases for
the HTML blocks was far more than the count for all of the other block groups
&lt;sup id="fnref:countScenarios"&gt;&lt;a class="footnote-ref" href="#fn:countScenarios"&gt;1&lt;/a&gt;&lt;/sup&gt; except for the list items group, at 47 use cases. And yes, the count
is mostly larger than the count for container blocks (with block quotes at 22 use
cases) and one half of the use cases for list blocks (with lists at 25 use cases and
list items at 47 use cases).  The data
backed my daunting feeling up, which was a relief.  Thinking about how I got to that
feeling, I realized that in reading the specification, I was telling myself a
story about how hard it would be to implement based on the sheer number of use cases.
So how was I going to change that narrative I was telling myself?&lt;/p&gt;
&lt;h2 id="changing-the-narrative"&gt;Changing The Narrative&lt;a class="headerlink" href="#changing-the-narrative" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In &lt;a href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/#what-was-my-experience-so-far"&gt;the last article&lt;/a&gt;,
I mentioned that one of my family’s favorite sayings is: “Stuff happens, pick yourself
up, dust yourself off, and figure out what to do next.”  “Stuff happens” was the
decision to defer the HTML blocks, “pick yourself up” was the decision to pick them up
again, “dust yourself off” was figuring out why I deferred the blocks, leaving the
“figure out what to do next” part.  One of my favorite tools to figure out what to do
next is to see if I am able to change the narrative, or story, with whatever it is that
I am doing.&lt;/p&gt;
&lt;p&gt;Why is this important?&lt;/p&gt;
&lt;p&gt;There are facts and opinions
that are part of every story.  Did the main character go to the cantina before boarding
the freighter with the smuggler?  That is a fact.  Whether or not the captain of that
freighter is a smuggler can be an opinion, depending on supporting facts.  How much
trust the main character had in that smuggler when boarding the freighter is mostly an
opinion.  The closer something is to a fact, the harder it is to change. Opinions can
be changed in many cases, if you can find the right story to tell.&lt;/p&gt;
&lt;p&gt;The HTML blocks having 42 use cases to define it’s behavior is a fact, and facts do not
change easily.  Taking a deeper look at the 7 categories at the
start of the specification’s section on HTML blocks, I can make a good argument that
there are 3 sets of HTML tags instead of the 7 presented:  the meta tags, the special
tags, and everything else.  Furthermore, the first 20 use cases present general cases
while the next 18 use cases, and the last 4 use cases talk about specific rules and why
they were specified.&lt;/p&gt;
&lt;p&gt;Given this information, I can change the story I am telling myself by breaking down
the previous story into smaller stories, each with a specific focus.  Instead of one
group of 42 use cases, I can
have 3 smaller groups: 1 for general HTML blocks with 20 use cases, 1 for specific
HTML blocks with 18 use cases, and finally a “wrap-up” group of 4 use cases that better
explains why the specified rules are important.&lt;/p&gt;
&lt;p&gt;Why is this better?&lt;/p&gt;
&lt;p&gt;At 42 use cases for HTML blocks, it is the second biggest block
of use cases, and is somewhat scary.  Breaking that group up into 2 groups of about 20
use cases followed by a small group with 4 example use cases is something I can
comprehend better, implement better, therefore removing my concerns about the large
scope.&lt;/p&gt;
&lt;p&gt;In addition, experience has taught me that when translating use cases to scenario tests,
the last 2 to 3 translations are frequently show stoppers or require major reworking to
properly translate and get working.
With a big group of 42 use cases, I know I would be expecting that behavior to happen,
with a large amount of rework to do when it happened.  After breaking down the problem
into the 3 smaller groups, I was fairly confident that if the same situation occurs, the
amount of rework will be limited to approximately 20 scenario tests.  For me, reducing
that perceived effort helped me keep my confidence up instead of having it take a hit.
Instead of “when it happens” with the 42 use cases, it became “if it happens” with the
smaller groups of 20 use cases.&lt;/p&gt;
&lt;h2 id="let-the-implementation-begin"&gt;Let The Implementation Begin!&lt;a class="headerlink" href="#let-the-implementation-begin" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With a boost to my confidence in place, I was able to get a decent amount of work
completed on the HTML blocks, wedged between shopping and work during the end of the
holiday season.  Despite my initial concerns
about the size and complexity of this feature, the development went pretty smoothly.
Given how it went, I believe it lends support to my opinion that breaking down the use
cases into the 3 groups was definitely the right thing to do.&lt;/p&gt;
&lt;p&gt;For those not familiar with Markdown and HTML, there some basic rules for HTML blocks,
and then the 3 categories of HTML blocks themselves: the meta tags, the special tags,
and everything else.  The basic rules are pretty simple.  HTML blocks are always
started with tags that start at the beginning of a new line, and once the start
condition is met for one of the 7 block types, only the matching end condition finishes
off the HTML block.  In some cases, the end conditions can be met on the same line, and
in some cases, the end conditions make sense… and in some they don’t. At least not
without understanding the rules!&lt;/p&gt;
&lt;h3 id="meta-tags"&gt;Meta Tags&lt;a class="headerlink" href="#meta-tags" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Block type 1 contains what I refer to as the “meta tags”, because those tags usually
contain information that is at a higher level than normal tags, such as script
information or style information.  For anyone familiar with authoring HTML, the
Markdown interpretation of these tags is almost the same as in a raw HTML document.
The start
condition is that one of the strings &lt;code&gt;&amp;lt;script&lt;/code&gt;, &lt;code&gt;&amp;lt;pre&lt;/code&gt;, or &lt;code&gt;&amp;lt;style&lt;/code&gt; are present,
followed by whitespace, the string &lt;code&gt;&amp;gt;&lt;/code&gt; or the end of the line.  The end condition is
that one of the strings &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;/style&amp;gt;&lt;/code&gt; are present, though the
tags specified in the start condition and end condition do not need to match each
other.&lt;/p&gt;
&lt;p&gt;As such, the following text is considered a complete HTML block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;style&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;"text/css"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
h1 { font-size: 140%; font-weight: bold; border-top: 1px solid gray; padding-top: 0.5em; }
&lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"jquery.min.js"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;"jquery.min.js"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that in the last example, while the Markdown specification considers it a complete
HTML block, it is not a valid HTML snippet.  The Markdown specification does not
specify any validation of the produced output, so beware of garbage-in, garbage-out.&lt;/p&gt;
&lt;p&gt;This HTML block type was pretty easy to figure out, hence it was easy to implement.
Pretty straight forward: Look for one of the start strings, capture everything until
we find one of the end strings.  Quick and painless.&lt;/p&gt;
&lt;h3 id="special-tags"&gt;Special Tags&lt;a class="headerlink" href="#special-tags" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Block types 2 to 5 are what I refer to as the special tags.  In order, the HTML
specification refers to these as the comment tag, the processing instruction tag,
the declaration tag, and the CDATA tag.  Each of these tags is authored exactly as
would be expected in a normal HTML document, and has it’s own distinct purpose.  In
each case, the start condition is a simple string, and the end condition is the
inversion of that string.&lt;/p&gt;
&lt;p&gt;While most of these tags have seldom used or esoteric purposes, the comment tag is used
frequently in HTML code, and is common in HTML documents.  Similar to block type 1
above, the following text is considered a complete HTML block:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;lt;!--&lt;/span&gt;
&lt;span class="c"&gt;    style type="text/css"&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;h1 { font-size: 140%; font-weight: bold; border-top: 1px solid gray; padding-top: 0.5em; }&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;as is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;!&lt;/span&gt;&lt;span class="c1"&gt;-- this is a comment --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Similar to the previous HTML block type, these HTML block types were also easy to
figure out and implement.  Just like before: look for one of the start strings, capture
everything until we find one of the end strings.  Just as quick and just as painless.&lt;/p&gt;
&lt;h3 id="everything-else-tags"&gt;“Everything Else” Tags&lt;a class="headerlink" href="#everything-else-tags" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With block types 1 to 5 out of the way, the work focused in on the remaining
block types 6 and 7.  These two block types are different than the other blocks, with
their most prominent difference being that their end condition is a simple blank line.
Another difference is that there is a long list of tag names that are eligible for block
type 6, while any other tag is relegated to block type 7.  This becomes important as the
start conditions of block type 6 are the string &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;lt;/&lt;/code&gt;, followed by the tag name,
and then followed by whitespace, the string &lt;code&gt;&amp;gt;&lt;/code&gt;, the string &lt;code&gt;/&amp;gt;&lt;/code&gt; or the end of the line.
In contrast, the start conditions for block type 7 are that the HTML must either be a
complete open tag or a complete close tag, followed by optional whitespace and the end
of the line.  As an additional requirement, a block type 7 HTML block cannot interrupt
a paragraph.&lt;/p&gt;
&lt;p&gt;To me, these rules are confusing to anyone authoring even a small piece of HTML in
Markdown, adding to the reasons for me to suggest to people not to use HTML in Markdown.
While this confusion is not evident in the examples for the block types 1 to 5,
consider this sample:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;canvas&lt;/span&gt;
    &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"my-canvas"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;pre&amp;gt;&lt;/span&gt;
**Hello**,

_world_.
&lt;span class="nt"&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/canvas&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and this sample:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;table&lt;/span&gt;
    &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;"column"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;pre&amp;gt;&lt;/span&gt;
**Hello**,

_world_.
&lt;span class="nt"&gt;&amp;lt;/pre&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Without looking at the information in the specification, how easy is it to tell what the
output of each sample is?  To be honest, I had to refer back to the
&lt;a href="https://github.github.com/gfm/#html-blocks"&gt;HTML block definitions&lt;/a&gt; in the GFM
specification twice when I was writing these samples and three times when I was
verifying the samples before publishing this article.  That doesn’t bode well, does it?&lt;/p&gt;
&lt;p&gt;For the first example, the &lt;code&gt;canvas&lt;/code&gt; tag name is not in the list for block type 6, and a
block type 7 evaluation fails as the tag is neither a complete start tag nor a complete
end tag.  As such, the &lt;code&gt;canvas&lt;/code&gt; start tag ends up being normal text, to be wrapped in a
paragraph.  The next tag, the &lt;code&gt;pre&lt;/code&gt; start tag, gets identified as a block type 1 start,
finishing at it’s own &lt;code&gt;pre&lt;/code&gt; end tag, with the remaining &lt;code&gt;canvas&lt;/code&gt; end tag going into it’s
own paragraph.  I know that wasn’t what I expected at first glance.&lt;/p&gt;
&lt;p&gt;The second example has different issues.  Because the &lt;code&gt;table&lt;/code&gt; tag name is in the block
type 6 list of allowable tag names, the start conditions only state that it needs to
start with the first part of a start tag or end tag, which the string &lt;code&gt;&amp;lt;table&lt;/code&gt;
satisfies.  However, as the end condition for block type 6 HTML blocks is a blank
line, the HTML block ends after &lt;code&gt;**Hello**,&lt;/code&gt; and before &lt;code&gt;_world_.&lt;/code&gt;.  At this point,
the text &lt;code&gt;_world_.&lt;/code&gt; is parsed as normal text, and the text &lt;code&gt;&amp;lt;/pre&amp;gt;&lt;/code&gt; is interpreted as
a complete end tag by the block type 7 rules, carrying a block type 7 HTML block to
the end of the sample.  When reading a similar example as part of
&lt;a href="https://github.github.com/gfm/#example-118"&gt;example 118&lt;/a&gt;, it did take several tries
to figure out what was going on.&lt;/p&gt;
&lt;p&gt;These block types provided a bit of complexity that was different than the previous
blocks.  As such, I hit a couple of road blocks that I had to work through.  It wasn’t
that the implementation was much more complicated than the previous HTML block types,
they weren’t.  It’s
almost the same process: find one of the start conditions, and capture everything
until a blank line.  Sure, the start conditions were a bit more meaty, but other than
that, it was relatively simple.  It was that they start conditions and end conditions
were different for these 2 HTML block types that made me look back at the use cases and
scenario tests with a couple of “huh”s until I that difference registered in my head.
And that list separating HTML block type 6 from 7… sheesh.&lt;/p&gt;
&lt;h2 id="my-recommendation"&gt;My Recommendation&lt;a class="headerlink" href="#my-recommendation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When it comes to HTML blocks, I implemented them as part of the parser because they
are part of the specification.  But because of the complexity in understanding
HTML blocks, I whole heartedly recommend avoiding using HTML blocks if at all possible.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I took my time with the implementation for HTML blocks due to the complexities stated
above.  For the most part, the code I implemented worked on the first or second try,
with few cases where it took more tries and debugging than that.  I believe the key
to the relatively easy implementation was breaking the groups and tasks down into
multiple, smaller groups and smaller tasks.  In retrospect, I believe this enabled me to
more readily get my mind around the task to accomplish, and not get overwhelmed by
the size of the problem.&lt;/p&gt;
&lt;p&gt;Implementing that thinking for the project, while not concrete, helped me see other
things for the project in a better perspective. Most of the things I initially thought
would be complex turned out to not be that complex.  The long list of tag names for
block type 6?  Strings in a list object. The end conditions?  Either looking for a
blank line or one of a set of strings in one of the following lines.  Getting the use
cases right in the scenario tests?  Really simple.  I still contend that authoring HTML
in Markdown is complex, but the implementation was pretty easy.&lt;/p&gt;
&lt;p&gt;Another boost to my confidence was tackling the HTML blocks and getting them out of
my “technical debt column”.  While I believe that I made the right decision to defer
the HTML blocks for the right reasons, it still felt good to get them dealt with.
Similar to my experience with translating the last 2-3 uses cases into scenario
tests, thinking about revisiting any technical debt also triggers similar expectations
of the reworking of existing code, if that revisiting is actually possible at all.
Taking something out of technical debt and being able to remove that uncertainty
definitely helped my confidence towards the completion of the parser for this project.&lt;/p&gt;
&lt;p&gt;All in all, I believe things are still headed in the right direction!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;During the implementation of the PyMarkdown parser, I have been using my PyScan script
to great benefit.  As such, I decided to take the time to polish it up a bit and
document it in
&lt;a href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/"&gt;this article&lt;/a&gt; on Software Quality.
While doing that, I took some time to refactor the PyMarkdown code to make it easier to
work with, preparing it for the inline processing that was to come next.  The
next article will go over the refactoring that I did, and how it helped the project.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:countScenarios"&gt;
&lt;p&gt;The totals are as follows: paragraphs (9), tabs (11), indented code blocks (15), atx headings (18), thematic breaks (19), block quotes (22), lists (25),setext headings (27), and fenced code blocks (29). &lt;a class="footnote-backref" href="#fnref:countScenarios" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Adding Block Quotes and Lists</title><link href="https://jackdewinter.github.io/2020/02/03/markdown-linter-adding-block-quotes-and-lists/" rel="alternate"></link><published>2020-02-03T00:00:00-08:00</published><updated>2020-02-03T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-02-03:/2020/02/03/markdown-linter-adding-block-quotes-and-lists/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having the leaf blocks mostly in place, as documented
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;in the last article&lt;/a&gt;, the next items
on the implementation list were the list blocks and the block
quote blocks.  These Markdown blocks, referred to as Container Blocks in the
&lt;a href="https://github.github.com/gfm/#container-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the more complicated blocks …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having the leaf blocks mostly in place, as documented
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;in the last article&lt;/a&gt;, the next items
on the implementation list were the list blocks and the block
quote blocks.  These Markdown blocks, referred to as Container Blocks in the
&lt;a href="https://github.github.com/gfm/#container-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the more complicated blocks to deal with, as they are capable of containing other
blocks.  As there are
&lt;a href="https://github.github.com/gfm/#phase-1-block-structure"&gt;specific suggestions&lt;/a&gt;
on how to parse these blocks, my confidence took a hit when I started looking at this
section. My viewpoint: if the specification writers thought it was difficult to
implement that they wrote suggestions on how to handle it, it must not be as easy as
the leaf blocks!&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits that occurred between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/49407f86564479934ee92fb59597ba830a46fde8"&gt;08 December 2019&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/00bbef09eba4fd5d7c663ca6e991b48e5b96c60e"&gt;15 December 2019&lt;/a&gt;.  This work includes creating the
scenario tests for all of the Container Blocks as documented in the GFM specification
and implementing the parsing to pass most those tests except for the nested cases.&lt;/p&gt;
&lt;h2 id="container-blocks-leaf-blocks-and-interactions-oh-my"&gt;Container Blocks, Leaf Blocks, and Interactions (Oh My!)&lt;a class="headerlink" href="#container-blocks-leaf-blocks-and-interactions-oh-my" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before container blocks, parsing was easy.  A block starts, and when the parser
encounters the termination conditions, it ends.  There are a few rules about when
blocks can start and end, such as
&lt;a href="https://github.github.com/gfm/#example-83"&gt;“An indented code block cannot interrupt a paragraph.”&lt;/a&gt;,
but for the most part, there is little interaction between the leaf blocks.  The leaf
blocks are clean and tidy.  Not so much with container blocks.&lt;/p&gt;
&lt;p&gt;Container blocks, by their very definition, contain other blocks, namely leaf blocks and
container blocks.  While this makes certain visual elements easier, this also means
specific rules about what interactions are allowed between the blocks.  On top of that,
as container blocks can contain other container blocks, testing is required to ensure
that an arbitrary number of nested containers is properly supported.&lt;/p&gt;
&lt;p&gt;A great example of nesting container blocks is the Markdown implementation of sublists.
A list containing a list containing a list is simple in Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;first&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;second&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;third&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That example is not a single list, but 3 separate lists.  The &lt;code&gt;first level&lt;/code&gt; list is the
first level list, containing the list &lt;code&gt;second level&lt;/code&gt;, which contains the list
&lt;code&gt;third level&lt;/code&gt;.  And while sublists are a simple case of container blocks, more complex
cases are possible, such as this one:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;first&lt;/span&gt; &lt;span class="k"&gt;level&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;```&lt;/span&gt;&lt;span class="nb"&gt;text&lt;/span&gt;
    &lt;span class="n"&gt;my&lt;/span&gt; &lt;span class="nb"&gt;text&lt;/span&gt;
    &lt;span class="o"&gt;```&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This list is similar to the first list, except it contains a fenced code block as the
contained block.  Both of these examples are just a few of the possibilities of how
container blocks can contain other blocks.  Looking through the specification, I
quickly lost count of the number of combinations possible.&lt;/p&gt;
&lt;h2 id="enter-lazy-continuations"&gt;Enter Lazy Continuations&lt;a class="headerlink" href="#enter-lazy-continuations" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If the interactions between container blocks and the blocks they contain wasn’t a fun
enough exercise in mental agility, enter lazy continuations.  From the GitHub Flavored
Markdown (GFM) Specification’s
&lt;a href="https://github.github.com/gfm/#block-quotes"&gt;block quotes section&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;. If a string of lines Ls constitute a block quote with contents Bs, then the result of deleting the initial block quote marker from one or more lines in which the next non-whitespace character after the block quote marker is paragraph continuation text is a block quote with Bs as its content.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;and from the &lt;a href="https://github.github.com/gfm/#list-items"&gt;list items section&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Laziness&lt;/strong&gt;. If a string of lines Ls constitute a list item with contents Bs, then the result of deleting some or all of the indentation from one or more lines in which the next non-whitespace character after the indentation is paragraph continuation text is a list item with the same contents and attributes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Basically, what they are both saying is that if a paragraph has been started with block
quotes or within a list AND if a line is clearly a continuation of a paragraph, then it
is valid to remove some or all of the container block markers.  For a more concrete
example, &lt;a href="https://github.github.com/gfm/#example-211"&gt;example 211&lt;/a&gt; has the following
Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="n"&gt;baz&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;which is parsed the same as if the following Markdown was written as:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;bar&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;baz&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After reading those sections and letting them sink in, my confidence took a dip.  This
was not going to be an easy concept to get right.  But the sooner I dealt with those
scenarios, the sooner I could try and implement them the right way.  So I went forward
with the implementation phase of the container blocks.&lt;/p&gt;
&lt;h2 id="getting-down-to-work-the-easy-scenarios"&gt;Getting Down to Work - The Easy Scenarios&lt;a class="headerlink" href="#getting-down-to-work-the-easy-scenarios" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I often recommend to friends and
co-workers that taking a break and doing something unconnected to the “chore” helps
your mind get things together.  As such, before getting started on this work, I
decided to walk our dog for a while and let some of these concepts mull around in my
head. I am not sure if it was the exercise or the change in scenery, but it helped to
clear the cobwebs from my head and helped me to see things about the project more
clearly.&lt;/p&gt;
&lt;p&gt;The big thing that it accomplished was to help me cleanly separate out the easy tasks
from the more difficult tasks. The easy tasks? Simple block quotes and simple lists,
including sub-lists.  The difficult tasks?  Lazy continuations and mixed container
types.  I remember feeling that taking this time helped my confidence on the project,
as I was taking simple steps to understand where the difficulties were most likely to
show up.  This process also allowed me to think about those hard issues a bit while
implementing the easier features.  While I wasn’t devoting any serious time to the
more complicated features, it was good to just have my mind aware of which sections of
code that I was going to need to keep flexible going forward.&lt;/p&gt;
&lt;p&gt;Keeping this in mind, I started with block quotes, adding the block quote test cases to
&lt;code&gt;test_markdown_block_quotes.py&lt;/code&gt;, disabling any tests that I figured were not in the
easy category.  I then proceeded to implement the code, in the same way as detailed in
the
&lt;a href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/"&gt;prior article on leaf blocks&lt;/a&gt;.
Implementing the easy scenario tests for the block quotes was a decent sized task,
mostly completed during two days on a weekend where I had some time.  This also included
fixing scenario tests in 6 other test files that has block quotes in their scenarios.&lt;/p&gt;
&lt;p&gt;Working on the basic list items over the next week, by the middle of the next weekend
they were completed, in a similar fashion to how the block quotes were completed: new
scenario tests were added, the easy ones were then tested, enabled, and verified for
completion, and the more difficult ones were disabled.  Similar to the block quotes,
getting these right took roughly a week, and that work also had impact on scenario
tests other than the ones I added.&lt;/p&gt;
&lt;p&gt;During this process, I believed I found the parsing of lists more difficult.  Thinking
about the
implementation in hindsight, I believe it was mostly due to their parsing requirements.
The fact is that block quotes have a single character &lt;code&gt;&amp;gt;&lt;/code&gt; to consider for parsing,
while the lists can be unordered and start with the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt; character or the
lists can be ordered and start with a number and the &lt;code&gt;)&lt;/code&gt; or &lt;code&gt;.&lt;/code&gt; or character.  In
addition, for ordered lists, there is also the parsing of the start number and how to
interpret it.  Looking at the two blocks that way, block quote blocks seem a lot easier
to me.&lt;/p&gt;
&lt;p&gt;However, now that I have had a bit of time since that code was written, I believe that
those two features were more closer in difficulty that I initially thought.  Having
implemented both block quotes and lists, I think that they both had something that was
difficult that needed overcoming.  Since I have done a lot of parsers in my past, the
number of variations in parsing the lists were immediately noticeable to me, while the
block quotes were pretty easy to parse.  Balancing that out, once parsed the lists were
easy to coordinate, while the block quotes took a bit more finessing to get right.
In the end, I believe it was a pretty event effort to get both done properly.&lt;/p&gt;
&lt;p&gt;At least until nested mixed container blocks.&lt;/p&gt;
&lt;h2 id="nested-and-mixed-containers"&gt;Nested and Mixed Containers&lt;a class="headerlink" href="#nested-and-mixed-containers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Nested container blocks, specifically mixed nested container blocks, is where things
got messy.  To be 100% honest, I am pretty sure I didn’t get everything right with the
implementation, and I already have plans to rewrite this logic. More on that later.&lt;/p&gt;
&lt;p&gt;I started implementing these features knowing that they probably made up the remaining
10% of the scenarios. I also figured that to handle these specific scenarios properly
would require as much time and effort as the prior 90% of the scenarios.  This was not
really a surprise, as in software development getting a project to the 70-90% finished
mark is almost always the easy part.&lt;/p&gt;
&lt;p&gt;Over the next week’s work, I reset my fork of the code back to it’s initial state 3 or 4
times.  In each case, I just got to a point where I either hit a block in going forward,
I wasn’t happy and confident about the solution, or both.  In one of those cases, the
code was passing the scenario tests that I was trying to enable, but it just didn’t feel
like I could extend it to the next scenario.  I needed to be honest with myself and
make an honest determination of how good the code I just wrote was.&lt;/p&gt;
&lt;p&gt;In the end, I completed some of the sublists and nested block quotes, requiring only 4
scenario tests to be disabled or skipped.  The ones that were disabled were the 10% of
the 10%, the cases where there were 3 or more levels of block quotes and lists mixed
together. I was not really happy with it, but after a week, I knew I needed to move on
with the project.  Grudgingly, I acknowledged that I would need to rewrite this later.&lt;/p&gt;
&lt;h2 id="why-rewrite-already"&gt;Why Rewrite Already?&lt;a class="headerlink" href="#why-rewrite-already" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I am very confident that I coded the easy level cases correctly, as I have solid
scenario tests, and a decent volume of them, to test the various use cases.  For the
medium difficulty cases, such as a container within a container, I have a decent amount
of confidence that the scenario tests are capturing most of the permutations.  It is
the more complicated cases that I really am not confident about.  And when I say I am
not confident, it is not that I am not sure if it is handling the test properly: that
is a binary thing.  The test is passing, or the test is failing, and thus disabled.  I
m not confident that all of those tests work for all use cases like that the scenario
tests represent.&lt;/p&gt;
&lt;p&gt;Part of any project is learning what works and what doesn’t work.  As I started
looking at implementing
&lt;a href="https://github.github.com/gfm/#example-237"&gt;example 237&lt;/a&gt;, I read the
following paragraph located right before the example:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It is tempting to think of this in terms of columns: the continuation blocks must be indented at least to the column of the first non-whitespace character after the list marker. However, that is not quite right. The spaces after the list marker determine how much relative indentation is needed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It was then that I was pretty sure I had coded the container blocks in terms of columns
instead of spaces.  Add that to the list of rewrites needed.&lt;/p&gt;
&lt;p&gt;The other category where my confidence is not high is with multiple levels of mixed
container blocks.  Once I complete the rewrite above, I can properly evaluate how well
I can nest the containers, but at the moment, that is not high.  At that point,
example 237 will be a good scenario test to determine how well I have those set up.
Having taken some time to really evaluate the code and the scenario tests, I just have
a suspicion that there is at least 1-2 bugs in the code that I wrote.  For now, that is
on my list of possible rewrites, with a medium to high probability of being needed.&lt;/p&gt;
&lt;p&gt;The saving grace for both of these scenarios that I believe need rewrites?  Their
frequency.  The scenarios for blocks, leaf blocks and container blocks, comprise
about half of the specification, ending with
&lt;a href="https://github.github.com/gfm/#example-306"&gt;example 306&lt;/a&gt;.  According to my test failure
report, only 4 of the list block tests had to be marked as skipped, hence they were not
passing.  At approximately 1.3% of the total scenarios, it is not a big impact.  In
writing this block, I have used lists frequently, block quotes sporadically, and block
quotes with lists even less.  I am not sure if my writing is representative of
everyone’s writing, but at least at the moment, &lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;All of the leaf blocks were finished in about a week.  The easy and medium cases for
the container blocks were finished about a week.  The hard cases for the container
blocks… not finished after a week, but close.&lt;/p&gt;
&lt;p&gt;Was I disappointed?  Sure.  But in comparison to other issues I have had with projects,
this was not even near the top 20 in terms of disappointment.  To be honest, in terms
of how projects have gone for me over the years, this has been a decent project to
work on.  Every project has it’s issues, and this was just the set of issues that
happened to occur on this project.&lt;/p&gt;
&lt;p&gt;I know it may sound a bit silly, but me and my immediate family have a saying we like
to repeat when things get tough: “Stuff&lt;sup id="fnref:notStuff"&gt;&lt;a class="footnote-ref" href="#fn:notStuff"&gt;1&lt;/a&gt;&lt;/sup&gt; happens, pick yourself up, dust
yourself off, and figure out what to do next.”  The disabled tests happened, so I took
some time to find my focus, and came up with a plan to deal with it.  Not a great
plan, but it meant I could go forward with the remaining scenarios and circle back
once I accumulated more experience with the parser.&lt;/p&gt;
&lt;p&gt;Sure there already was some
&lt;a href="https://en.wikipedia.org/wiki/Technical_debt"&gt;technical debt&lt;/a&gt;
for this project, but other than that, I believe it is going well.  At this point it
was just before Christmas, and I had a Markdown parser that was coming along pretty
well.  My confidence in the implemented leaf blocks was high, as was my confidence in
the easy 90% of the container block implementation.  The more difficult 10% of the
container blocks was still undecided, but I had a plan to deal with it going forward.
While not a sterling situation, it was definitely a good position for me to be in.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before I took some time to improve my PyScan tool, I worked on adding HTML block
support for the PyMarkdown project.  As HTML in Markdown has some funny logic associated
with it, the next article will be devoted entirely to the HTML blocks.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:notStuff"&gt;
&lt;p&gt;When my kids were younger, I did indeed use the word “stuff”.  As my kids got older, we changed that word to another one that also starts with “s”.  The actual word that we now use should be easy to figure out! &lt;a class="footnote-backref" href="#fnref:notStuff" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Parsing Normal Markdown Blocks</title><link href="https://jackdewinter.github.io/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/" rel="alternate"></link><published>2020-01-27T00:00:00-08:00</published><updated>2020-01-27T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-01-27:/2020/01/27/markdown-linter-parsing-normal-markdown-blocks/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the &lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;project requirements&lt;/a&gt;,
the &lt;a href="https://jackdewinter.github.io/2019/12/16/markdown-linter-setting-up-parser-tests/"&gt;test framework&lt;/a&gt;,
and the &lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/"&gt;test strategy&lt;/a&gt; in place,
it was time to start working on the most frequently used and easy-to-parse Markdown
items.  These Markdown blocks, referred to as Leaf Blocks in the
&lt;a href="https://github.github.com/gfm/#leaf-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the root of many Markdown …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;With the &lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;project requirements&lt;/a&gt;,
the &lt;a href="https://jackdewinter.github.io/2019/12/16/markdown-linter-setting-up-parser-tests/"&gt;test framework&lt;/a&gt;,
and the &lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/"&gt;test strategy&lt;/a&gt; in place,
it was time to start working on the most frequently used and easy-to-parse Markdown
items.  These Markdown blocks, referred to as Leaf Blocks in the
&lt;a href="https://github.github.com/gfm/#leaf-blocks"&gt;GitHub Flavored Markdown (GFM) Specification&lt;/a&gt;,
are the root of many Markdown documents and have the virtue of being easy to parse.
With small exceptions, each of the Leaf Blocks is self contained.  For the most part,
those exceptions arise in how the Leaf Blocks interact with each other.
In all cases, this interaction is small and does not require complicated logic to
understand.&lt;/p&gt;
&lt;p&gt;The full record of the work detailed in this article is documented in the
project’s GitHub repository in the commits that occurred between
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/4ad7ebd46d7651d20a8b470b4d287e49cebfff75"&gt;30 November 2019&lt;/a&gt;
and
&lt;a href="https://github.com/jackdewinter/pymarkdown/commit/aee7a3def2dffc8531814a8b87365068d07730dc"&gt;05 December 2019&lt;/a&gt;.  This work includes creating the
scenario tests for all of the Leaf Blocks as documented in the GFM specification
and implementing the parsing to pass all of those tests except for the Link Reference
Definitions, HTML Blocks, and Tables.&lt;/p&gt;
&lt;p&gt;While the documentation of what needed to be done (GFM Specification) and what was done
(GitHub commits) is pretty straightforward, the “hows” and “whys” of what I implemented
is worth talking about.  The process that I followed for the implementation of the Leaf
Blocks did not uncover any development issues during implementation.  However, without
giving too much away, the same process applied to other block types (to be talked about
in future articles) did uncover issues that were not so easy to resolve.  As there were
complications that arose with those feature implementations, I wanted to provide a
consistent documentation of the process from the beginning, to provide a complete
picture of how things progressed.   I firmly believe that it is always good to show the
complete story of what happened, and not only one side of the story. So let’s go!&lt;/p&gt;
&lt;h2 id="moving-forward-with-implementation"&gt;Moving Forward With Implementation&lt;a class="headerlink" href="#moving-forward-with-implementation" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Even though the first commit for processing Markdown elements is on 30 November 2019, my
work on implementing them started on 25 November 2019.  Based on the test framework and
strategy documented in previous articles, the first thing to do was to write the
scenario tests cases, even if most of those tests were initially disabled or skipped.
This was easily done by annotating each test function with &lt;code&gt;@pytest.mark.skip&lt;/code&gt;. Once
I implemented the code to satisfy a given test, I removed that skip annotation for
that specific test.  While I would made modifications on how I disabled tests later on,
this was a good point for me to start off at.&lt;/p&gt;
&lt;h2 id="what-was-the-workflow"&gt;What Was the Workflow?&lt;a class="headerlink" href="#what-was-the-workflow" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From the outset, the basic implementation workflow was as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;figure out the next section to work on&lt;/li&gt;
&lt;li&gt;figure out the next section-feature to implement&lt;/li&gt;
&lt;li&gt;enable the relevant tests for that section-feature&lt;/li&gt;
&lt;li&gt;add or change the code in &lt;code&gt;tokenized_markdown.py&lt;/code&gt; to implement that feature&lt;/li&gt;
&lt;li&gt;execute all enabled tests, with special attention to the feature added in item 4.&lt;/li&gt;
&lt;li&gt;if there were any test errors; debug, fix and go back to &lt;code&gt;item 4.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;stage the changes in the project before&lt;/li&gt;
&lt;li&gt;if there are more features in the current section, go back to &lt;code&gt;item 2.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;verify each test case’s input and output against the specification&lt;/li&gt;
&lt;li&gt;if any verification errors are found; debug, fix and go back to &lt;code&gt;item 4.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;if there are any leaf block sections left to work on, go back to &lt;code&gt;item 1.&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;It wasn’t really glamourous, but it worked well.  Looking closely at the list, it is
easy for me to see why… I took an agile approach without really being aware of it.
According to the Wikipedia article on
&lt;a href="https://en.wikipedia.org/wiki/Agile_software_development#Agile_software_development_practices"&gt;Agile Software Development&lt;/a&gt;,
there are a number of good practices that I was following.  Because I was doing testing
as I went, the is a good argument to be made that I was practicing
&lt;a href="https://en.wikipedia.org/wiki/Agile_testing"&gt;Agile Testing&lt;/a&gt; and
&lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;Test Driven Development&lt;/a&gt;.
As the tests are also the acceptance criteria for this stage of the project,
&lt;a href="https://en.wikipedia.org/wiki/Acceptance_test-driven_development"&gt;Acceptance Test Driven Development&lt;/a&gt;
could also be tacked on to those two Agile practices.  Finally, as the workflow is
iterative by it’s very nature, the workflow also qualifies as
&lt;a href="https://en.wikipedia.org/wiki/Iterative_and_incremental_development"&gt;Iterative and Incremental Development&lt;/a&gt;.
All in all, I see a number of solid agile patterns within the workflow.&lt;/p&gt;
&lt;p&gt;Agile aspirations aside, the real test of this workflow is that it works for me and
works well.  I was able to stick to the process pretty easily. It very nicely
compartmentalized my work into nice iterations that were easy for me to keep in my
head. It was also simple enough that if I needed to refocus myself, I just had to
figure out where I was in the workflow and where I was in the specification, and I
was able to get back to work!  In addition, I feel that if I had performed this
development as part of a team, the frequent commits and complete with enabled tests
would enable me to share my progress with the rest of the team, and solicit their
feedback in a quick and iterative manner.&lt;/p&gt;
&lt;p&gt;More importantly, at no point in the development practice did I feel that I bit off more
than I could handle.  Of course there were times where I was wondering how long it was
going to take me and how I would handle some features… I am only human!  But the agile
nature of how the workflow is structured kept me grounded and focused on the feature
that was in front of me.  I just reminded myself to keep that focus, and feature by
feature, the foundations of the parser came together.&lt;/p&gt;
&lt;p&gt;In the end, this workflow wasn’t about being agile or taking easy to implement steps.
It is about finding something that works well for the team… namely me.&lt;/p&gt;
&lt;h2 id="how-did-things-progress"&gt;How Did Things Progress?&lt;a class="headerlink" href="#how-did-things-progress" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The order in which things are tackled is important.  Doing the big
stuff at the start of the project sometimes pays off, but it can often be demoralizing.
Doing the small stuff first can lay some great foundations, but miss the larger target
due to the smaller focus.  To accomplish this for the PyMarkdown project, I broke
this part of the project down into 4 groups of Markdown elements.  Each group of
Markdown elements that were handled added new information to the stream of tokens
that were being generated by the parser, allowing for future examination.  It was
very important to me to ensure that the token stream was kept working and moving
forwards at all times.&lt;/p&gt;
&lt;h3 id="group-1-foundational-elements"&gt;Group 1: Foundational Elements&lt;a class="headerlink" href="#group-1-foundational-elements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The first group that I worked on were the rudimentary elements of blank lines,
paragraphs, and thematic breaks.  This was a good first
group to work on, as these were all common Markdown elements that people use, and are
foundational to the rest of the work.  As such, they were good confidence boosters for
the tribulations that I expected that would occur later with the more complicated
elements.&lt;/p&gt;
&lt;p&gt;The only real issue that I had with this first group was due to my lack of confidence
about the Markdown specification itself.  From my days on the
&lt;a href="https://www.ietf.org/"&gt;Internet Engineering Task Force&lt;/a&gt;,
I am used to clear grammar specifications written in
&lt;a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form"&gt;Backus-Naur form&lt;/a&gt;.
However, this specification has no such representation and is written mainly as a
series of use cases and text to describe each use case.  It took me a while to see that
what I perceived initially as a downfall was actually a bonus.  Instead of having to
search for examples or to make them up myself, they were already provided.  Once I got
used to that concept, my confidence increased and I started to implement each test more
quickly than the last one.&lt;/p&gt;
&lt;p&gt;While it didn’t seem like much at the time, at this point the parser was capable of handling the following Markdown:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;captured&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="o"&gt;***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 id="group-1-sidebar-tabs"&gt;Group 1 Sidebar: Tabs&lt;a class="headerlink" href="#group-1-sidebar-tabs" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;I started to tackle the GFM specification decision that any tab character is
considered to be replaced with exactly 4 space characters.  For the most part, this had
little bearing on the foundational elements, but the subject of
&lt;a href="https://www.bing.com/search?q=tabs+vs+spaces"&gt;tabs versus spaces&lt;/a&gt; has ignited
&lt;a href="https://www.reddit.com/r/programming/comments/3xbyh6/the_software_development_holy_wars_part_i_the/"&gt;programming holy wars&lt;/a&gt;
that last to this day.  I thought it was useful and prudent to deal with it
and get it out of the way early.&lt;/p&gt;
&lt;p&gt;Smartly, Markdown avoids these arguments with a strong statement that 1 tab character
equals 4 space characters, and a decent argument to reinforce that the decision is the
right one. With the exception of the indented code block, every Markdown element is
only recognized if it starts with less than 4 spaces.  An indented code block line is
only recognized if it starts with 4 spaces.  Therefore, a shortcut for any indented
code block is to start the line with 1 tab character, due to it’s 1:4 mapping.  To be
honest, I feel this is brilliant in it’s simplicity.&lt;/p&gt;
&lt;h3 id="group-2-headers"&gt;Group 2: Headers&lt;a class="headerlink" href="#group-2-headers" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The next group that I tackled were the header markers, referred to in the specification
as the &lt;code&gt;setext&lt;/code&gt; and &lt;code&gt;atx&lt;/code&gt; elements.  Weird names though they are, they are the up to 6
&lt;code&gt;#&lt;/code&gt; characters at the start of the line, or the &lt;code&gt;-&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt; characters underlining
text from a previous paragraph.  While the &lt;code&gt;atx&lt;/code&gt; elements (the &lt;code&gt;#&lt;/code&gt; characters) was
pretty straight forward, the ‘underlining’ aspect of the &lt;code&gt;setext&lt;/code&gt; element made it
interesting.  As that element essentially makes the last paragraph a heading, I had to
search backwards in the list of generated tokens for the first time.&lt;/p&gt;
&lt;p&gt;It was also at this point that I decided to perform some refactoring to better
handle string processing.  The simple truth about any parser is that it requires
gratuitous amounts of “string fiddling” &lt;sup id="fnref:stringFiddle"&gt;&lt;a class="footnote-ref" href="#fn:stringFiddle"&gt;1&lt;/a&gt;&lt;/sup&gt;.  Most efficient parsers work
aggressively to parse their documents in a way that minimizes the number of actual
strings created while parsing.  A good example of efficient “string fiddling” can be
seen in the following example of parsing the sentence &lt;code&gt;I have a black dog&lt;/code&gt;.  When
parsing out the word &lt;code&gt;black&lt;/code&gt;, the most optimal parsers will find the index of the &lt;code&gt;b&lt;/code&gt;
in &lt;code&gt;black&lt;/code&gt;, then find the space character after the &lt;code&gt;k&lt;/code&gt;, using the language’s
&lt;code&gt;substring&lt;/code&gt; function  and those two indexes to create a single string with &lt;code&gt;black&lt;/code&gt; in
it.  Less optimal parsers will find the &lt;code&gt;b&lt;/code&gt;
append it to the end of an empty string (creating a new string with &lt;code&gt;b&lt;/code&gt;), then find
the &lt;code&gt;l&lt;/code&gt; character and appended it, etc.  This can easily cause 6 strings to be created
during the parsing of the word &lt;code&gt;black&lt;/code&gt;, when only 1 is needed.  As some of the
Markdown documents that the parser will handle are large, it is important to remember
optimizations like this as features are added.&lt;/p&gt;
&lt;p&gt;Keeping this in mind, I started looking for “string fiddling” patterns that looked ripe
for refactoring.  The most obvious one was the
&lt;code&gt;determine_whitespace_length&lt;/code&gt; function that took care of any tabs in the input data.
While I would rip this out later, opting instead to do a simple search-and-replace for
tabs at the start of parsing, the &lt;code&gt;determine_whitespace_length&lt;/code&gt; function kept things
manageable for tabs characters.  There were also the &lt;code&gt;extract_whitespace*&lt;/code&gt; functions for
extracting whitespace and the &lt;code&gt;collect_while_character&lt;/code&gt; function for collecting data
for a string while the input was a given character.  Taking a couple of peeks ahead in
the specification, it was easy to see that moving the code into those functions was going to pay off.&lt;/p&gt;
&lt;p&gt;When it comes down to it, there were no real issues that I experienced with the
headers.  My confidence was still building from the foundational group above, but there
was nothing weird or challenging that I did not handle with a bit of serious thought
and planning.&lt;/p&gt;
&lt;p&gt;At this point, the parser was capable of handling the following Markdown elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Markdown&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;captured&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="n"&gt;But&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;
&lt;span class="c1"&gt;-------------------&lt;/span&gt;

&lt;span class="o"&gt;***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="group-3-indented-and-fenced-code-blocks"&gt;Group 3: Indented and Fenced Code Blocks&lt;a class="headerlink" href="#group-3-indented-and-fenced-code-blocks" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Marching right along, indented and fenced code blocks were next on the list.  Both are
used to denote sections of text that are to be represented literally, but one is easier
and one is more flexible.  The indented code blocks require 4 space characters (or a
tab character) at the start of the line to denote the block, and text is presented
plainly.  However, the fenced code blocks start and end with an equal number of &lt;code&gt;`&lt;/code&gt;
or &lt;code&gt;~&lt;/code&gt; characters and include provisions for naming the type of text used within the
code block.  This naming allows processors to specify a given style to apply to the
code block, allowing processors and style sheets to ‘colorize’ the text according to
the the specified type name.&lt;/p&gt;
&lt;p&gt;This grouping was pretty easy to process, adding the &lt;code&gt;extract_until_whitespace&lt;/code&gt; function
to the growing list of helper functions.  The interesting part to the code blocks was
that I needed to add extra processing of normal text to handle the text within the code
blocks.  Prior to these code blocks, any text that did not fall into one of the other
categories was simply wrapped in a paragraph.  Both of these blocks have specific end
conditions, and until those end conditions are met, the collection continues.  This
meant adding extra code at the start of line parsing to determine if it was within one
of the code blocks.  If the end condition was met, then the end block token was emitted,
and if not, a text block would be emitted without further parsing.&lt;/p&gt;
&lt;p&gt;It was at this point that I started seeing the intertwining nature of some of the use
cases.  An indented code block cannot interrupt a paragraph, but a fenced code block
can.  So when looking for the indented code block, I had to explicitly disallow one
from starting if the block currently being process was a paragraph.  While this was
only a small case, it became very obvious to me from a quick scan over the specification
that this type of pattern was going to repeat more than once.  As such, I started
moving the start and stop logic into their own functions, whether they required it or
not.  This improved the readability, and enabled me to get a better view on what was
being handled and where.&lt;/p&gt;
&lt;p&gt;At this point, the parser was capable of handling the following Markdown elements:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#&lt;/span&gt; &lt;span class="n"&gt;My&lt;/span&gt; &lt;span class="n"&gt;Markdown&lt;/span&gt;

&lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;captured&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;paragraph&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;

&lt;span class="o"&gt;```&lt;/span&gt;&lt;span class="n"&gt;Python&lt;/span&gt;
    &lt;span class="n"&gt;rt&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="ss"&gt;"1:"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;```&lt;/span&gt;

&lt;span class="n"&gt;But&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;header&lt;/span&gt;
&lt;span class="c1"&gt;-------------------&lt;/span&gt;

    &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;block&lt;/span&gt;

&lt;span class="o"&gt;***&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Please note that the fenced code block specifies &lt;code&gt;python&lt;/code&gt; as it’s type, allowing the
colorization of the text with the assumption that the code block is Python code.&lt;/p&gt;
&lt;h3 id="group-4-stopping-at-a-good-place"&gt;Group 4: Stopping At a Good Place&lt;a class="headerlink" href="#group-4-stopping-at-a-good-place" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Sometimes it makes sense to march forward without much attention to the surroundings,
and sometimes it makes sense to stop at a good place along the way.  In taking a quick
look at HTML blocks, I figured they were going to be tricky, and I had the same
determination with the table element.  Taking a look at the link reference definitions,
I noticed that they required inline expansion of text within the blocks, something that
I wasn’t even remotely close to yet.  These three leaf blocks were in the final group:
the To Be Done Later group.&lt;/p&gt;
&lt;p&gt;To ensure that I had a good place to come back to when I was ready for the each of these
blocks, I made sure to go through and implement, verify, and then disable each
test for every leaf block.&lt;/p&gt;
&lt;p&gt;Depending on the leaf block, I handled the disabling of the tests differently. To
properly deal with the link reference definitions, I needed the inline processing
capabilities that I knew were many weeks away.  As such, I kept those tests disabled
in the previous documented way of using the &lt;code&gt;@pytest.mark.skip&lt;/code&gt; annotation.  This was
a big shout out to myself that these were going to need to be completed after almost
everything else.&lt;/p&gt;
&lt;p&gt;In the case of any other of the leaf node tests, I captured the
current tokens emitted for that case and placed them in the corresponding test.  While
it might seem weird, my belief was that by testing each test case this way, I would
increase overall coverage and possibly hit edge cases not currently documented in an
use case.  It also meant that once I started implementing the HTML blocks and table
blocks, those tests would just start failing in predictable fashion.&lt;/p&gt;
&lt;h2 id="what-was-my-experience-so-far"&gt;What Was My Experience So Far?&lt;a class="headerlink" href="#what-was-my-experience-so-far" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It is always easier to look back and see what worked and what did not work, than to
observe it at the time.  With only a few issues, I personally felt like I dodged a
lot of pain due to the specification and planning.  While BNF grammars are easy to
implement, the general rule is to “be strict in what you generate and lenient in what
you accept”.  As such, coming up with “valid” parse cases is a task that takes a long
time to complete.  By having the acceptable test cases as part of the core
specification, the time that I would normally spend in the development and testing phase
was greatly reduced.  True, it took me a while to get used to it, but when I did, it
just worked and worked well.&lt;/p&gt;
&lt;p&gt;One of the practices that I engaged in during the development of the parser is to
liberally spread around &lt;code&gt;print&lt;/code&gt; statements as I went.  As I was adding these statements,
my dominant thought was to collect enough information to determine which pieces of
information were the most relevant for log messages to be added later.  However,
as I proceeded, that information also had the additional benefits of being immensely
helpful to debug any parsing issues, and indispensable in the verification of the code
itself.  While I know I need to remove those statements or convert them before the
project is completed, their presence is indeed beneficial.&lt;/p&gt;
&lt;p&gt;All in all, I think I had a great start to an interesting project and learned a bit
in the process… and learning is always good!&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Next up on the list is adding block quote and list support to the parser.  Stay tuned!&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:stringFiddle"&gt;
&lt;p&gt;I remember this term being used all the way back to my university days.  The closest I have been able to come to a definition is the Oxford dictionary’s definition: touch or fidget with something in a restless or nervous way.  Perhaps this is alluding to amount of work to get most string operations “just right”? &lt;a class="footnote-backref" href="#fnref:stringFiddle" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Clarity Through The Summarizing of Test Measurements</title><link href="https://jackdewinter.github.io/2020/01/20/clarity-through-the-summarizing-of-test-measurements/" rel="alternate"></link><published>2020-01-20T00:00:00-08:00</published><updated>2020-01-20T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-01-20:/2020/01/20/clarity-through-the-summarizing-of-test-measurements/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As part of the process of
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;creating a Markdown Linter&lt;/a&gt;
to use with my personal website, I firmly believe that it is imperative that I have
solid testing on the linter and the tools necessary to test the linter.  In previous
articles, I talked about the framework I use …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As part of the process of
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;creating a Markdown Linter&lt;/a&gt;
to use with my personal website, I firmly believe that it is imperative that I have
solid testing on the linter and the tools necessary to test the linter.  In previous
articles, I talked about the framework I use to
&lt;a href="https://jackdewinter.github.io/2020/01/06/scenario-testing-python-scripts/"&gt;scenario test Python scripts&lt;/a&gt; and
how my current PyTest setup
&lt;a href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/"&gt;produces useful test reports&lt;/a&gt;,
both human-readable and machine-readable.  These two things allow me to properly
test my Python scripts, to collect information on the tests used to verify those
scripts, and to determine how well the collection of tests covers those scripts.&lt;/p&gt;
&lt;p&gt;While the human-readable reports are very useful for digging into issues, I often find
that I need a simple and concise “this is where you are now” summary that gives me the
most pertinent information from those reports.  Enter the next tool in my toolbox, a
Python script that summarizes information from the machine-readable reports,
unimaginatively called &lt;code&gt;PyScan&lt;/code&gt;.  While it is simple tool, I constantly use this tool
when writing new Python scripts and their tests to ensure the development is going in
the direction that I want to.  This article describes how I use the tool and how it
provides a benefit to my development process.&lt;/p&gt;
&lt;h2 id="why-not-discuss-the-script-itself"&gt;Why Not Discuss The Script Itself?&lt;a class="headerlink" href="#why-not-discuss-the-script-itself" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When coming up with the idea for this article, I had two beneficial paths
available: focus on the code behind the PyScan tool or focus on the usage of the PyScan
tool.  Both paths have merit and benefit,
and both paths easily provide enough substance for a full article.  After a lot of
thought, I decided to focus on the usage of this tool instead of the code itself.  I
made this decision primarily due to my heavy use of the PyScan tool and it’s
significant benefit to my development process.&lt;/p&gt;
&lt;p&gt;I rely on the PyScan to give me an accurate summary of the tests used to verify any
changes along with the impact on code coverage for each of those changes.  While I
can develop without PyScan, I find that using PyScan immediately increases my
confidence in each change I make.  When I make a given type of change to either the
source code or the test code, I expect a related side-effect to appear in the test
results report and the test coverage report.  By having PyScan produce summaries of the
test results and test coverage, each side-effect is more visible, therefore
adding validation that the changes made are the right changes.&lt;/p&gt;
&lt;p&gt;In the end, the choice became an easy one: focus on the choice with the most positive
impact.  I felt that documenting how I use this tool satisfied that requirement with
room to spare.  I also felt that if any readers are still interested in looking at the
code behind the script, it’s easy enough to point them to the project’s
&lt;a href="https://github.com/jackdewinter/pyscan"&gt;GitHub repository&lt;/a&gt; and make sure it is well
documented.&lt;/p&gt;
&lt;h2 id="setting-up-pyscan-for-its-own-project"&gt;Setting Up PyScan For It’s Own Project&lt;a class="headerlink" href="#setting-up-pyscan-for-its-own-project" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Based on the setup from
&lt;a href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/"&gt;the last article&lt;/a&gt;, the PyTest command
line options &lt;code&gt;--junitxml=report/tests.xml&lt;/code&gt; and &lt;code&gt;--cov-report xml:report/coverage.xml&lt;/code&gt;
place the &lt;code&gt;tests.xml&lt;/code&gt; file and the &lt;code&gt;coverage.xml&lt;/code&gt; file in the &lt;code&gt;report&lt;/code&gt; directory.
Based on observation, the &lt;code&gt;tests.xml&lt;/code&gt; file is in a JUnit XML format and the
&lt;code&gt;coverage.xml&lt;/code&gt;
file is in a Cobertura XML format.  The format of the &lt;code&gt;tests.xml&lt;/code&gt; is pretty obvious from
the command line flag required to generate it.  The format of the &lt;code&gt;coverage.xml&lt;/code&gt; file
took a bit more effort, but the following line of the file keyed me to it’s format:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;&amp;lt;!-- Based on https://raw.githubusercontent.com/cobertura/web/master/htdocs/xml/coverage-04.dtd --&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;From within the project’s root directory, the main script is located at &lt;code&gt;../main.py&lt;/code&gt;.
Since the project uses &lt;code&gt;pipenv&lt;/code&gt;, the command line to invoke the script is
&lt;code&gt;pipenv run python pyscan/main.py&lt;/code&gt; and invoking the script with the &lt;code&gt;--help&lt;/code&gt; option
gives us the options that we can use.  Following the information from the help text,
the command line that I use from the project’s root directory is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run python pyscan/main.py --junit report/tests.xml --cobertura report/coverage.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With everything set up properly, the output from that command looks like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Class Name                     Total Tests   Failed Tests   Skipped Tests
----------------------------  ------------  -------------  --------------
test.test_coverage_profiles              2              0               0
test.test_coverage_scenarios            12              0               0
test.test_publish_scenarios              9              0               0
test.test_results_scenarios             19              0               0
test.test_scenarios                      1              0               0
---                                     --              -               -
TOTALS                                  43              0               0

Test Coverage Summary
---------------------

Type           Covered   Measured   Percentage
------------  --------  ---------  -----------
Instructions       ---        ---        -----
Lines              505        507        99.61
Branches           158        164        96.34
Complexity         ---        ---        -----
Methods            ---        ---        -----
Classes            ---        ---        -----
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="before-we-continue"&gt;Before We Continue…&lt;a class="headerlink" href="#before-we-continue" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To complete my setup, there are two more things that are needed.  The first thing is
that I primarily execute the tests from a simple Windows script called &lt;code&gt;ptest.cmd&lt;/code&gt;.
While there is a lot of code in the &lt;code&gt;ptest.cmd&lt;/code&gt; script to handle errors and options,
when the script is boiled down to it’s bare essence, the script runs tests and reports
on those tests as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run pytest
pipenv run python pyscan/main.py --only-changes --junit report/tests.xml --cobertura=report/coverage.xml
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;Note&lt;/p&gt;
&lt;p&gt;I also have a Bash version called &lt;code&gt;ptest.sh&lt;/code&gt; which I have experimented with locally, but is not checked in to the project.  If you are interested in this script, please let me know in the comments below.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Setting up a script like &lt;code&gt;ptest&lt;/code&gt; keeps things simple and easy-to-use.  One
notable part of the script is that there is a little bit of logic in the script to not
summarize any coverage if there are any issues running the tests under PyTest.  Call me
a purist, but if the tests fail to execute or are not passing, any
measurements of how well the tests cover the code are moot.&lt;/p&gt;
&lt;p&gt;The other thing that I have setup is a small change to the command line for PyScan.  In
the “bare essence” text above, after the text &lt;code&gt;pyscan/main.py&lt;/code&gt;, there is a new option
used for PyScan: the &lt;code&gt;--only-changes&lt;/code&gt; option.  By adding the &lt;code&gt;--only-changes&lt;/code&gt; option,
PyScan restricts the output to only those items that show changes.  If no changes are
detected, it displays a simple line stating that no changes have been observed.  In the
case of the above output, the output with this new option is as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Test results have not changed since last published test results.

Test Coverage Summary
---------------------

Test coverage has not changed since last published test coverage.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To me, this gives a very clear indication that things have not changed.  In the
following sections, I go through different cases and explain what changes I made and
what effects I expect to see summarized.&lt;/p&gt;
&lt;h2 id="introducing-changes-and-observing-behavior"&gt;Introducing Changes and Observing Behavior&lt;a class="headerlink" href="#introducing-changes-and-observing-behavior" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For this section of the article, I temporarily added a “phantom” feature called
“nothing” to PyScan.  This feature is facilitated by two code changes.
In the &lt;code&gt;__parse_arguments&lt;/code&gt; function, I added the following code:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;parser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add_argument&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"--nothing"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;dest&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"do_nothing"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"store_true"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;help&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;"only_changes"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and in the &lt;code&gt;main&lt;/code&gt; function, I changed the code as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;        &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__parse_arguments&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;do_nothing&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"noop"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that this feature is only present for the sake of these examples, and is not in
the project’s code base.&lt;/p&gt;
&lt;h3 id="adding-new-code"&gt;Adding New Code&lt;a class="headerlink" href="#adding-new-code" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;When I added the above code for the samples, the output that I got after running
the tests was:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Test results have not changed since last published test results.

Test Coverage Summary
---------------------

Type       Covered   Measured     Percentage
--------  --------  ---------  -------------
Lines     507 (+2)   511 (+4)  99.22 (-0.39)
Branches  159 (+1)   166 (+2)  95.78 (-0.56)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on the introduced changes, this output was expected.  In the &lt;code&gt;Measured&lt;/code&gt; column,
4 new lines were added (1 in &lt;code&gt;__parse_arguments&lt;/code&gt; and 3 in &lt;code&gt;main&lt;/code&gt;) and the
&lt;code&gt;if args.do_nothing:&lt;/code&gt; line added 2 branches (1 for True and one for False). In the
&lt;code&gt;Covered&lt;/code&gt; column, without any tests to exercise the new code, 2 lines are
covered by default (1 in &lt;code&gt;__parse_arguments&lt;/code&gt; and 1 in &lt;code&gt;main&lt;/code&gt;) and 1 branch is covered
by default (the False case of &lt;code&gt;if args.do_nothing:&lt;/code&gt;).&lt;/p&gt;
&lt;h3 id="adding-a-new-test"&gt;Adding a New Test&lt;a class="headerlink" href="#adding-a-new-test" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Having added source code to the project, I added a test to address the new code.  To
start, I added this simple test function to the &lt;code&gt;test_scenarios.py&lt;/code&gt; file:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_nothing&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This change is just a stub for a test function, so the expected change is that the
number of tests for that module increase and there is no change in coverage.  This
effect is born out by the output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Class Name            Total Tests   Failed Tests   Skipped Tests
-------------------  ------------  -------------  --------------
test.test_scenarios        2 (+1)              0               0
---                       --                   -               -
TOTALS                    44 (+1)              0               0

Test Coverage Summary
---------------------

Type       Covered   Measured     Percentage
--------  --------  ---------  -------------
Lines     507 (+2)   511 (+4)  99.22 (-0.39)
Branches  159 (+1)   166 (+2)  95.78 (-0.56)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id="populating-the-test-function"&gt;Populating the Test Function&lt;a class="headerlink" href="#populating-the-test-function" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Now that a stub for the test is in place and registering, I added a real body to the
test function as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_nothing&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MainlineExecutor&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;suppplied_arguments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"--nothing"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;expected_output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""noop&lt;/span&gt;
&lt;span class="s2"&gt;"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
    &lt;span class="n"&gt;expected_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;execute_results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invoke_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;suppplied_arguments&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;execute_results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assert_results&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;expected_output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_error&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_return_code&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code that I added at the start of this section is triggered by the command line
argument &lt;code&gt;--nothing&lt;/code&gt;, printing the simple response text &lt;code&gt;noop&lt;/code&gt;, and returning a return
code of 1 .  This test code was crafted to trigger that code and to verify the expected
output.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Class Name            Total Tests   Failed Tests   Skipped Tests
-------------------  ------------  -------------  --------------
test.test_scenarios        2 (+1)              0               0
---                       --                   -               -
TOTALS                    44 (+1)              0               0

Test Coverage Summary
---------------------

Type       Covered   Measured     Percentage
--------  --------  ---------  -------------
Lines     509 (+4)   511 (+4)  99.61 ( 0.00)
Branches  160 (+2)   166 (+2)  96.39 (+0.04)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Based on the output from the test results summary, the test does verify that once
triggered, the code is working as expected.  If there was any issue with the test,
the summary would include the text &lt;code&gt;1 (+1)&lt;/code&gt; in the &lt;code&gt;Failed Tests&lt;/code&gt; column to denote
the failure.  As that text is not present, it is safe to assume that both tests in
the &lt;code&gt;test.test_scenarios&lt;/code&gt; module succeeded.  In addition, based on the output from the
test coverage summary, the new code added 4 lines and 2 branches to the code base, and
the new test code covered all of those changes.&lt;/p&gt;
&lt;h3 id="establishing-a-new-baseline"&gt;Establishing a New Baseline&lt;a class="headerlink" href="#establishing-a-new-baseline" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With the new source code and test code in place, I needed to publish the results and
set a new baseline for the project.  To do this with the &lt;code&gt;ptest&lt;/code&gt; script, I invoked the
following command line:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ptest -p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Within this &lt;code&gt;ptest&lt;/code&gt; script, the &lt;code&gt;-p&lt;/code&gt; option was translated into the following command:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv run python pyscan/main.py --publish
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When executed, the &lt;code&gt;publish/coverage.json&lt;/code&gt; and &lt;code&gt;publish/test-results.json&lt;/code&gt; files were
updated with the current summaries.  Following that point, when the script was run, it
reverts back to the original output of:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Test results have not changed since last published test results.

Test Coverage Summary
---------------------

Test coverage has not changed since last published test coverage.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This process can be repeated at any time to establish a solid baseline that any new
changes can be measured against.&lt;/p&gt;
&lt;h3 id="refactoring-code-my-refactoring-process"&gt;Refactoring Code - My Refactoring Process&lt;a class="headerlink" href="#refactoring-code-my-refactoring-process" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In practice, I frequently do “cut-and-paste” development during my normal development
process.  However, I do this with a strict rule that I follow: “2 times on the
fence, 3 times refactor, clean up later”.  That rule break down as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;if I cut-and-paste code once, I then have 2 copies, and I should consider refactoring unless I have a good reason to delay&lt;/li&gt;
&lt;li&gt;if I cut-and-paste that code again, I then have 3 copies, and that third copy must be into a function that the other 2 copies get merged into&lt;/li&gt;
&lt;li&gt;when I have solid tests in place and I am done with primary development, go back
to all of the cases where I have 2 copies and condense them if beneficial&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;My rationale for this rule is as follows.&lt;/p&gt;
&lt;p&gt;When you are creating code, you want the
ideas to flow free and fast, completing a good attempt at meeting your current goal
in the most efficient way possible.  While cut-and-paste as a long term strategy is not
good, I find that in the short term, it helps me in creating a new function, even if
that function is a copy of something done before.  To balance that, from experience, if
I have pasted the same code twice (meeting the criteria for “3 times refactor”), there
is a very good chance that I will use that code at least one more time, if not more.  At
that point, it makes more sense to refactor the code to encapsulate the functionality
properly before the block of code becomes to unwieldly.&lt;/p&gt;
&lt;p&gt;Finally, once I have completed the creation of the new source code, I go back and
actively look for cases where I cut-and-pasted code, and if it is worth it to refactor
that code, with a decision to refactor if I am on the fence.  At the very least,
refactoring code into a function almost always makes the code more readable and
maintainable.  Basically, by following the above rule for refactoring, I almost always
change the code in a positive manner.&lt;/p&gt;
&lt;p&gt;The summaries provided to me from PyScan help me with this refactoring in a big way.
Most of the time, the main idea with refactoring is to change the code on the “inside”
of the program or script without changing the “outside” of the program or script.  If
any changes are made to the “outside”, they are usually small changes with very
predictable impacts.  The PyScan summaries assist me in ensuring that any changes to the
outside of the script are kept small and manageable while also measuring the
improvements made to the inside of the script.  Essentially, seeing both summaries
helps me keep the code refactor of the script very crisp and on course.&lt;/p&gt;
&lt;h3 id="refactoring-code-leveraging-the-summaries"&gt;Refactoring Code - Leveraging The Summaries&lt;a class="headerlink" href="#refactoring-code-leveraging-the-summaries" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;A good function set of functions for me to look at for clean-up refactoring were the
&lt;code&gt;generate_test_report&lt;/code&gt; and &lt;code&gt;generate_coverage_report&lt;/code&gt; functions.  When I wrote those
two functions, I wasn’t sure
how much difference I was going to have between those two functions, so did an initial
cut-and-paste (see “2 times on the fence”) and started making changes.  As those parts
of PyScan are now solid and tested, I went back (see “clean up later”) and compared
the two functions to see what was safe to refactor.&lt;/p&gt;
&lt;p&gt;The first refactor I performed was to extract the xml loading logic into a new
&lt;code&gt;__load_xml_docment&lt;/code&gt; function.  While I admit I didn’t get it right the first time, the
tests kept me in
check and made sure that, after a couple of tries, I got it right.  And when I say
“tries”, I mean that I made a change, ran &lt;code&gt;ptest&lt;/code&gt;, got some information, and diagnosed
it… all within about 30-60 seconds per iteration.  In the end, the summary looked like
this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Test results have not changed since last published test results.

Test Coverage Summary
---------------------

Type        Covered   Measured     Percentage
--------  ---------  ---------  -------------
Lines     499 (-10)  501 (-10)  99.60 (-0.01)
Branches  154 ( -6)  160 ( -6)  96.25 (-0.14)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As expected, the refactor eliminated both lines of code and branches, with the measured
values noted in the summary.&lt;/p&gt;
&lt;p&gt;The second refactor I made was to extract the summary file writing logic into a new
&lt;code&gt;__save_summary_file&lt;/code&gt; function.  I followed a similar pattern to the refactor for
&lt;code&gt;__load_xml_docment&lt;/code&gt;, but there was a small difference.  In this case, I observed that
for a specific error case, one function specified &lt;code&gt;test coverage&lt;/code&gt; and the other function
specified &lt;code&gt;test summary&lt;/code&gt;.  Seeing as consistent names in output is always beneficial,
I decided to change the error messages to be consistent with each other.  The
&lt;code&gt;test coverage&lt;/code&gt; name for the first function remained the same, but the &lt;code&gt;test summary&lt;/code&gt;
name was changed to &lt;code&gt;test report&lt;/code&gt;, with the text &lt;code&gt;summary&lt;/code&gt; added in the refactored
function.&lt;/p&gt;
&lt;p&gt;At this point, I knew that one test for each of the test results scenarios and test
coverage scenarios was going to fail, but I knew that it would fail in a very specific
manner.  Based on the above changes, the text &lt;code&gt;Project test summary file&lt;/code&gt; for the
results scenario test should change to &lt;code&gt;Project test report summary file&lt;/code&gt; and the text
&lt;code&gt;Project test coverage file&lt;/code&gt; for the coverage scenario test should change to
&lt;code&gt;Project test coverage summary file&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When I ran the tests after these changes, there were indeed 2 errors, specifically
in the tests I thought they would show up in.  Once those 2 tests were changed to
reflect the new consistent text, the tests were ran again and produced the following
output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Test results have not changed since last published test results.

Test Coverage Summary
---------------------

Type        Covered   Measured     Percentage
--------  ---------  ---------  -------------
Lines     491 (-18)  493 (-18)  99.59 (-0.01)
Branches  152 ( -8)  158 ( -8)  96.20 (-0.18)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Once again, the output matched my expectations.  While it wasn’t a large number of code
or branches, an additional 8 lines and 2 branches were refactored.&lt;/p&gt;
&lt;h3 id="determining-additive-test-function-coverage"&gt;Determining Additive Test Function Coverage&lt;a class="headerlink" href="#determining-additive-test-function-coverage" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;There are times after I have written a series of tests where I wonder how much actual
coverage a given test contributes to the overall test coverage percentage. As test
coverage is a collaborative effort of all of the tests, a single number that identifies
the amount of code covered by a single test is not meaningful.  However, a meaningful
piece of information is what unique coverage a given test contributes to the collection
of tests as a whole.&lt;/p&gt;
&lt;p&gt;To demonstrate how I do this, I picked one of the tests that addresses one of the error
conditions, the &lt;code&gt;test_summarize_cobertura_report_with_bad_source&lt;/code&gt; function in the
&lt;code&gt;test_coverage_scenarios.py&lt;/code&gt; file.  Before I
changed anything, I made sure to publish the current state to use it as a baseline. To
determine the additive coverage this test provides, I simply changed it’s name to
&lt;code&gt;xtest_summarize_cobertura_report_with_bad_source&lt;/code&gt;.  As the &lt;code&gt;pytest&lt;/code&gt; program only
matches on functions that start with &lt;code&gt;test_&lt;/code&gt;, the function was then excluded from the
tests to be executed.&lt;/p&gt;
&lt;p&gt;Upon running the &lt;code&gt;ptest&lt;/code&gt; script, I got the following output:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Class Name                     Total Tests   Failed Tests   Skipped Tests
----------------------------  ------------  -------------  --------------
test.test_coverage_scenarios       11 (-1)              0               0
---                                --                   -               -
TOTALS                             43 (-1)              0               0

Test Coverage Summary
---------------------

Type       Covered   Measured     Percentage
--------  --------  ---------  -------------
Lines     507 (-2)        511  99.22 (-0.39)
Branches  159 (-1)        166  95.78 (-0.60)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Interpreting this output, given what I documented earlier in this article, was pretty
easy.  As I “disabled”
one of the coverage scenario tests in the &lt;code&gt;test_coverage_scenarios.py&lt;/code&gt; file, the summary
reports one less test in &lt;code&gt;test.test_coverage_scenarios&lt;/code&gt; as expected.  That disabled
test added 2 lines of coverage and 1 branch of coverage to overall effort, coverage
that was now being reported as missing.  As this test was added specifically to test a
single error case, this was expected.&lt;/p&gt;
&lt;p&gt;If instead I disable the &lt;code&gt;xtest_junit_jacoco_profile&lt;/code&gt; test in the
&lt;code&gt;test_coverage_profiles.py&lt;/code&gt; file, I get a different result:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Test Results Summary
--------------------

Class Name                    Total Tests   Failed Tests   Skipped Tests
---------------------------  ------------  -------------  --------------
test.test_coverage_profiles        1 (-1)              0               0
---                               --                   -               -
TOTALS                            43 (-1)              0               0

Test Coverage Summary
---------------------

Type       Covered   Measured     Percentage
--------  --------  ---------  -------------
Lines     501 (-8)        511  98.04 (-1.57)
Branches  152 (-8)        166  91.57 (-4.82)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Like the previous output, the disabled test is showing up as being removed, but there
is a lot more coverage that was removed.  Strangely enough, this was also expected.  As
I also use PyScan to summarize test results from Java projects I work on, I used all 6
coverage measurements available from Jacoco &lt;sup id="fnref:jacoco"&gt;&lt;a class="footnote-ref" href="#fn:jacoco"&gt;1&lt;/a&gt;&lt;/sup&gt; as a baseline for the 2
measurements generated by PyTest for Python coverage.  With a quick look at the
&lt;code&gt;report/coverage/pyscan_model_py.html&lt;/code&gt; file, this was indeed the reason for the
difference, with the test exercising 4 additional paths in each of the serialization
and deserialization functions. Basically, four paths of one line each, times two (one
for serialization and one for deserialization), and the 8 lines/branches covered is
explained.&lt;/p&gt;
&lt;h2 id="wrapping-up"&gt;Wrapping Up&lt;a class="headerlink" href="#wrapping-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I believe that making my decision to talk about how I use my PyScan tool to summarize
test results and test coverage was the right choice.  It is difficult for me to
quantize exactly how much benefit PyScan has provided to my development process, but it
is easily in the very positive to indispensable category.  By providing a quick summary
on the test results file and the test coverage file, I can ensure that any changes I
make are having the proper effects on those two files at each stage of the change that
I am making.  I hope that by walking through this process and how it helps me, it will
inspire others to adopt something similar in their development processes.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:jacoco"&gt;
&lt;p&gt;For an example Jacoco HTML report that shows all 6 coverage measurements, check out &lt;a href="https://www.jacoco.org/jacoco/trunk/coverage/"&gt;the report trunk coverage for Jacoco&lt;/a&gt;. &lt;a class="footnote-backref" href="#fnref:jacoco" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="pytest"></category><category term="scenario testing"></category></entry><entry><title>Measuring Testing in Python Scripts</title><link href="https://jackdewinter.github.io/2020/01/13/measuring-testing-in-python-scripts/" rel="alternate"></link><published>2020-01-13T00:00:00-08:00</published><updated>2020-01-13T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-01-13:/2020/01/13/measuring-testing-in-python-scripts/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As part of the process of
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;creating a Markdown Linter&lt;/a&gt;
to use with my personal website, I firmly believe that it is imperative that I have
solid testing on that linter and the tools necessary to test the linter.  In my
previous article on
&lt;a href="https://jackdewinter.github.io/2020/01/06/scenario-testing-python-scripts/"&gt;Scenario Testing Python Scripts&lt;/a&gt;,
I …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As part of the process of
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;creating a Markdown Linter&lt;/a&gt;
to use with my personal website, I firmly believe that it is imperative that I have
solid testing on that linter and the tools necessary to test the linter.  In my
previous article on
&lt;a href="https://jackdewinter.github.io/2020/01/06/scenario-testing-python-scripts/"&gt;Scenario Testing Python Scripts&lt;/a&gt;,
I described the in-process framework that I use for testing Python scripts from within
PyTest.  That framework ensures that I can properly test Python scripts from the
start of the script, increasing my confidence that they are tested properly.&lt;/p&gt;
&lt;p&gt;To properly figure out how my tests are doing and what their impact is, I turned on a
number of features that are available with PyTest.  The features either make testing
easier or measure the impact of those tests and relay that information. This article
describes my PyTest configuration and how that configuration provides a benefit to my
development process.&lt;/p&gt;
&lt;h2 id="adding-needed-packages-to-pytest"&gt;Adding Needed Packages to PyTest&lt;a class="headerlink" href="#adding-needed-packages-to-pytest" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There are four main Python packages that I use in conjunction with PyTest.  The
&lt;code&gt;pytest-console-scripts&lt;/code&gt; package is the main one, allowing PyTest to be invoked
from the command line.  Since I am in favor of automating process where possible, this
is a necessity.  From a test execution point of view, the &lt;code&gt;pytest-timeout&lt;/code&gt; is
used to set a timeout on each test, ensuring that a single runaway test does not cause
the set of tests to fail to complete.  For reporting, the &lt;code&gt;pytest-html&lt;/code&gt; package is
useful for creating an HTML summary of the test results.  The &lt;code&gt;pytest-cov&lt;/code&gt; package adds
coverage of the source code, with reporting of that coverage built in.  I have found
that all of these packages help me in my development of Python scripts, so I highly
recommend these packages.&lt;/p&gt;
&lt;p&gt;Depending on the Python package manager and environment in use, there will be slightly
different methods to install these packages.  For plain Python this is usually:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pip install pytest-console-scripts&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.20 pytest-cov&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.8.1 pytest-timeout&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.3.3 pytest-html&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.0.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As I have used &lt;code&gt;pipenv&lt;/code&gt; a lot in my professional Python development, all of my personal
projects use it for setting up the environment and it’s dependencies.  Similar to the
line above, to install these packages into &lt;code&gt;pipenv&lt;/code&gt; requires executing the following
line in the project’s directory:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pipenv install pytest-console-scripts&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;.20 pytest-cov&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.8.1 pytest-timeout&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;.3.3 pytest-html&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;.0.1
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="configuring-pytest-for-those-packages"&gt;Configuring PyTest For Those Packages&lt;a class="headerlink" href="#configuring-pytest-for-those-packages" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unless information is provided on the command line, PyTest will search for a
configuration file to use.  By default, &lt;code&gt;setup.cfg&lt;/code&gt; is the name of the configuration
file it uses.  The following fragment of my &lt;code&gt;setup.cfg&lt;/code&gt; file takes care of the
configuration for those PyTest packages.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[tool:pytest]
testpaths=./test
cache_dir=./build/test/.pytest_cache
junit_family=xunit2
addopts=--timeout=10 --cov --cov-branch --cov-fail-under=90 --strict-markers -ra --cov-report xml:report/coverage.xml --cov-report html:report/coverage --junitxml=report/tests.xml --html=report/report.html
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;While all configuration is important, the following sections are most important in the
setting up of PyTest for measuring the effects of testing:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;testpaths=./test&lt;/code&gt; - relative path where PyTest will scan for tests&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addopts/--junitxml&lt;/code&gt; - creates a junit-xml style report file at given path&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addopts/--cov&lt;/code&gt; - record coverage information for everything&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addopts/--cov-branch&lt;/code&gt; - enables branch coverage&lt;/li&gt;
&lt;li&gt;&lt;code&gt;addopts/--cov-report&lt;/code&gt; - types of report to generate and their destination paths&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default/--cov-config&lt;/code&gt; - configuration file for coverage, defaulting to &lt;code&gt;.coveragerc&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In order, the first two configuration items tells PyTest where to look for tests to
execute and where to place the JUnit-styled XML report with the results of each test.
The next three configuration items turn on coverage collection, enable
branch coverage, and specifies what types of coverage reports to produce and where to
place them.  Finally, because the &lt;code&gt;--cov-config&lt;/code&gt; is not set, the default location for
the coverage configuration file is set to &lt;code&gt;.coveragerc&lt;/code&gt;.  &lt;/p&gt;
&lt;p&gt;For all of my projects, the default &lt;code&gt;.coveragerc&lt;/code&gt; that I use, with a small change to
the &lt;code&gt;source=&lt;/code&gt; line is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[run]
source = pyscan

[report]
exclude_lines =
    # Have to re-enable the standard pragma
    pragma: no cover

    # Don't complain about missing debug-only code:
    def __repr__
    if self\.debug

    # Don't complain if tests don't hit defensive assertion code:
    raise AssertionError
    raise NotImplementedError

    # Don't complain if non-runnable code isn't run:
    if 0:
    if __name__ == .__main__.:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To be honest, this &lt;code&gt;.coveragerc&lt;/code&gt; template is something I picked up somewhere, but it
works, and works well for my needs.  The exclude lines work in all case that I have
come across, so I haven’t touched them in the 2+ years that I have been writing code in
Python.&lt;/p&gt;
&lt;h2 id="benefits-of-this-configuration"&gt;Benefits Of This Configuration&lt;a class="headerlink" href="#benefits-of-this-configuration" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Given the setup from the last section, there are two main benefits that I get from this
setup.  The first benefit is machine readable XML information generated for the test
results and the test coverage.  While this is not immediately consumable in it’s
current form, that data can be harvested in the future to provide concise information
about what has been tested.&lt;/p&gt;
&lt;p&gt;The second benefit is to provide human readable information about the tests that have
been executed.  The HTML file located at &lt;code&gt;report/report.html&lt;/code&gt; relays the results of the
last series of tests while the HTML file located at &lt;code&gt;report/coverage/index.html&lt;/code&gt; relays
the coverage information for the last series of tests.  Both of these pieces of
information are useful for different reasons.&lt;/p&gt;
&lt;p&gt;In the case of the test results HTML, the information presented on the test results page
is mostly the same information as is displayed by PyTest when executed on the command
line.  Some useful changes are present, such as seeing all of the test information at
once, instead of just a &lt;code&gt;.&lt;/code&gt; for a successful test, a &lt;code&gt;F&lt;/code&gt; for a failed test, and so on.
I have found that having this information available on one page allows me to more
quickly debug an issue that is affecting multiple tests, instead of scrolling through
the command line output one test at a time.&lt;/p&gt;
&lt;p&gt;In the case of the test coverage HTML, the information presented on this page is
invaluable.  For each source file in the Python project being tested, there is a page
that clearly shows which lines of each Python script are exercised by the tests,  By
using these pages as a guide, I can determine what tests I need to add to ensure that
the scripts are properly covered.&lt;/p&gt;
&lt;p&gt;By using these two tools together, I can quickly determine what tests to add, and when
tests fail, I can determine why they failed and look for patterns in the failures.  This
enables me to quickly figure out where the blind spots are in my testing, and to address
them quickly.  This in turn can help me to figure out the best way to improve the
quality of the project I am working on.&lt;/p&gt;
&lt;p&gt;If this finds an issue with an existing requirement, that requirement can be adjusted
or a new requirement added to fulfil the deficiency.  If the requirements were all
right and the code it was testing was incorrect, that code can be addressed.  If
the coverage page shows that code was written but not tested, a new test function can
be introduced to cover that scenario.  Each observation and its appropriate action
work to improve the quality of the software project.&lt;/p&gt;
&lt;h2 id="what-was-accomplished"&gt;What Was Accomplished&lt;a class="headerlink" href="#what-was-accomplished" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This article showed how to setup PyTest using a configuration file.  With that
configuration file, it was set up to provide timeouts for tests, provide output on
the test results, and provide a coverage report of how well the tests covered the
scripts under test.  This was all accomplished to better understand the impact of tests
on a project and provide better information on how they succeed (test coverage) or fail
(test results).  By understanding this information, the quality of the software
can be measured and improved on if needed.&lt;/p&gt;
&lt;h2 id="what-is-next"&gt;What Is Next?&lt;a class="headerlink" href="#what-is-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the next article, I will briefly describe the PyScan tool I have written, and how it
takes the XML information generate by the &lt;code&gt;--junitxml=report/tests.xml&lt;/code&gt; option and the
&lt;code&gt;--cov-report xml:report/coverage.xml&lt;/code&gt; option and produces concise summaries of that
information.  I will also give a number of examples of how I use this information during
my development of Python projects.&lt;/p&gt;</content><category term="Software Quality"></category><category term="pytest"></category><category term="scenario testing"></category></entry><entry><title>Scenario Testing Python Scripts</title><link href="https://jackdewinter.github.io/2020/01/06/scenario-testing-python-scripts/" rel="alternate"></link><published>2020-01-06T00:00:00-08:00</published><updated>2020-01-06T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2020-01-06:/2020/01/06/scenario-testing-python-scripts/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As part of the process of
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;creating a Markdown Linter&lt;/a&gt;
to use with my personal website, I firmly believe that it is imperative that I have
solid testing on that linter and the tools necessary to test the linter.  This testing
includes executing those Python tool scripts from start …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As part of the process of
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;creating a Markdown Linter&lt;/a&gt;
to use with my personal website, I firmly believe that it is imperative that I have
solid testing on that linter and the tools necessary to test the linter.  This testing
includes executing those Python tool scripts from start to finish and verifying that
everything is working properly.  From my experience, one of the most efficient ways to
scenario test the project’s Python scripts is to use an in-process framework for
running Python scripts.&lt;/p&gt;
&lt;p&gt;Because of the way that Python works, it is very feasible to scenario test the Python
scripts using the in-process framework which I describe in this article.  To show
how the framework works in practice, I reference my
&lt;a href="https://github.com/jackdewinter/pyscan"&gt;PyScan project&lt;/a&gt; to
illustrate how I use this framework to test the scenarios in that project.
Specifically, I talk about the
&lt;a href="https://github.com/jackdewinter/pyscan/blob/master/test/pytest_execute.py"&gt;pytest_execute.py file&lt;/a&gt;
which contains the bulk of the code I use to write scenario tests with.&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;h2 id="determine-the-requirements"&gt;Determine the Requirements&lt;a class="headerlink" href="#determine-the-requirements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As with most of my projects, the first thing I do for any new project is to cleanly
determine and document the requirements for the project.  Even though this project is
a single component used to test the tools and other components, I feel strongly that it
is still important to follow those guidelines to ensure the right component is built in
the right way.&lt;/p&gt;
&lt;p&gt;The basic requirements are pretty easy to define for this in-process test component:
execute the Python script independently and capture all relevant information about it’s
execution, verifying that information against expected values.  The devil is in the
details however.  I believe that a good definition of “execute the Python script” must
include the ability to set the current working directory and arguments for the command
line. For a good definition of “capture all relevant information”, I believe the
requirements must include capturing of the script’s return code as well as any output
to standard out (stdout) and standard error (stderr).  As this component executes the
script in-process, any attempts to exit the script prematurely must be properly
captured, and the state of the test must be returned to what it was at the beginning of
the test. Finally, to satisfy the “verifying” requirement, the component must have easy
to use comparison functions, with informative output on any differences that arise
during verification.&lt;/p&gt;
&lt;p&gt;Finding a balance between too many bulky requirements and too few lean requirements is
a tough balance to achieve.  In this case, I feel that I have achieved that balance by
ensuring all of the major parts of the requirements are specified at a high enough level
to be able to communicate clearly without ambiguity.  Here’s hoping I get the balance
right!&lt;/p&gt;
&lt;h2 id="capture-relevant-information"&gt;Capture Relevant Information&lt;a class="headerlink" href="#capture-relevant-information" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The first thing to take care of is a class that will contain the information to satisfy
the “capture all relevant information” requirement above.  As the requirement specifies
the 3 things that need to be captured, all that is left to do is to create a class to
encapsulate these variables as follows:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;InProcessResult&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Class to provide for an encapsulation of the results of an execution.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;return_code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std_out&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std_err&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;return_code&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_out&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std_out&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_err&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std_err&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="executing-the-script"&gt;Executing the Script&lt;a class="headerlink" href="#executing-the-script" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Now that there is an object to collect the information about the script’s execution, a
simple function is needed to collect that information.  In the &lt;code&gt;InProcessExecution&lt;/code&gt;
base class, the &lt;code&gt;invoke_main&lt;/code&gt; function serves this purpose.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;invoke_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Invoke the mainline so that we can capture results.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;

        &lt;span class="n"&gt;saved_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SystemState&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="n"&gt;std_output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StringIO&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;std_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;StringIO&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;returncode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;
            &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std_output&lt;/span&gt;
            &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std_error&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[]&lt;/span&gt;
            &lt;span class="n"&gt;sys&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;insert&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;get_main_name&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;chdir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;execute_main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;SystemExit&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;this_exception&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;returncode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle_system_exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this_exception&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std_error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;returncode&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle_normal_exception&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;saved_state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;restore&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;InProcessResult&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;returncode&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std_output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;std_error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Before changing any of the existing system values, changes that by their very nature
are be made across the entire Python interpreter, the original values of those system
values are kept safely in an instance of the the &lt;code&gt;SystemState&lt;/code&gt; class in the
&lt;code&gt;saved_state&lt;/code&gt; variable.  As I want to ensure that the saved system state is reverted
back to regardless of what happens, a try-finally block is used to ensure that the
&lt;code&gt;saved_state.restore&lt;/code&gt; function is called to restore the system back to it’s original
state.&lt;/p&gt;
&lt;p&gt;Once the system state is safely stored away, changes to those system values can be made.
Instances of the &lt;code&gt;StringIo&lt;/code&gt; class are used to provide alternative streams for stdout
and stderr.  A new array is assigned to &lt;code&gt;sys.argv&lt;/code&gt;, either an empty array if no
arguments are provided or a copy of the provided array if provided.  To the start of
that array is inserted the name of the main script, to ensure that libraries expecting
a properly formatted array of system arguments are happy.  Finally, if an alternate
working directory is provided to the function, the script changes to that directory.&lt;/p&gt;
&lt;p&gt;To reiterate, the reason it is acceptable to make all of these changes to the system
state is that we have a safe copy of the system state stored away that we will revert
to when this function completes.&lt;/p&gt;
&lt;p&gt;After the &lt;code&gt;execute_main&lt;/code&gt; function is called to execute the script in the specified
manner, there are three possibilities that the function needs to capture the
information for. In the case of a normal fall-through execution, the &lt;code&gt;returncode = 0&lt;/code&gt;
statement at the start of the try-finally block sets the return code.  If a
&lt;code&gt;SystemExit&lt;/code&gt; exception is thrown, the &lt;code&gt;handle_system_exit&lt;/code&gt; function does a bit of
process to figure out the return code based on the contents of the exception.  Finally,
if the execution is terminated for any other exception, the &lt;code&gt;handle_normal_exception&lt;/code&gt;
makes sure to print out decent debug information and sets the return code to 1.  In all
three cases, the collected values for stdout and stderr are collected, combined with
the return code determined earlier in this paragraph, and a new instance of the
&lt;code&gt;InProcessResult&lt;/code&gt; class is returned with these values.&lt;/p&gt;
&lt;h2 id="verifying-actual-results-against-expected-results"&gt;Verifying Actual Results Against Expected Results&lt;a class="headerlink" href="#verifying-actual-results-against-expected-results" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When I started with the &lt;code&gt;assert_results&lt;/code&gt; function, it was only 3 statements in quick
succession: 3 assert statements asserting that the actual values for stdout, stderr and
the return code matched the expected values.  However, as I started using that function,
it was quickly apparent that when something did fail, there was a certain amount of
repetitive debugging that I performed to determine why the assert was triggered.  At
first I added some extra information to the assert statements, and that worked for the
return code.  But there were still two issues.&lt;/p&gt;
&lt;p&gt;The first issue was that, in the case where all 3 expected values were different than
the actual values, it took 3 iterations of cleaning up the test before it passed.  Only
when I cleared up the first failure did I see the second failure, and only after the
second failure was dealt with did I see the third.  While this was workable, it was far
from efficient.  The second issue was that if there were any differences with the
contents of the stdout or stderr stream, the differences between the expected value and
the actual value were hard to discern by just looking at them.&lt;/p&gt;
&lt;p&gt;To address the first issue, I changed the simple &lt;code&gt;assert_results&lt;/code&gt; function to the
following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assert_results&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;error_code&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Assert the results are as expected in the "assert" phase.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;

        &lt;span class="n"&gt;stdout_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assert_stream_contents&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"stdout"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_out&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;stderr_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assert_stream_contents&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"stderr"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;std_err&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stderr&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;return_code_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assert_return_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;return_code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;error_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

        &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;stdout_error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdout_error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;stderr_error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr_error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;return_code_error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;combined_error_msg&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;return_code_error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;combined_error_msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
            &lt;span class="s2"&gt;"Either stdout, stderr, or the return code was not as expected.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
            &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;combined_error_msg&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The key to resolving the first issue is in capturing the information about all
differences that occur, and then asserting only once if any differences are encountered.
To accomplish this, several comparison functions are required that capture individual
asserts and relay that information back to the &lt;code&gt;assert_results&lt;/code&gt; function where they
can be aggregated together.  It is these comparison functions that are at the heart
of the &lt;code&gt;assert_results&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;The easiest
of these comparison functions is the &lt;code&gt;assert_return_code&lt;/code&gt; function, which simply
compares the actual return code and the expected return code.  If there is any
difference, the error message for the assert statement is descriptive enough to provide
a clear indication of what the difference is.  That raised &lt;code&gt;AssertionError&lt;/code&gt; is then
captured and returned from the function so the &lt;code&gt;assert_results&lt;/code&gt; function can report on
it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assert_return_code&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_return_code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_return_code&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Assert that the actual return code is as expected.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;actual_return_code&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;expected_return_code&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="s2"&gt;"Actual error code ("&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;actual_return_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;") and expected error code ("&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_return_code&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;") differ."&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;A slightly more complicated function is the &lt;code&gt;assert_stream_contents&lt;/code&gt; comparison
function. To ensure
that helpful information is returned in the assert failure message, it checks to see if
the &lt;code&gt;expected_stream&lt;/code&gt; is set and calls &lt;code&gt;compare_versus_expected&lt;/code&gt; if so.  (More about
that function in a minute.)  If not set, the assert used clearly states that the stream
was expected to be empty, and the actual stream is not empty.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;assert_stream_contents&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stream_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_stream&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Assert that the contents of the given stream are as expected.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;

        &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;expected_stream&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;compare_versus_expected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="n"&gt;stream_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_stream&lt;/span&gt;
                &lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getvalue&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                    &lt;span class="s2"&gt;"Expected "&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;stream_name&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" to be empty. Not:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;---&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getvalue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
                    &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;---&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
                &lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ex&lt;/span&gt;
        &lt;span class="k"&gt;finally&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Addressing the second issue with the initial &lt;code&gt;assert_results&lt;/code&gt; function, the differences
between the two streams being difficult to discern, is the &lt;code&gt;compare_versus_expected&lt;/code&gt;
function.  My first variation on this function simply used the statement
&lt;code&gt;assert actual_stream.getvalue() != expected_text&lt;/code&gt;, producing the same assert result,
but lacking in the description of why the assert failed.  The second variation of this
function added a better assert failure message, but left the task of identifying the
difference between the two strings on the reader of the failure message.  The final
variation of this function uses the &lt;code&gt;difflib&lt;/code&gt; module and the &lt;code&gt;difflib.ndiff&lt;/code&gt; function to
provide a detailed line-by-line comparison between the actual stream contents and the
expected stream contents.  By using the &lt;code&gt;difflib.ndiff&lt;/code&gt; function in this final
variation, the assert failure message now
contains a very easy to read list of the differences between the two streams.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;difflib&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;compare_versus_expected&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="bp"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stream_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_text&lt;/span&gt;
    &lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;        Do a thorough comparison of the actual stream against the expected text.&lt;/span&gt;
&lt;span class="sd"&gt;        """&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getvalue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;expected_text&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;diff&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;difflib&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ndiff&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;expected_text&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitlines&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;actual_stream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getvalue&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;splitlines&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;

            &lt;span class="n"&gt;diff_values&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;diff&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
                &lt;span class="n"&gt;stream_name&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;" not as expected:&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;---&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;diff_values&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;---&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;
            &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="using-it-all-together"&gt;Using it all together&lt;a class="headerlink" href="#using-it-all-together" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To start using the work that completed in the sections above, a proper subclass of the
&lt;code&gt;InProcessExecution&lt;/code&gt; class is required.  Because that class is an abstract base class,
a new class &lt;code&gt;MainlineExecutor&lt;/code&gt; is required to resolve the &lt;code&gt;execute_main&lt;/code&gt; function and
the &lt;code&gt;get_main_name&lt;/code&gt; function.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MainlineExecutor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InProcessExecution&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="nb"&gt;super&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="fm"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="n"&gt;resource_directory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;path&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;os&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getcwd&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s2"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"resources"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resource_directory&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;resource_directory&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;execute_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;PyScan&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_main_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s2"&gt;"main.py"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;MainlineExecutor&lt;/code&gt; class implements those two required functions.  The
&lt;code&gt;get_main_name&lt;/code&gt; function returns the name of the module entry point for the project.
This name is inserted into the array of arguments to ensure that any functions based
off of the command line &lt;code&gt;sys.argv&lt;/code&gt; array resolves properly.  The &lt;code&gt;execute_main&lt;/code&gt;
function implements the actual code to invoke the main entry point for the script.  In
the case of the PyScan project, the entry point at the end of the &lt;code&gt;main.py&lt;/code&gt; script is:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;"__main__"&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;PyScan&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Therefore, the contents of the &lt;code&gt;execute_main&lt;/code&gt; function is &lt;code&gt;PyScan().main()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In addition to those two required functions, there is some extra code in the constructor
for the class.  Instead of recomputing the resource directory in each test that requires
it, the &lt;code&gt;MainlineExecutor&lt;/code&gt; class computes it in the constructor to keep the test
functions as clean as possible.  While this is not required when subclassing from
&lt;code&gt;InProcessExecution&lt;/code&gt;, it has proven very useful in practice.&lt;/p&gt;
&lt;p&gt;To validate the use of the &lt;code&gt;MainlineExecutor&lt;/code&gt; class with the project, I created a
simple scenario test to verify that the version of the scanner is correct.  This is
very simple test, and verifying that the framework passes such a simple test increases
the confidence in the framework itself.  At the start of the scenario test, the
&lt;code&gt;executor&lt;/code&gt; variable is created and assigned an instance of our new class
&lt;code&gt;MainlineExecutor&lt;/code&gt; as well as specify that the arguments to
use for the script as &lt;code&gt;["--version"]&lt;/code&gt;. in the array &lt;code&gt;suppplied_arguments&lt;/code&gt;  In keeping
with the Arrange-Act-Assert pattern, I then specify the expected behaviors for stdout
(in &lt;code&gt;expected_output&lt;/code&gt;), stderr (in &lt;code&gt;expected_error&lt;/code&gt;), and the return code from the
script (in &lt;code&gt;expected_return_code&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Having set everything up in the Assert section of the test, the Act section simply
invokes the script using the &lt;code&gt;executor.invoke_main&lt;/code&gt; function with the
&lt;code&gt;suppplied_arguments&lt;/code&gt; variable assigned previously, and collect the results.  Once
collected, the &lt;code&gt;execute_results.assert_results&lt;/code&gt; function verifies those actual results
against the expected results, asserting if there are differences.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_get_summarizer_version&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Make sure that we can get information about the version of the summarizer.&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;executor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MainlineExecutor&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;suppplied_arguments&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;"--version"&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;expected_output&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""&lt;/span&gt;&lt;span class="se"&gt;\&lt;/span&gt;
&lt;span class="s2"&gt;main.py 0.1.0&lt;/span&gt;
&lt;span class="s2"&gt;"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;""&lt;/span&gt;
    &lt;span class="n"&gt;expected_return_code&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;execute_results&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;executor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;invoke_main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;suppplied_arguments&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cwd&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;execute_results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;assert_results&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
        &lt;span class="n"&gt;expected_output&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_error&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;expected_return_code&lt;/span&gt;
    &lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="what-does-using-this-look-like"&gt;What Does Using This Look Like?&lt;a class="headerlink" href="#what-does-using-this-look-like" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In terms of writing scenario tests, the tests are usually as simple to write as the
&lt;code&gt;test_get_summarizer_version&lt;/code&gt; function in the last section.  If there are parts of the
output that have a non-constant value, such as the full path of the directory in which
the test is executed in, the &lt;code&gt;expected_output&lt;/code&gt; variable would have to be set to
compensate for that variability, but that is an expected complexity.&lt;/p&gt;
&lt;p&gt;For the PyScan project, a quick scan of the 
&lt;a href="https://github.com/jackdewinter/pyscan/blob/master/test/test_scenarios.py"&gt;PyScan test_scenarios.py file&lt;/a&gt; reveals that for this project, the non-constant values most often
occur with failure messages, especially ones that relay path information in their
failure messages.  When that happens, such as with the
&lt;code&gt;test_summarize_junit_report_with_bad_source&lt;/code&gt; test function, that extra complexity
is not overwhelming and does not make the test function unreadable.&lt;/p&gt;
&lt;p&gt;In terms of the test output for a passing test, there is no difference.  If executing
&lt;code&gt;pipenv run pytest&lt;/code&gt; produced a &lt;code&gt;.&lt;/code&gt; for a successful test before, it remains a &lt;code&gt;.&lt;/code&gt; now.
The big difference is in what is displayed when there is a difference in the test
output.  &lt;/p&gt;
&lt;p&gt;In the case where there is a single character difference in the test output, such as
changing the expected output for the &lt;code&gt;test_get_summarizer_version&lt;/code&gt; test to
&lt;code&gt;main.py 0.1.1&lt;/code&gt;, the output below
clearly shows where the actual output and expected output differ.  Note that in these
comparisons, the line that starts with the &lt;code&gt;-&lt;/code&gt; character is the expected output and
the line that starts with the &lt;code&gt;+&lt;/code&gt; character is the actual output.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E       AssertionError: Either stdout, stderr, or the return code was not as expected.
E
E       stdout not as expected:
E       ---
E       - main.py 0.1.1
E       ?             ^
E
E       + main.py 0.1.0
E       ?             ^
E
E       ---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In the case where a line in the test output is completely different, such as changing
the expected output to &lt;code&gt;This is another line&lt;/code&gt;, the output below clearly reflects that
difference:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E       AssertionError: Either stdout, stderr, or the return code was not as expected.
E
E       stdout not as expected:
E       ---
E       - This is another line
E       + main.py 0.1.0
E       ---
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Finally, in the case where the actual output contains either more lines or less lines
that the expected output, such as adding the line &lt;code&gt;This is another line&lt;/code&gt; to the
expected output, the output below clearly shows that difference.  In this example, as
the first line is at the start of both the actual output and expected output, it is
shown without any prefix to the line.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;E       AssertionError: Either stdout, stderr, or the return code was not as expected.
E
E       stdout not as expected:
E       ---
E         main.py 0.1.0
E       - This is another line
E       ---
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="summary"&gt;Summary&lt;a class="headerlink" href="#summary" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While the &lt;code&gt;pytest_execute.py&lt;/code&gt; file that I use as the base for my scenario tests isn’t
rocket science, it is invaluable to me in creating simple, easy-to-read scenario tests.
At the heart of the module is the base requirement (as stated above) to execute the
Python script independently, capture all relevant information about it’s execution,
and then verifying that information against expected values.  Based on my experience
and evolution of this module, I believe that it handily satisfies the requirements
with ease.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;To keep things simple for the article, the &lt;code&gt;additional_error&lt;/code&gt; parameter from a number of the functions has been removed.  This parameter is used in the PyMarkdown project and will be documented as part of my articles on that project. &lt;a class="footnote-backref" href="#fnref:1" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="pytest"></category><category term="scenario testing"></category></entry><entry><title>Have a Happy Winter Holiday 2019</title><link href="https://jackdewinter.github.io/2019/12/29/have-a-happy-winter-holiday-2019/" rel="alternate"></link><published>2019-12-29T00:00:00-08:00</published><updated>2019-12-29T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2019-12-29:/2019/12/29/have-a-happy-winter-holiday-2019/</id><summary type="html">&lt;p&gt;I just wanted to take a quick minute and wish everyone a  happy winter holiday season
as 2019 winds to a close.  When I resume posts in the new year, I will be trying to
publish weekly posts on Mondays instead of Sundays, and see how that goes.&lt;/p&gt;
&lt;p&gt;Safe travels …&lt;/p&gt;</summary><content type="html">&lt;p&gt;I just wanted to take a quick minute and wish everyone a  happy winter holiday season
as 2019 winds to a close.  When I resume posts in the new year, I will be trying to
publish weekly posts on Mondays instead of Sundays, and see how that goes.&lt;/p&gt;
&lt;p&gt;Safe travels, and well wishes.&lt;/p&gt;</content><category term="Software Quality"></category></entry><entry><title>Markdown Linter - Parser Testing Strategy</title><link href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/" rel="alternate"></link><published>2019-12-22T00:00:00-08:00</published><updated>2019-12-22T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2019-12-22:/2019/12/22/markdown-linter-parser-testing-strategy/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the previous articles in this series, I discussed the requirements for the Markdown
linter that I am writing.  From a development point of view, the main requirement is
the need for an accurate stream of tokens emitted by the parser.  Due to the absence of
any Markdown-to-token parsers …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the previous articles in this series, I discussed the requirements for the Markdown
linter that I am writing.  From a development point of view, the main requirement is
the need for an accurate stream of tokens emitted by the parser.  Due to the absence of
any Markdown-to-token parsers out there, I need to write a new parser that outputs an
accurate stream of tokens instead of a stream of HTML text. With the last article
showing the patterns I am using to test the parser, it is now time to figure out a set
of good strategies for the project, to ensure I can complete it without losing my
confidence (and sanity).&lt;/p&gt;
&lt;h2 id="why-is-strategy-important-when-testing"&gt;Why Is Strategy Important When Testing?&lt;a class="headerlink" href="#why-is-strategy-important-when-testing" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;When my son was younger, like most boys in his age group, he loved playing with LEGO and
he loved the idea of robots.  I mean, come on!  I am a lot older than him and I still
like LEGO and the idea of robots!  Anyhow, at his school they advertised for 5th grade
students that were interested in participating in a local
&lt;a href="http://firstlegoleague.org/"&gt;FIRST Lego League&lt;/a&gt; robotics team. From the first mention
of it, he was hooked.  As they needed some parents to help out, I participated with him
as a coach.  That position was a very rewarding, very humbling, and very frustrating
experience. Rewarding because I got to help 5th graders learn a little taste of what I
did everyday at work.  Humbling because the look in the kid’s eyes when they really
understood something reminded me of the benefits of being a coach.  Frustrating because
of almost all of the rest of the time between those two types of moments.&lt;/p&gt;
&lt;p&gt;I am not sure which parent, coach, or teacher helped me with a little gem of wisdom,
but I remember it as clear as day:  People have problems moving boulders, people
have success moving pebbles.  The idea behind that phrase is that if a team is
confronted with a problem, it is like encountering a boulder that you need to move out
of the way. Upon seeing a big boulder, many people take a look at it and say something
similar to “Wow! That is too big to move!”  But if you take that boulder and break it
down into smaller rocks, such as pebbles, many people will just laugh with ease at
moving those rocks, even if they have to do it one at a time.  In a similar fashion,
breaking down a big problem into smaller problems is a necessity in problem solving a
situation.  The boulders-to-pebbles phrase is a phrase I still use to this day when
coaching people in both my professional and personal lives.&lt;/p&gt;
&lt;p&gt;Writing a parser that handles anything more significant than a single line of text is
definitely “a boulder”.  I have been writing parsers for the better part of 25 years,
and those parsers are still boulders to me. However, I know from experience that
breaking down that “boulder-sized” task into more “pebble-sized” tasks works and works
well.  So here are the various items of my strategy for this project.&lt;/p&gt;
&lt;h2 id="strategy-0-define-and-execute-testing-linting-and-formatting"&gt;Strategy 0: Define and Execute Testing, Linting, and Formatting&lt;a class="headerlink" href="#strategy-0-define-and-execute-testing-linting-and-formatting" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For me this is a strategy that I bring to almost every project, with very few
exceptions.  I always start with some kind of workflow template that I apply to the
project that performs formatting of the source code, linting of the source code, and
executes the testing framework.  Since I am a stickler for this approach, the setup for
this workflow usually takes 5 minutes or less, as I usually have at least one example
project lying around.  By consistently executing this workflow before committing any
changes, I keep the quality reasonably high as I go.&lt;/p&gt;
&lt;p&gt;Knowing that I had this framework in place for the Markdown parser was a godsend.  My
preference is to find frequent small break points during the implementation of a
feature, and to use those points to run the workflow.  For me, it increases my
confidence that I am either establishing a new “last known good point” or that I need
to retrace my steps to the last known good point to address an issue.  That confidence
helps me go forward with a positive attitude.&lt;/p&gt;
&lt;h2 id="strategy-0a-suppress-major-issues-until-later"&gt;Strategy 0A: Suppress Major Issues Until Later&lt;a class="headerlink" href="#strategy-0a-suppress-major-issues-until-later" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;This may seem like somewhat of a counter to Strategy 0, but I see it more of allowing
the project to grow, but being reminded that there is work to do.  Minor issues such
as stylistics and documentation are handled right away, as they have a direct impact
on the maintainability of the code as it moves forward.  Major issues usually involve
a larger amount of code, and changing that much code usually has a fair amount of side
effects unless you work to prevent those side effects.&lt;/p&gt;
&lt;p&gt;Major issues are usually of the “too many/much” type, such as “too much complexity”,
“too many statements”, or “too many boolean statements”.  When I get to a really good
and stable point in the project, I know I will deal with these.  If I deal with the
issues before I get to such a point, I am taking a chance that I won’t have the
stability to make the change, while limiting and dealing with any potential side effects
in a clean and efficient manner.&lt;/p&gt;
&lt;p&gt;What is a good and stable point? For me, such a point has to have two dominant
characteristics.  The first is that I need to have a solid collection of tests in place
that I can execute.  These tests make sure that any refactoring doesn’t negatively
affect the quality of the code. The second characteristic is that the source code for
the project is at a point where there is a large degree of confidence that the
code in the section that I want to refactor is very solid and very well defined.  This
ensures that I can start looking for commonalities and efficiencies for refactoring
that will enhance the source code, but not prematurely.&lt;/p&gt;
&lt;h2 id="strategy-1-break-tests-and-development-into-task-groups"&gt;Strategy 1: Break Tests and Development Into Task Groups&lt;a class="headerlink" href="#strategy-1-break-tests-and-development-into-task-groups" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Following the principle of keeping things at a good size, don’t plan the entire project
out ahead of time, but make sure to break things down into the groups of tasks that are
needed as you need them.  Following an agile approach, make sure you have a good idea of
what needs to be done for a given task group, and don’t worry about any more details of
it until you need to.  And when you reach that point, reverify the tasks before going
forward and flushing out the details.&lt;/p&gt;
&lt;p&gt;For this parser, the
&lt;a href="https://github.github.com/gfm"&gt;GitHub Flavored Markdown specification&lt;/a&gt; delineates it’s
groups by the features in Markdown that are implemented.  Aligning the groups specified
in that document with the groups for tests and development was a solid choice from a
tracking point of view.  One of the reasons that I feel this worked well is because
these feature groups have anywhere between 1 and 50 examples in each group.  While some
of the larger ones were a tiny bit too big, for the most part it was a manageable
number of scenarios to handle in each group.&lt;/p&gt;
&lt;h2 id="strategy-2-organize-those-task-groups-themselves"&gt;Strategy 2: Organize Those Task Groups Themselves&lt;a class="headerlink" href="#strategy-2-organize-those-task-groups-themselves" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Once the task groups have been identified, take a step back and organize those task
groups themselves.  There are almost always going to be task groups that have a natural
affinity to be with similar task groups, so do so.  By doing similar tasks in
groups, it will help identify refactorings that can be accomplished later, as well as
the efficiency benefits from repeating similar processes.  Especially with a larger
project, those little efficiency benefits can add up quickly.&lt;/p&gt;
&lt;p&gt;As with the previous strategy, the GitHub Flavored Markdown specification comes to the
rescue again.  There are some implementation notes near the end of the specification
that provide some guidance on grouping.  The groups that I recognized were container
blocks, normal blocks, and inline parsing.  Normal blocks are the foundation of the
parsing, so it made sense to schedule those first.  Container blocks (lists and block
quotes) add nesting requirements, so I scheduled those second.  Finally, once all of
the block level tasks are done, inline parsing (such as for emphasis) can be performed
on text blocks derived at after the processing of the normal and container blocks.
After re-reading the end of the specification, the example that they gave seemed to
indicate that as well, so I was probably on a decent path.&lt;/p&gt;
&lt;h2 id="strategy-3-kiss"&gt;Strategy 3: K.I.S.S.&lt;a class="headerlink" href="#strategy-3-kiss" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As I mentioned in the last article, I am a big proponent of the
&lt;a href="https://en.wikipedia.org/wiki/KISS_principle"&gt;K.I.S.S principle&lt;/a&gt;.
While I usually arrive at an end project that has lots of nice classes and functions,
worrying about that at an early stage can often be counter productive.  Even if it means
doing ugly string manipulations with variable names that you know you will change, that
approach can often lead to cleaner code faster.  Worry about getting the logic and the
algorithms right first, and then worry about making it “look pretty”.&lt;/p&gt;
&lt;p&gt;A good example of this is my traditional development practice of giving variables and
functions “garbage names” until I am finished with a set of functions.  Yes, that means
during development I have variable names like “foobar”, “abc”, “sdf”, and “ghi”, just to
name a few of them.  When I am creating the function, I maintain a good understanding of
what the variables are doing, and I want to concentrate on the logic.  Once the logic
is solid, I can then rename the variables to a descriptive name that accurately
reflects it’s purpose and use.&lt;/p&gt;
&lt;p&gt;I am not sure if this process works for everyone, but for me, not focusing on the names
helps me focus on the logic itself.  I also find that having a “naming pass” at the
function when I am done with the work helps me to give each variable a more meaningful
name before I commit the changes.  Once again, this is one of my development practices
that helps boost my productivity, and I acknowledge it might not work for everyone.&lt;/p&gt;
&lt;p&gt;For the parser, I employed this strategy whole-heartedly.  The first couple of groups of
work on the parser were performed by dealing with strings, with the only class for the
parser being the single class containing the parsing logic.  Once I got to a good point
(see above), I moved a number of the parsing functions and html functions into their
own static helper modules.  Up until that point, it was just simpler to be creative
with the logic in a raw form.  After that point, it made more sense to identify and
solidify the logic that encapsulated some obvious patterns, moving those algorithms
into their own classes for easy identification.&lt;/p&gt;
&lt;p&gt;As with many things, finding the right points to perform changes like this are difficult
to describe.  I can only say that “it felt like the right time for that change”.  And as
I commit and stage code frequently, if I made a mistake, I could easily rewind and
either retry the change, or abandon it altogether.&lt;/p&gt;
&lt;h2 id="strategy-4-use-lots-of-debug-output"&gt;Strategy 4: Use Lots of Debug Output&lt;a class="headerlink" href="#strategy-4-use-lots-of-debug-output" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;There is a phrase that we use at work called “TTR” or Time-To-Resolution.
This is usually measured as the time taken from knowing that you have a problem until
the time that the problem is resolved and it’s solution is published.  Added during
development and debugging, spurious debug output can help provide a journal or log of
what is happening in the project, allowing for a more comprehensive comparison of the
 output of a passing test with the output of a failing test at the same time.  &lt;/p&gt;
&lt;p&gt;To be clear, using a debugger to load the code and step through it as it executes is
another way to debug the code.  In fact, in a fairly decent number of situations I
recommend that.  However, I find that the downside is that I don’t get to see the
flow through the code in the same way as with lots of debug statements.  As with a
lot of things, determining the balance between debug output and using a debugger
will differ for individual developers and for individual projects.&lt;/p&gt;
&lt;p&gt;Another benefit of the debug output approach is the transition from debug output to
logging.  Once the project has been sufficiently stabilized and completed, one of the
tasks that
arises is usually to output useful log messages at various points throughout the code.
I personally find that a certain percentage of the debug output that was good enough to
emit during development can become quality log messages with only small changes.&lt;/p&gt;
&lt;p&gt;The parser development definitely benefitted from this strategy.  Within a given task
group, there were often two Markdown patterns that were almost the same.  Sometimes it
looked like they should being parsed differently and sometimes I couldn’t figure out
why they weren’t parsed differently.  By examining the debug output for both cases,
I was able to verify whether or not the correct paths were followed, and if not, where
the divergences occurred.  Sure, the debug was cryptic and most of it never made it in
the final version of the parser. But when I needed to debug or verify during
development, it was invaluable.&lt;/p&gt;
&lt;h2 id="strategy-5-run-tests-frequently"&gt;Strategy 5: Run Tests Frequently&lt;a class="headerlink" href="#strategy-5-run-tests-frequently" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Don’t only run tests when a set of changes is ready to commit, run those tests
frequently during the development of each task.  If done properly, most tests are there
to verify things are as they should be, and to warn of changes or situations that fall
outside of the requirements. If something is wrong, it is better to look through the
last feature added to determine what the problem is, rather than trying to determine
which of the last 5 features introduced that bad behavior.  Therefore, by executing the
tests frequently, either the confidence that the project is working properly increases
or there are early and frequent indications that something is wrong.&lt;/p&gt;
&lt;p&gt;During the development of the parser, the tests were instrumental in making sure that
I knew what features were “locked down” and which features needed work.  By keeping
track of that when adding a new feature, I could easily see when work on a new feature
caused a previously completed feature to fail it’s tests.  At that point, I knew I
didn’t have the right solution, but I also had confidence that the changes were small
enough to handle.&lt;/p&gt;
&lt;p&gt;Also, as the specification is large, there were often cases that were present but not
always spelled out in the documentation as well as they could have been.  However, time
and time again, the saving grace for the specification were the examples, now scenarios
and scenario tests in my project, sterling examples of what to expect.  And as I took
care to make sure they ran quickly, I was able to run all of the scenario tests in less
than 10 seconds.  For me, taking 10 seconds to ensure things were not broken was well
worth the cost.&lt;/p&gt;
&lt;h2 id="strategy-6-do-small-refactors-only-at-good-points"&gt;Strategy 6: Do Small Refactors Only At Good Points&lt;a class="headerlink" href="#strategy-6-do-small-refactors-only-at-good-points" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While this strategy may look like a repeat of
&lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/#strategy-0a-suppress-major-issues-until-later"&gt;Strategy 0A: Suppress Major Issues Until Later&lt;/a&gt;,
the scope for this strategy is on a smaller, more local level.  Where Strategy 0A talks
about refactoring major issues later, there are often obvious minor refactors that can
be done at a local level.  These changes are often done right after a function is
written to fulfil a feature and rarely includes more than one function.  A good example
of this is taking a function that performs a given action twice with small variations
and rewriting that function by encapsulating that repeated action into it’s own
well-named function.  &lt;/p&gt;
&lt;p&gt;While such refactors almost always improve the code, care must be taken to strike a
good balance between making each method more readable and trying to optimize the
function ahead of time.  For myself, it is often more efficient for me to see the raw
code to recognize patterns from rather than already refactored code.  Unless I am the
author of the refactored code, I find that I don’t see the same patterns as with the
raw code.  As with many things, “Your Mileage May Vary”.&lt;/p&gt;
&lt;p&gt;When implementing the parser, this strategy was effectively applied at the local
level to improve readability and maintainability.  There were quite a few cases where
the logic to detect a given case and the processing of that case were complicated.
By assigning the detection of a given case to one function and the processing of that
case to another function, the border between the two concepts was enhanced, making the
calling function more readable.  As this kind of refactoring occurred at the local
level, it employed this strategy quite effectively.&lt;/p&gt;
&lt;h3 id="how-did-this-help"&gt;How Did This Help?&lt;a class="headerlink" href="#how-did-this-help" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;For one, I had a plan and a strategy to deal with things.  As always, something would
happen during development which would require me to re-assess something. Given the
above strategy, I had confidence that I would be able to deal with it, adjusting the
different parts of the project as I went.&lt;/p&gt;
&lt;p&gt;Basically, I took a boulder (writing a parser) and not only broke it down into pebbles
(tasks needed to write the parser), but came up with a set of rules (strategy) on what
to do if I found some rocks that were previously unknown or larger than a pebble.  As
I mentioned at the start of the article, it’s a fairly simple bit of wisdom that I was
taught, but what a gem it is!&lt;/p&gt;
&lt;h2 id="what-comes-next"&gt;What Comes Next?&lt;a class="headerlink" href="#what-comes-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the next article, I take the requirements, scenarios,
and strategies and put them together to start writing the parser.  As one of the
test groups that I came up with was normal Markdown blocks, I will describe how I
implemented those blocks as well as the issues I had in doing so cleanly.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Setting Up Parser Tests</title><link href="https://jackdewinter.github.io/2019/12/16/markdown-linter-setting-up-parser-tests/" rel="alternate"></link><published>2019-12-16T00:00:00-08:00</published><updated>2019-12-16T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2019-12-16:/2019/12/16/markdown-linter-setting-up-parser-tests/</id><summary type="html">
&lt;h2 id="sidebar"&gt;Sidebar&lt;a class="headerlink" href="#sidebar" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;My apologies for this being a day or two later that usual.  My son brought home a
cold that knocked the stuffing out of me, I needed to take some personal time to ensure
I was feeling better before writing.  Thanks for your patience.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As a reminder of …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="sidebar"&gt;Sidebar&lt;a class="headerlink" href="#sidebar" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;My apologies for this being a day or two later that usual.  My son brought home a
cold that knocked the stuffing out of me, I needed to take some personal time to ensure
I was feeling better before writing.  Thanks for your patience.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As a reminder of the requirements from the
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;last article&lt;/a&gt;,
the big bullet-point items are:
command line driven, GitHub Flavored Markdown (for now), and preserving all tokens.  To
make sure I have a solid set of goals to work towards, setting these requirements as
part of the project was pivotal.  Now that I have that as a touchstone, I need to move
forward with defining how to progress with the testing of the parser at the core of
the linter.&lt;/p&gt;
&lt;h2 id="why-write-a-parser"&gt;Why Write a Parser?&lt;a class="headerlink" href="#why-write-a-parser" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In taking a look at the kind of rules that linters support, I have observed that there
are typically two categories of rules: general rules and grammar rules.  For general
rules such as “tabs should not be used”, it is easy to look at any line in the
document being scanned and look for a tab character.  For grammatical rules such
as “headings should always be properly capitalized”, that scan is more difficult.
The most difficult part of that rule is identifying whether or not any given piece
of text is considered part of a header, thus engaging the rest of the rule.&lt;/p&gt;
&lt;p&gt;From experience, to properly determine which part of grammar maps to which part of text
requires a capable parser, written to the specifications of the language to be parsed.
Based on my research from the
&lt;a href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/"&gt;last article&lt;/a&gt;,
all of the parsers that I found only translated Markdown into HTML, not any
intermediate form.  Since I need a clean stream of tokens before translation to HTML,
the only option is to write my own parser which will output a clean stream of parsed
Markdown tokens.&lt;/p&gt;
&lt;p&gt;As I am writing my own parser, I need to have a good set of tests to ensure
that the parser works properly.  But where to start?&lt;/p&gt;
&lt;h2 id="where-to-start-with-the-tests"&gt;Where To Start With The Tests?&lt;a class="headerlink" href="#where-to-start-with-the-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Referring back to my article on &lt;a href="https://jackdewinter.github.io/2019/11/10/software-quality-reliability/"&gt;software reliability&lt;/a&gt;,
the 2 main types of tests that I need to decide on are scenario tests and unit tests.
In a nutshell, the purpose of a scenario test is to test the input and outputs of the
project and the purpose of a unit test is to test a specific function of a specific
components of the project.  Getting a hold of how to balance the quantity of tests that
I need to write between the two of these types is my first priority.&lt;/p&gt;
&lt;p&gt;As one of the initial requirements is to support the
&lt;a href="https://github.github.com/gfm"&gt;GitHub Flavored Markdown specification&lt;/a&gt;, it is useful to
note that the specification itself has 637 individual examples.  Each example provides
for the input, in Markdown, and the output, in HTML.  While the output is not at the
token level needed to satisfy my project’s third requirement, it should be close
enough.  In looking at each of these examples, I need a solid set of rules that I
can apply to the tokens to get them from my desired token-based output to a HTML-based
output that matches the examples.  It is reasonable to collect these rules as I go when
I develop the various types of elements to be parsed.  If I tried to do them to far
ahead of time, it would invariably lead to a lot of rework.  Just in time is the way to
go for these rules.&lt;/p&gt;
&lt;p&gt;Taking another looking at the types of tests that I need to write, I realized that this
project’s test viewpoint was inverted from the usual ratio of scenario tests to unit
tests.  In most cases, if I have anything more than 20-30 scenario tests, I would think
that I have not properly scoped the project.  However, with 637 scenarios already
defined for me, it would be foolish not to write at least one scenario test for each of
those scenarios, adding extra scenario tests and supportive unit tests where needed.
In this case, it makes more sense to focus on the scenario tests as the major set of
tests to write.&lt;/p&gt;
&lt;p&gt;The balance of scenario tests to unit tests?&lt;/p&gt;
&lt;p&gt;Given 637 scenarios ready to go, I need to create at least 637 scenario tests.
For those scenario tests, experimenting with the first couple of scenario tests to
find a process that worked seemed to be the most efficient way forward.  Given a simple
and solid template for every scenario test, I had a lot of confidence to then use that
template for each scenario test that I tackled.&lt;/p&gt;
&lt;p&gt;And the unit tests?  In implementing any parsing code, I knew that I needed helper
functions that parsed a specific type of foundational thing, like a tag in an HTML
block or skipping ahead over any whitespace.  The unit tests are used to verify
that those kind of foundational functions are operating properly, ensuring that the
rest of the code can depend on those foundations with confidence.  As an added bonus,
more combinations of the various sequences to parse could be tested without inflating
the number of scenario tests.&lt;/p&gt;
&lt;p&gt;Ground rules set?   Check.  On to the first scenario test.&lt;/p&gt;
&lt;h2 id="starting-with-the-first-scenario-test"&gt;Starting With the First Scenario Test&lt;a class="headerlink" href="#starting-with-the-first-scenario-test" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While it might not seem correct, starting with example number 189, the first test I
did write was for
&lt;a href="https://github.github.com/gfm/#example-189"&gt;GitHub Flavored Markdown example 189&lt;/a&gt;,
the first example
included in the specification for the paragraph blocks.  After solidly reading the
specification, the general rule seemed to be that if it doesn’t fit into any other
category, it is a paragraph.  If everything is going to be a paragraph until the other
features are written, I felt that starting with the default case was the right choice.&lt;/p&gt;
&lt;p&gt;After a number of passes at cleaning up the test for this first case, it boiled down to
the following Python code.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;https://github.github.com/gfm/#paragraphs&lt;/span&gt;
&lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pymarkdown.tokenized_markdown&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.utils&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_paragraph_blocks_189&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 189:  simple case of paragraphs&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;tokenizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""aaa&lt;/span&gt;

&lt;span class="s2"&gt;bbb"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[para:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text:aaa:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[BLANK:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[para:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text:bbb:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="breaking-down-the-scenario-test"&gt;Breaking Down the Scenario Test&lt;a class="headerlink" href="#breaking-down-the-scenario-test" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;It might be a lot to take in all at once, so let’s break it down step by step.&lt;/p&gt;
&lt;h3 id="start-of-the-module"&gt;Start of the Module&lt;a class="headerlink" href="#start-of-the-module" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The start of the module needs to perform two important tasks: provide useful
documentation to someone examining the tests and import any libraries needed.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;https://github.github.com/gfm/#paragraphs&lt;/span&gt;
&lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;pymarkdown.tokenized_markdown&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;

&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;.utils&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The most useful and relevant information about the module that I was able to think of
was the actual source for the test cases themselves.  That being the case, I felt that
including the URI to the specific section in the
&lt;a href="https://github.github.com/gfm"&gt;GitHub Flavored Markdown specification&lt;/a&gt; was the
right choice for the module documentation.  For anyone reading the tests, it provides a
solid reference point that answers most of the questions about why the tests are there
and whether or not the tests are relevant.&lt;/p&gt;
&lt;p&gt;Next are the import statements.  The first one statement imports the
&lt;code&gt;TokenizedMarkdown&lt;/code&gt; class, a class that I set up to handle the parsing.  Initially this
class was a quick and simple skeleton class, especially for the first paragraph case.
However, it provided the framework for me to support more use cases while maintaining
a uniform interface. The second import statement is used to include a function that
provides a good comparison of the contents of the list returned from the &lt;code&gt;transform&lt;/code&gt;
function of the &lt;code&gt;TokenizedMarkdown&lt;/code&gt; class and a simple text list of the expected
tokens.  &lt;/p&gt;
&lt;h3 id="arrange-the-data-for-the-test"&gt;Arrange The Data For The Test&lt;a class="headerlink" href="#arrange-the-data-for-the-test" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;From all of the useful pieces of information that I have learned about testing, the
most useful bits about actually writing tests are the K.I.S.S. principle and the use of
the Arrange-Act-Assert pattern.  The
&lt;a href="https://en.wikipedia.org/wiki/KISS_principle"&gt;K.I.S.S principle&lt;/a&gt; constantly reminds me
to not overcomplicate things, reducing the tests to what is really relevant for that
thing or task.  The
&lt;a href="https://docs.telerik.com/devtools/justmock/basic-usage/arrange-act-assert"&gt;Arrange-Act-Assert pattern&lt;/a&gt;
reminds me that when writing tests, each test I write breaks down into setup, action,
and verification (with cleanup occasionally being added if needed). As such, I always
start writing my tests by adding a comment for each of those sections, with the rest
of the function blank.  Once there, it’s easy to remember which parts of the tests
go where!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;test_paragraph_blocks_189&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="sd"&gt;"""&lt;/span&gt;
&lt;span class="sd"&gt;    Test case 189:  simple case of paragraphs&lt;/span&gt;
&lt;span class="sd"&gt;    """&lt;/span&gt;

    &lt;span class="c1"&gt;# Arrange&lt;/span&gt;
    &lt;span class="n"&gt;tokenizer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TokenizedMarkdown&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="n"&gt;source_markdown&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;"""aaa&lt;/span&gt;

&lt;span class="s2"&gt;bbb"""&lt;/span&gt;
    &lt;span class="n"&gt;expected_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;
        &lt;span class="s2"&gt;"[para:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text:aaa:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[BLANK:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[para:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[text:bbb:]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="s2"&gt;"[end-para]"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Arrange&lt;/code&gt; part of this test is simple, consisting mostly of easy-to-read
assignments.  The object to test needs to be setup in a way that it is completely
enclosed within the test function.  The tokenizer object with no options is assigned to
the &lt;code&gt;tokenizer&lt;/code&gt;, so a simple assignment takes care of it’s setup.  The &lt;code&gt;source_markdown&lt;/code&gt;
variable is setup within Python’s
&lt;a href="https://docs.python.org/3/tutorial/introduction.html#strings"&gt;triple-quotes&lt;/a&gt;
to preserve newlines and provide an accurate look at the string being fed to the
tokenizer.  This string is copied verbatim from the example represented by the function,
in this case &lt;a href="https://github.github.com/gfm/#example-189"&gt;example 189&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The final setup, the array assigned to the &lt;code&gt;expected_tokens&lt;/code&gt; variable, takes a bit more
work.  When I wrote these, I sometimes wrote the expect tokens ahead of time, but more
often than not used a known “bad” set of tokens and adjusted the tokens as I went.&lt;/p&gt;
&lt;h3 id="act-tokenize-and-assert-verify-results"&gt;Act (Tokenize) and Assert (Verify Results)&lt;a class="headerlink" href="#act-tokenize-and-assert-verify-results" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;With all of the work on the setup of the tests, the Act and Assert parts of the test
are very anticlimactic.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="c1"&gt;# Act&lt;/span&gt;
    &lt;span class="n"&gt;actual_tokens&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tokenizer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;transform&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;source_markdown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Assert&lt;/span&gt;
    &lt;span class="n"&gt;assert_if_lists_different&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expected_tokens&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;actual_tokens&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Using the information that was established in the Arrange section of the test, the
Act section simply applies the input (&lt;code&gt;source_markdown&lt;/code&gt;) to the object to test
(&lt;code&gt;tokenizer&lt;/code&gt;) and collects the output in &lt;code&gt;actual_tokens&lt;/code&gt;.  The Assert section then
takes the output tokens and compares them against the expected list of tokens in
&lt;code&gt;expected_tokens&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="why-not-use-pure-test-driven-development"&gt;Why Not Use Pure Test Driven Development?&lt;a class="headerlink" href="#why-not-use-pure-test-driven-development" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;In a normal project, I usually follow
&lt;a href="https://en.wikipedia.org/wiki/Test-driven_development"&gt;Test Driven Development&lt;/a&gt;
practices quite diligently, either writing the tests first and code second, or writing
both tests and code at the same time.  As this was my first version of my first
Markdown parser, I was aware that I was going to be adapting the tokens and token
formats as I went, eventually arriving at a set of tokens that worked for all scenarios.
Knowing that this churn was part of the development process for this project, I decided
that a true Test Driven Development process would not be optimal.&lt;/p&gt;
&lt;p&gt;For this project, it was very useful to adjust the process.  The balance that I struck
with myself was to make sure that as I coded the parser to respond to a given scenario,
I adjusted the tokens assigned to the &lt;code&gt;expected_tokens&lt;/code&gt; variable based on the example’s
HTML output for the equivalent scenario test.  This process gave me the confidence to
know that as I made tests pass by enabling the code behind the scenario, each individual
passing test was both moving towards a fully functioning parser and protecting the work
that I had already done in that direction.&lt;/p&gt;
&lt;p&gt;To be clear, as I copied the template over, I adjusted the function name, the
function’s doc-string, and the Markdown source text based on the scenario test that I
was implementing.  The list of tokens in &lt;code&gt;expected_tokens&lt;/code&gt; were then populated with
a “best guess” before I started working on the code to make that scenario pass.
In a microscopic sense, as I updated the test and the test tokens before starting on
the code, I was still adhering to Test Driven Development on a scenario-by-scenario
level.&lt;/p&gt;
&lt;p&gt;To me, this was a good balance to strike, evaluating the correct tokens as I went
instead of trying to work out all 637 sets of tokens ahead of time.  &lt;/p&gt;
&lt;h3 id="how-did-this-help"&gt;How Did This Help?&lt;a class="headerlink" href="#how-did-this-help" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Getting a good process to deal with the large bulk of scenario tests was a welcome
relief.  While I still needed to create a strategy to deal with that bulk of scenario
tests I would need to write (see the
&lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/"&gt;next article&lt;/a&gt;
for details on that), I had a
solid template that was simple (see K.I.S.S. principle), easy to follow (see
Arrange-Act-Assert pattern), and would scale.  This was indeed something that I
was able to work with.&lt;/p&gt;
&lt;h2 id="what-about-the-unit-tests"&gt;What About the Unit Tests?&lt;a class="headerlink" href="#what-about-the-unit-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Compared to the scenario tests, writing unit tests for the parser’s foundation
functions was easy.  In each case, there is a function to test with a very cleanly
specified interface, providing for a clean definition of expected input and output.&lt;/p&gt;
&lt;h2 id="what-comes-next"&gt;What Comes Next?&lt;a class="headerlink" href="#what-comes-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the &lt;a href="https://jackdewinter.github.io/2019/12/22/markdown-linter-parser-testing-strategy/"&gt;next article&lt;/a&gt;,
I look at the work that needs to
be done and come up with general strategies that I use to implement the parser
required for the linter.  With the specification’s 637 examples as a base for the
scenario tests, good planning is needed to ensure the work can progress forward.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Markdown Linter - Collecting Requirements</title><link href="https://jackdewinter.github.io/2019/12/08/markdown-linter-collecting-requirements/" rel="alternate"></link><published>2019-12-08T00:00:00-08:00</published><updated>2019-12-08T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2019-12-08:/2019/12/08/markdown-linter-collecting-requirements/</id><summary type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;My website is now up and running, even though in my mind it took forever.  To make sure
everything was “just so”, I went through each article with a fine-toothed comb multiple
times, each with a slightly different thing I was looking for.  In the end, it worked
out …&lt;/p&gt;</summary><content type="html">
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;My website is now up and running, even though in my mind it took forever.  To make sure
everything was “just so”, I went through each article with a fine-toothed comb multiple
times, each with a slightly different thing I was looking for.  In the end, it worked
out, but I wished I could have automated at least some of that work and reduced the time
it took to do it.  And I also have a lingering question of whether or not I got
everything, or did I miss something out?&lt;/p&gt;
&lt;h2 id="what-is-a-linter"&gt;What Is a Linter?&lt;a class="headerlink" href="#what-is-a-linter" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A long time ago, when I first heard the term “lint”, I thought someone was referring to
the stuff that you find in the clothes dryer trap that you need to clean out.  According
to &lt;a href="https://en.wikipedia.org/wiki/Lint_(software)"&gt;Wikipedia&lt;/a&gt;, my guess was close.
Similar to the “undesirable bits of fiber and fluff found in sheep’s wool” from the
Wikipedia article, software linters are used to detect undesirable practices and
patterns in the objects they scan.  Once pointed out, the development team can then
decide whether or not to address the issue or ignore the issue.&lt;/p&gt;
&lt;h2 id="doing-my-research"&gt;Doing My Research&lt;a class="headerlink" href="#doing-my-research" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I started looking around, and even though there are a number of Markdown-to-HTML command
line programs out there, finding a solid Markdown linter was another story.  I did find
a couple of starts at making one, but not a finished one that I could use.  The only
exception was the NPM-based
&lt;a href="https://marketplace.visualstudio.com/items?itemName=DavidAnson.vscode-markdownlint"&gt;Markdownlint&lt;/a&gt;
by David Anson.  This VSCode plugin is pretty much a standard for anyone creating
content in Markdown using VSCode, with well over 1.3 million downloads as of the writing
of this article.  By default, as you save articles, this linter executes and produces a
list of issues in the &lt;code&gt;Problems&lt;/code&gt; section at the bottom of the VSCode editor.&lt;/p&gt;
&lt;p&gt;This tool is indeed handy while writing an article, but the act of verifying multiple
articles becomes a bit of chore.  My general process was to open a document I wanted to
inspect, make a small whitespace changes, save the file, and examine the &lt;code&gt;Problems&lt;/code&gt;
section to see what the linter came up with.  Two things were more annoying about this
process that others.  The first issue is that any issue for any file that is open is
displayed in that section.  If I wanted to be efficient, it meant closing every other
file and just working on a single file at a time.  The second issue is that other
plugins write their problems there as well.  As a lot of my content is technical, there
are a fair number of spelling issues that arise that I need to ignore.  Once again,
neither one of these issues is a bad thing, just annoying.&lt;/p&gt;
&lt;h2 id="what-are-the-requirements"&gt;What Are The Requirements?&lt;a class="headerlink" href="#what-are-the-requirements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Doing some thinking about this during the couple of weeks that I worked on the website,
a fairly decent set of requirements crystalized:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;must be able to see an accurate tokenization of the markdown document before translating to HTML&lt;ul&gt;
&lt;li&gt;working with an accurate tokenization remedies any translation problems instead of translating from HTML&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;all whitespace must be encoded in that token stream as-is&lt;ul&gt;
&lt;li&gt;for consistency, want an exact interpretation&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;initial tokenization for GitHub Flavored Markdown only, add others later&lt;ul&gt;
&lt;li&gt;initial tests against the &lt;a href="https://github.github.com/gfm/"&gt;GitHub Flavored Markdown specs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;plans to later add other flavors of parser&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;must be able to provide a consistent lexical scan of the Markdown document from the command line&lt;ul&gt;
&lt;li&gt;clean feedback on violations&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;extending the base linting rules should require very little effort&lt;ul&gt;
&lt;li&gt;clear support for adding custom linting rules.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;written in Python&lt;ul&gt;
&lt;li&gt;good cross-platform support&lt;/li&gt;
&lt;li&gt;same language as Pelican, used as the
  &lt;a href="https://jackdewinter.github.io/2019/08/18/static-websites-choosing-a-static-web-site-generator/"&gt;Static Site Generator&lt;/a&gt; for my website&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While there are only 5 requirements, they are important.  The first two requirements
speak to reliability: the parsed Markdown tokens should be complete. The third
requirement is for stability: write against one specification with a solid set of test
cases before moving on to others.  The fourth requirement is all about usability: the
linter can be run from any appropriate command line.  Finally, the fifth requirement is
about extensibility:  add any needed custom rules.&lt;/p&gt;
&lt;p&gt;From my point of view, these requirements help me visualize a project that will help me
maintain my website by ensuring that any articles that I write conform to a simple set
of rules.  Those rules can be checked by a script before I commit them, without having
to load up a text editor.  Simple.&lt;/p&gt;
&lt;h2 id="why-is-this-important-to-me"&gt;Why Is This Important To Me?&lt;a class="headerlink" href="#why-is-this-important-to-me" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Writing this section, it took me a couple of tries to word this properly.  In the end, I
settled on a basic phrase:  It is a tool that I can use to make a software project
better.&lt;/p&gt;
&lt;p&gt;In other parts of my professional life, I take a look at things such as a Java project,
and try and improve the quality of that project.  The input is mainly Java source code
and the output is mainly JAR files that are executed by a JVM.  My website is no
different.  Remove Java source code and insert Markdown documents.  Remove JAR files
executed by a JVM and insert HTML files presented by a browser.  There are a few
differences between the two types of projects, but in all of the important ways, they
are the same.&lt;/p&gt;
&lt;p&gt;I took the time to manually scan each article for my website multiple times before I
did my website’s soft release.  To me, it just makes sense that there should be an
easier way to perform that process.  Easier in terms of time, and easier in terms of
consistency.  Unless I am missing something out there in the Internet, the only project
that came close to fulfilling my requirements was &lt;code&gt;Markdownlint&lt;/code&gt;, and it still had some
things missing.  I came to the realization that to be able to lint a Markdown file
against a set of rules, I was going to have to write my own Markdown parser.&lt;/p&gt;
&lt;p&gt;In the last couple of decades of professional life, I have written many parsers, so that
part of the project doesn’t scare me.  Due to the great works of the people at the
&lt;a href="https://github.github.com/gfm/"&gt;GFM site&lt;/a&gt;, there we a solid number of test cases that I
can test the parser against.  The extensibility issue would make me look at different
ways to integrate code into my tool, so a plus there.  All in all, a decent number of
things I have to get right, but nothing too far out of my field of experience.&lt;/p&gt;
&lt;p&gt;Sure it would be hard in places… but also a challenge!  Just the kind of thing I like!&lt;/p&gt;
&lt;h2 id="what-comes-next"&gt;What Comes Next?&lt;a class="headerlink" href="#what-comes-next" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;In the &lt;a href="https://jackdewinter.github.io/2019/12/16/markdown-linter-setting-up-parser-tests/"&gt;next article&lt;/a&gt;, I start breaking down the
requirements for the Markdown parser and document how I will setup the tests for it.
As I am parsing a well-known format with varying implementations already available, it
is important to stay focused on one implementation and have a solid set of tests to
ensure I don’t go backwards in my development.&lt;/p&gt;</content><category term="Software Quality"></category><category term="markdown linter"></category></entry><entry><title>Software Quality: Reliability</title><link href="https://jackdewinter.github.io/2019/11/10/software-quality-reliability/" rel="alternate"></link><published>2019-11-10T00:00:00-08:00</published><updated>2019-11-10T00:00:00-08:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2019-11-10:/2019/11/10/software-quality-reliability/</id><summary type="html">
&lt;p&gt;In the main article titled &lt;a href="https://jackdewinter.github.io/2019/09/15/what-is-software-quality/"&gt;What is Software Quality?&lt;/a&gt;, I
took a high level look at what I believe are the 4 pillars of software quality.  This article
will focus specifically on the Reliability pillar, with suggestions on how to measure
Reliability and how to write good requirements for this …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;In the main article titled &lt;a href="https://jackdewinter.github.io/2019/09/15/what-is-software-quality/"&gt;What is Software Quality?&lt;/a&gt;, I
took a high level look at what I believe are the 4 pillars of software quality.  This article
will focus specifically on the Reliability pillar, with suggestions on how to measure
Reliability and how to write good requirements for this pillar.&lt;/p&gt;
&lt;h2 id="introduction"&gt;Introduction&lt;a class="headerlink" href="#introduction" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;From the main article on
&lt;a href="https://jackdewinter.github.io/2019/09/15/what-is-software-quality/"&gt;What is Software Quality?&lt;/a&gt;,
the essence of this pillar can be broken down into two questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the software do the task that it is supposed to do?&lt;/li&gt;
&lt;li&gt;Does the software execute that task in a consistent manner?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This article will take an in-depth look at common types of tests, discussing how those
tests can help us gather the information necessary to answer those questions.  At
the end of this article, the section
&lt;a href="https://jackdewinter.github.io/2019/11/10/software-quality-reliability/#how-to-measure-reliability"&gt;How To Measure Reliability&lt;/a&gt; will use that information to provide a cohesive answer
to those questions.&lt;/p&gt;
&lt;h2 id="how-does-testing-help-measure-reliability"&gt;How Does Testing Help Measure Reliability?&lt;a class="headerlink" href="#how-does-testing-help-measure-reliability" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As discussed in the main article’s section on
&lt;a href="https://jackdewinter.github.io/2019/09/15/what-is-software-quality/#Reliability"&gt;Reliability&lt;/a&gt;,
many articles on testing and reliability refer to a test pyramid that defines the 4
basic types of reliability tests: unit tests, functional/integration tests, scenario
tests, and end-to-end tests.  While those articles often have slightly different takes
on what the pyramid represents, a general reading of most of those articles leaves me
with the opinion that each test in each section of the pyramid must pass every time.
With tests and reliability being closely related, it is easy for me to draw the
conclusion that if tests must pass every time, then reliability is a binary choice:
they all pass and the project is reliable, or one or more fail and the project is not
reliable.&lt;/p&gt;
&lt;p&gt;As such, my main question is: Does it have to be a
binary choice?  Are the only two choices that either all tests did pass or all tests did
not pass? If the answer to that question is a binary answer, then the answer is simple:
it is either 100% reliable or 0% reliable.  More likely, there are other answers that
will give use a better understanding of how to measure reliability and how to interpret
those measurements.&lt;/p&gt;
&lt;h2 id="can-we-identify-groups-of-tests"&gt;Can We Identify Groups of Tests?&lt;a class="headerlink" href="#can-we-identify-groups-of-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before determining whether or not reliability is a binary choice, I feel that it is important
to make some foundational decisions on how to measure reliability based on the types of tests
that are already identified.  To aid in making those decisions, it helps to examine the four
categories of tests, looking for groupings between them.&lt;/p&gt;
&lt;p&gt;&lt;img alt="test pyramid" src="https://jackdewinter.github.io/images/quality-1/test-pyramid.png"/&gt;&lt;/p&gt;
&lt;p&gt;Using the definitions established in the main article, unit tests are used to test
the reliability of individual software components and functional tests are used to test the
reliability of more than one of those components working together.  Both of these categories
are used to determine the reliability of the components themselves, and not their objectives.
As such, they make for a good grouping as they have a common responsibility: technical
reliability.&lt;/p&gt;
&lt;p&gt;Observing the scenario tests and end-to-end tests through a similar lens, those tests are used to
determine whether or not the software project meets its business requirements.  The end-to-end tests are often a set of
tests that are very narrow and deep of purpose.   At a slightly lower level, the scenario
tests provide extra support to those end-to-end tests by breaking those “bulky” end-to-end
tests into more discrete actions matched to the overall business use cases for the project.
A good grouping for these tests is by what they: business reliability.&lt;/p&gt;
&lt;p&gt;Another way to think about it is to view the groups of tests in terms of whether or not they
are inside or outside of the
&lt;a href="https://www.techopedia.com/definition/3552/black-box-testing"&gt;black box&lt;/a&gt;
that is the software project.  The first group of tests verify the inside of that black box,
ensuring that all of the technical requirements or “what needs to be done to meet
expectations” are met.  The second group of tests verify the outside of that black box,
ensuring that all of the business requirements or “what is expected of the project” are met.&lt;/p&gt;
&lt;p&gt;[Add picture of pyramid showing inside and outside?]&lt;/p&gt;
&lt;h2 id="give-me-an-example"&gt;Give Me an Example&lt;a class="headerlink" href="#give-me-an-example" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For the follow sections, I use the example of a simple project that uses a data store to
keep track of contact information. By providing a simple example that most developers have
encountered before, my hope is that it will make it easier for the reader to picture the
different types of tests and how they will interact with their team’s project.  As I
examine each type of tests, I try and explain my thinking on what I write and how
I write it for that group of tests, hoping to guide others on making better decisions
for their testing strategy.&lt;/p&gt;
&lt;p&gt;Note that I do not believe that the definition of “data store” is relevant to the example,
therefore the definition of “data store” is left up to the reader’s imagination and
experience.&lt;/p&gt;
&lt;h3 id="end-to-end-tests"&gt;End-To-End Tests&lt;a class="headerlink" href="#end-to-end-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Starting at the top of test pyramid, each end-to-end test needs to be a solid,
representative test of the main focus of the project itself.  These tests are usually a
small set of tests meant as a solid litmus test on whether the software project is
reliably meeting the requirements of the project.  In forming the initial end-to-end
tests, my intent is to start with a focus on positive cases which occur more than
60% of the time.&lt;/p&gt;
&lt;p&gt;For the example project, I started with a test to successfully add a new contact. As a
nice bonus, starting with that test allowed me to add the remove, list, and update
end-to-end tests, as they all need to add a new contact as a foundation of each of those
3 individual tests. Given my experience measuring quality, I believe that all of those
tests together provide that check with confidence for the example project.  If I had
found out
that the number of end-to-end tests I needed was more than a handful of tests, I would
have then examined the requirements and try to determine if the project had too many
responsibilities.  Doing this exercise with a new project often helps me figure out if
the project is properly scoped and designed, or if it requires further refinement.&lt;/p&gt;
&lt;p&gt;Having identified the end-to-end tests for a project and assuming that no further
refinement is necessary, I rarely write source code for these tests right away.  Most
of the time I just add some simple documentation to the project outlined in
&lt;a href="https://en.wikipedia.org/wiki/Pseudocode"&gt;pseudocode&lt;/a&gt; to capture that information.  I
find that the main benefit of doing this in the early stages is to provide a
well-defined high level goal that myself and my team can work towards. Even having rough
notes on what the test will eventually look like can help the team work towards that
goal of a properly reliable project.&lt;/p&gt;
&lt;h3 id="scenario-tests"&gt;Scenario Tests&lt;a class="headerlink" href="#scenario-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Still on the outside of the box, I then add a number of scenario tests to expand on the
scope of each of end-to-end tests.  For these tests, I focus on
&lt;a href="https://en.wikipedia.org/wiki/Use_case"&gt;use cases&lt;/a&gt;
that the user of the project will experience in typical scenarios. The intent here is to
identify the scenario tests that collectively satisfy 90% or more of the projected
business use cases for a given slice of the project.&lt;/p&gt;
&lt;p&gt;For the example project, adding a test to verify that I can successfully add a contact
was the first scenario test that I added.  I then added a scenario for the negative use
case of adding a contact and being told there are invalid fields in my request and a
third for a contact name that already existed.  Together, these scenarios met my bar for
the “add a contact” slice of the scenarios for the project.&lt;/p&gt;
&lt;p&gt;It is important to remember that these are tests that are facing the user and systems
they interact with. Unless there is a very strong reason to, I try and avoid scenario
tests that depend on any specific state of the project unless the test explicitly sets
that state up.  From my experience, such a dependency on external setup of state is very
fragile and hard to maintain.  It also raises the question on whether or not it is a
realistic or valuable test if that setup is not something that the project itself sets
up.&lt;/p&gt;
&lt;h4 id="why-only-those-3-scenario-tests"&gt;Why only those 3 scenario tests?&lt;a class="headerlink" href="#why-only-those-3-scenario-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Here is a simple table on what types of scenario tests to add that I quickly put
together for that project.  The estimates are just that, examples,  but helped me
determine if I hit the 90% mark I was aiming for.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Category&lt;/th&gt;
&lt;th&gt;Percentage&lt;/th&gt;
&lt;th&gt;Scenario&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Success&lt;/td&gt;
&lt;td&gt;60%&lt;/td&gt;
&lt;td&gt;Add a contact successfully to the project.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Bad/Invalid Data&lt;/td&gt;
&lt;td&gt;25%&lt;/td&gt;
&lt;td&gt;Add an invalid contact name and validate that a ValidateError response is returned.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Processing Error&lt;/td&gt;
&lt;td&gt;10%&lt;/td&gt;
&lt;td&gt;Add an contact name for an already existing contact and validate that a ProcessingError response is returned.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;I sincerely believe that between those 3 scenario tests, I can easily defend that they
represent 90%+ of the expected usage of the project for the specific task of adding a
contact. While the percentages in the table are
&lt;a href="https://en.wikipedia.org/wiki/Scientific_wild-ass_guess"&gt;swags&lt;/a&gt;
that seem to be “plucked out of thing air”, I believe they can be reasonably
defended&lt;sup id="fnref:defense"&gt;&lt;a class="footnote-ref" href="#fn:defense"&gt;1&lt;/a&gt;&lt;/sup&gt;.  This defense only needs to be reasonable enough to get the project
going. Once the project is going, real data can be obtained by monitoring and more
data-driven percentages can be used, if desired.&lt;/p&gt;
&lt;h4 id="how-did-i-get-there"&gt;How did I get there?&lt;a class="headerlink" href="#how-did-i-get-there" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;From experience, there are typically 4 groups of action results, and therefore,
scenarios: the action succeeded, the action failed due to bad data, the action failed
due to a processing error, or the action failed due to a system error.&lt;/p&gt;
&lt;p&gt;The first scenario test represents the first category.  Unless there was a good reason to
show another successful “add” use case, I will typically stick with a single “add” test.
As the goal is to achieve 90% of the typical use cases for the project, unless a
variant of that success case is justified by it’s potential contribution towards the 90%
total, it can be better performed by other tests.  In addition, tests on variations of
the input data are better performed by unit tests and functional tests, where executing
those tests have lower setup costs and lower execution costs.&lt;/p&gt;
&lt;p&gt;The second scenario test is used to satisfy the second group of tests where the data is
found to be bad or invalid. In general, I use these to test that there is consistent
error handling &lt;sup id="fnref:errorHandling"&gt;&lt;a class="footnote-ref" href="#fn:errorHandling"&gt;2&lt;/a&gt;&lt;/sup&gt; on the boundary between the user and the project.  At
this level, I ideally need only one or two tests to verify that any reporting of bad or
invalid data is being done consistently. By leaving the bulk of the invalid testing to
unit testing and/or functional testing, I can simulate many error conditions and check
them for consistent output at a low execution cost.  To be clear, if possible I try and
verify the general ability that consistent error handling is in place and not that a
specific instance of error is being reported properly.&lt;/p&gt;
&lt;p&gt;The third scenario test is used to verify the third group of tests where data is valid
but fails during processing.  Similar to the second group of tests, there is an
assumption that the reporting of processing errors should be done consistently.  However,
as most processing errors result due to a sequence of actions originating from the user,
representative types of processing errors should be tested individually.  The key to this
type of scenario tests is to represent processing errors that will help the group of
scenario tests hit that 90% mark.  Relating this to the example project, getting a
“already add a record with that name” response from the project is something that would
occur with enough frequency to qualify in my books.&lt;/p&gt;
&lt;p&gt;From experience, the fourth group of tests, testing for system errors, rarely makes it
to the level of a scenario test.  In this example, unless a system error is so
consistent that it was estimated to occur more than 10% of the time, a higher priority
is placed on the other types of responses.&lt;/p&gt;
&lt;p&gt;One of the exceptions to these generic rules are when a business requirement exists to
provide extra focus on a given portion of the interface.  These requirements are often
added to a project based on a past event, either in the project or in a related project.
As the business owners have taken the time to add the business requirement due to its
perceived priority, it should have a scenario test to verify that requirement is met.&lt;/p&gt;
&lt;p&gt;In the contact manager example, I made a big assumption that unless there were
requirements that stated otherwise, the data store is local and easy to reach.  If
instead we are talking about a project where the data is being collected on a mobile
device and relayed to a server, then a test in this last group of system errors would
increase in value.  The difference that this context introduces is that it is expected
that project will fail to reach the data store on a frequent basis, and hence, providing
a scenario for that happening helps us reach that 90% goal.&lt;/p&gt;
&lt;h3 id="commonalities-between-end-to-end-tests-and-scenario-tests"&gt;Commonalities between End-to-end tests and scenario tests&lt;a class="headerlink" href="#commonalities-between-end-to-end-tests-and-scenario-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While I took the long way around describing end-to-end tests and scenario tests, I
believe the journey was worth it.  These two types of tests test against the external
surface of the project, together painting a solid picture of what that external surface
will look like once the project is done.  For both of those tests, the project needs
clear business requirements on what benefit it provides to the user, which will be
highlighted by translating the requirements into the various tests.  By including either
actual data (for existing projects) or projected data (for new projects) on the usage
patterns for that project, the requirements can be prioritized to ensure the most
frequently used requirements are more fully tested.&lt;/p&gt;
&lt;p&gt;For each of those requirements and goals, the team can then set goals for the project
based on those documented requirements.  By codifying those goals and requirements with
end-to-end and scenario tests, you firm up those goals into something concrete.  Those
actions allow the team to present a set of tests or test outlines to the authors of the
requirements, validating that things are going in the right direction before writing too
much source code or setting up of interfaces with the user.  That communication and
changing the course before writing code can save a team hours, days, or weeks,
depending on any course changes discovered.&lt;/p&gt;
&lt;p&gt;What happens if the requirements change?  The project has a set of tests that
explicitly test against the outside of the box, and informs the team on what changes
will be needed if that requirement change is applied to the project.  At the very least,
it starts a conversation with the author of the requirement about what the external
surface of the project will look like before and after the change.  With that
conversation started, the team can have a good understanding of how things will change,
with some level of confidence that the change is the change specified by the
requirements author.&lt;/p&gt;
&lt;h3 id="unit-tests-and-functional-tests"&gt;Unit Tests and Functional Tests&lt;a class="headerlink" href="#unit-tests-and-functional-tests" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Transitioning to inside of the black box, unit tests and functional tests are more
understood by developers and more frequently used than end-to-end tests or scenario
tests. The unit tests isolate a single component (usually a class) and attempt to test
that each interface of that component and is functioning properly.  The functional tests
do the same thing, but with a single group of components that work together as a single
component rather than a single component itself.&lt;/p&gt;
&lt;p&gt;From an implementation point of view, the main difference is in how these tests are
created. Unit tests, as they are testing a single component, should only contain a
project reference to the one component being tested.  If the components are created
properly and have a good separation from the rest of the project, this should be
achievable for a good number of
components for the project, especially the support components.  Therefore, the degree to
which these tests are successful is determined by the amount of clean division of
responsibilities the project has between it’s components.&lt;/p&gt;
&lt;p&gt;Functional tests complete the rest of the inside-of-the-box testing by testing individual
components with related components, in the way they are used in a production
environment.  With these tests, the degree to which these tests are successful is the
ability to inject the project dependencies into one or more of the components being
tested, coupled with the clean division of responsibilities needed for good unit tests.
While using a concept such as the interface concept from Java and C# is not required, it
does allow the injection of dependencies to be performed cleanly and with purpose.&lt;/p&gt;
&lt;p&gt;To enable groups of functional tests to be as independent of the components outside of
their group as possible, &lt;a href="https://en.wikipedia.org/wiki/Mock_object"&gt;mock objects&lt;/a&gt; are
often used to replace concrete classes that are part of your project.  If interfaces are
used in your project to allow for better
&lt;a href="https://en.wikipedia.org/wiki/Dependency_injection"&gt;dependency injection&lt;/a&gt;,
your functional tests can create mock objects that reside with your tests.  This provides
more control and reliability on what changes you are making from the live instance of
the interfaces, for the sake of testing.  If interfaces are not supplied for better
dependency injection, a mocking library such as the Java
&lt;a href="https://site.mockito.org/"&gt;Mockito&lt;/a&gt;
are required to replace test dependencies with reliable objects.&lt;/p&gt;
&lt;h4 id="back-to-our-example"&gt;Back to our example&lt;a class="headerlink" href="#back-to-our-example" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Using the example project as a template, we know from the section on
&lt;a href="https://jackdewinter.github.io/2019/11/10/software-quality-reliability/#Scenario-Tests"&gt;scenario tests&lt;/a&gt;
that we need to test for valid inputs when adding a new contact.  To add
coverage for the component containing the “add a contact” logic as a unit test, it’s
success is determined by how much of the handling the external interface is in the one
component. If that component contains all of the code needed to handle that external
request in one method, it is extremely hard to test that component without bringing in
the other components.  That is definition of a functional test, not a unit test.  As an
alternative, if the validation of the input can be condensed into it’s own component and
removed from that method, that validation component can be unit tested very effectively.&lt;/p&gt;
&lt;p&gt;Applying that refactoring pattern a couple of more times in the right ways, the project’s
ability to be functionally tested increases.  As an added bonus,  depending on how the
refactoring is accomplished, new unit tests can be added based on the refactoring,
gaining measurable confidence on each additional component tested.  &lt;/p&gt;
&lt;p&gt;Using the adding a contact example again, having refactored the input validation to a
validation class could be followed by the following changes:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;create a new component for the handling of “add a contact” and decouple it from logic of the handling of the external interface&lt;/li&gt;
&lt;li&gt;move the user authentication and authorization logic into it’s own component&lt;/li&gt;
&lt;li&gt;move the persisting of the new contact logic into it’s own component&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From a functional test point of view, each of these refactorings makes it easier to test.
For the first refactoring, instead of having to rely on all functional testing going
through the external interface, which may include costly setup, we can create a local
instance of the new component and test against that.  If interfaces are used for the
remaining two refactorings, then test objects can be used instead of the “live” objects,
otherwise a mocking library can be used to replace those objects with more predictable
objects.&lt;/p&gt;
&lt;h2 id="how-is-each-group-of-tests-measured"&gt;How is each group of Tests Measured?&lt;a class="headerlink" href="#how-is-each-group-of-tests-measured" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;On this winding journey to determine how to measure reliability, I explored the relevant
elements of the four main types of tests.  I believe that I was successful in showing a
clear delineation between the two groups of tests and the benefits each group provides.
To recap, the outside-of-the-box group validates the expectations to be met, matched
against the requirements set out for the project.  The inside-of-the-box group validates
how those exceptions are met, matched against the external interfaces for the project.&lt;/p&gt;
&lt;p&gt;These two distinct foundations are important, as the two distinct groups of tests require
two distinct groups of measurements.&lt;/p&gt;
&lt;p&gt;The first group, scenario tests and end-to-end tests, are measured by scenario coverage.
Scenario coverage measures the number of tests that successfully pass against the total
number of scenario tests and end-to-end tests for that project.  As this group of tests
is measuring the business expectations of the project, this measurement is a simple
fraction: the number of passing tests as the numerator and the number of defined tests
as the denominator.&lt;/p&gt;
&lt;p&gt;The second group, unit tests and functional tests, are measured by source code coverage,
or code coverage for short.  Code coverage can be specified along 6 different axes:
class, method, line, complexity, blocks, and lines.  Different measurement tools will
provide different subsets of those measurements, but in the end they are all relaying
the same thing: the points in the project’s source code that are not properly tested.&lt;/p&gt;
&lt;h2 id="back-to-the-original-question"&gt;Back to the original question&lt;a class="headerlink" href="#back-to-the-original-question" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Does it (the measuring of reliability) have to be a binary choice?&lt;/p&gt;
&lt;p&gt;It depends.&lt;/p&gt;
&lt;p&gt;In an ideal world, the answer to that question is yes, but we do not live in an ideal
world.  In the real world, we have a decision to make for either group of tests on what
is good enough for the project and that group of tests.&lt;/p&gt;
&lt;p&gt;If the suggestions of this article are followed, then a condition of releasing the
project to a production state is 100% scenario coverage.  Anything less than 100% means
that critical use cases for the project are not complete, hence the project itself is not
complete.  &lt;/p&gt;
&lt;p&gt;To achieve the 100% coverage without adding new project code, updated requirements are
needed from the requirements author, say a project manager, to change the composition of
the scenario tests and end-to-end tests.  This may include removing some of these
tests as the release goals for the project are changed.  While changing and removing
goals and their tests, may seem like cheating to some people, the other option is
very risky.&lt;/p&gt;
&lt;p&gt;It should be evident that if a project is released without all scenario tests and
end-to-end tests passing, that team is taking a gamble with their reputation and the
reputation of the project.  It is better to adjust the tests and goals, and communicate
those changes, than to take a risk on releasing something before it meets those goals.&lt;/p&gt;
&lt;p&gt;Following the suggestions of this article for code coverage is a more nuanced goal, and
really does depend on the project and the situation. If architected and designed to
support proper testing from the beginning, I would argue that 95%+ code coverage is easy
and desirable.  If you are adding testing to an already existing project or do not have
the full support of the developers on the project, this number is going to be lower.&lt;/p&gt;
&lt;p&gt;Another factor is the type of project that is being tested and who will use it.  If you
are creating this project to support people inside of your company, it is possible that
one of the requirements is to have a lower initial code coverage target to allow the
project to be used right away and alleviate some internal company pressure.  If the
project is something that will represent you and your company on the international stage,
you will have to balance the time and effort needed to meet a higher bar for code
coverage with the need to get the project out where it can be used.  As with many things,
it is a matter of negotiation and balance between the various requirements.&lt;/p&gt;
&lt;h2 id="what-is-really-important"&gt;What Is Really Important&lt;a class="headerlink" href="#what-is-really-important" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;I want to stress that I believe that the important thing is that each project measures
where they are against whatever goals they set for their project. The team doesn’t need
to always maintain a near-100% code coverage measure, but that team needs to know where
they stand.  This will influence and inform the people that author the requirements and
adjust the priorities for the team.  Any negotiations within the team can then cite this
information and use it to help with the balancing act of adding new features, fixing
existing bugs, and enhancing code quality (in this case, increasing code coverage).&lt;/p&gt;
&lt;h2 id="how-to-measure-reliability"&gt;How To Measure Reliability&lt;a class="headerlink" href="#how-to-measure-reliability" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To answer the question “Does the software do the task that it is supposed to do?”,
scenario coverage is measured.  Scenario coverage for end-to-end tests and scenario
tests should always be at 100% when a production release of the project is performed.
This measurement is binary.  Until that release (or next production release) is
performed, adding or changing these tests based on the requirements for the next release
will inform the team and any stakeholders of how close the team is to satisfying those
requirements for that release.&lt;/p&gt;
&lt;p&gt;To answer the question “Does the software execute that task in a consistent manner?”,
code coverage is measured.  Code coverage for unit tests and functional tests should
strive for 95% code coverage along all 6 axes with all active tests completing
successfully 100% of the time.  The test completion percentage must be non-negotiable,
but the code coverage percentage must take into account the maturity of the project and
the usage of the project.  This measurement is non-binary.  However, it is important to
know your project’s code coverage measurement, and how it trends over time. While the
measurement is non-binary, it is suggested to create a binary rule that
specifies what the minimum percentage is for each axis, failing the rule if that
specific metric falls below the goal percentage.&lt;/p&gt;
&lt;h2 id="wrapping-it-up"&gt;Wrapping It Up&lt;a class="headerlink" href="#wrapping-it-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;By breaking down the types of tests that are expected for a given project, the two
different types of measurements of reliably become more evident.  Scenario coverage
is determined by outlining the major scenarios for using a project and writing
end-to-end tests and scenario tests against them.  Scenario coverage must be a binary
measurement at release time.  Code coverage is determined by using tools to measure
which parts of the code are executed when running functional tests and unit tests.
Code coverage is a non-binary metric that must have a minimum bar for coverage that is
met for the project, and determined on the merits of the project itself.&lt;/p&gt;
&lt;p&gt;By using these two measurements, I hope that I have shown that it is possible to provide
a way to empirically measure reliability.  By having a project be transparent about how
it is reaching those measurements and what they are, any team can provide meaningful and
understandable measurements of reliability.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:defense"&gt;
&lt;p&gt;If asked, I could easily defend the percentages.  For the success case, I would assume that half the 60% number will come from first try successes and half the number will come from success that occurred after people fixed errors returned from the other two tests and resubmitted the data.  While the other two categories are somewhat guesswork, from my experience validation errors are 2-3 times more common than an “existing contact” processing error.  Note that in the absence of real data, these are estimates that do not have to be perfect, just reasonable. &lt;a class="footnote-backref" href="#fnref:defense" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:errorHandling"&gt;
&lt;p&gt;In designing any type of project, you should seek to have clear and consistent interfaces between your project and the users of the project.  An extension of that statement is that any responses you return to your user should be grouped with related responses and returned in a common data structure or UI element to avoid confusion. &lt;a class="footnote-backref" href="#fnref:errorHandling" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="measuring software quality"></category><category term="software reliability"></category><category term="end-to-end tests"></category><category term="scenario tests"></category><category term="functional tests"></category><category term="unit tests"></category><category term="code coverage"></category><category term="scenario coverage"></category></entry><entry><title>What is Software Quality?</title><link href="https://jackdewinter.github.io/2019/09/15/what-is-software-quality/" rel="alternate"></link><published>2019-09-15T00:00:00-07:00</published><updated>2019-09-15T00:00:00-07:00</updated><author><name>Jack De Winter</name></author><id>tag:jackdewinter.github.io,2019-09-15:/2019/09/15/what-is-software-quality/</id><summary type="html">
&lt;p&gt;When introducing myself to someone professionally, I usually start with the normal
“Hi, my name is …” that is boiler-plated on nametags the world over.  Getting past that
initial point, if the person is so inclined, they ask that always fun lead off question “So,
what do you?”  For me, I …&lt;/p&gt;</summary><content type="html">
&lt;p&gt;When introducing myself to someone professionally, I usually start with the normal
“Hi, my name is …” that is boiler-plated on nametags the world over.  Getting past that
initial point, if the person is so inclined, they ask that always fun lead off question “So,
what do you?”  For me, I always respond with “I am an SDET”&lt;sup id="fnref:SDET"&gt;&lt;a class="footnote-ref" href="#fn:SDET"&gt;1&lt;/a&gt;&lt;/sup&gt;, to which anyone not in the
software industry replies back with “Um.... What is that?”&lt;/p&gt;
&lt;p&gt;Spewing out “It means I am a Software Development Engineer in Test.”, I wait for the response
that most people use: “Oh, so you are a tester.”  Often with gritted teeth, I try and explain
that testing is only a small part of what I do.  If I think they are still listening, I
given them my quick elevator pitch that emphasizes that I focus on helping to produce good
quality software by helping to increase the quality of the teams, the projects, and the
processes that I am tasked to assist with.&lt;/p&gt;
&lt;p&gt;Approximately 60-70% the time I win people over
with the elevator pitch, and a pleasant conversation continues.  The next 20-30% of the time,
usually with people not in the software field, I get blank stares and they fixate on the
“test” in the title rather than the “quality” in my description.  The remaining people are
usually Software Development Engineers or SDEs&lt;sup id="fnref:SDE"&gt;&lt;a class="footnote-ref" href="#fn:SDE"&gt;2&lt;/a&gt;&lt;/sup&gt; that for one reason or another, start to
tune out.&lt;/p&gt;
&lt;p&gt;For the percentage of people that I win over, they seem to understand that I focus on quality,
but the follow up question is almost always: “What does quality software mean to you?”&lt;/p&gt;
&lt;h2 id="where-do-we-start"&gt;Where do we start?&lt;a class="headerlink" href="#where-do-we-start" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For me, I almost always start at the beginning with requirements.  Whether they are
spoken or written down, each project has a set of requirements.  It could be the requirements
are to “explore my ability to use X” or “fix the X in the Y project” or “create a project
that can help me X”, but every project has requirements.&lt;/p&gt;
&lt;p&gt;In the software development industry, requirements are often presented
to teams that are hard to deal with or are left to the developers to write themselves.  This
practice is so prolific that Scott Adam’s Dilbert site has pages and pages of instance where
&lt;a href="https://dilbert.com/search_results?terms=User%20Requirements"&gt;requirements are talked about&lt;/a&gt;.
One example is when a manager talks to their team and
informs them that some process needs to be faster by 5%.  Do they have enough information from
that manager to understand the context of the requirement?  Do they expect that increase by a
specific time to meet their own goals?  What does that requirement look like?  How do they
know when they have achieved it?  Is it achievable?  If it is achievable, how do they measure
progress towards that goal?  These are some of the core questions that I believe need
answering.&lt;/p&gt;
&lt;p&gt;As those questions are at the front of my mind, when someone asks me how I define software quality, the first thing I immediately think back to is a course that I once took on setting
&lt;a href="https://en.wikipedia.org/wiki/SMART_criteria"&gt;S.M.A.R.T. requirements&lt;/a&gt;.
In that class, the main focus was on taking unrefined requirements and curating them to a
point where they could be more readily be acted upon.  The instructor made a very good
argument that each requirement must be Specific, Measurable, Assignable, Realistic, and
Time-Related.&lt;/p&gt;
&lt;p&gt;When it comes to software quality, I believe those same questions needs to be asked with
regards to any of the requirements teams put on their software.  But to ask those questions
properly, we need to have some context in which to ask those questions.  To establish that
context, it is helpful to have some guidelines to provide a framework for the requirements.&lt;/p&gt;
&lt;h2 id="establishing-some-guidelines-the-four-pillars"&gt;Establishing Some Guidelines: The Four Pillars&lt;a class="headerlink" href="#establishing-some-guidelines-the-four-pillars" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;A good general article for anyone interested in software quality is the
&lt;a href="https://en.wikipedia.org/wiki/Software_quality#Measurement"&gt;Wikipedia article on Software Quality&lt;/a&gt;.
In fact, when asked by people where to get started in the software quality area, I often refer
them to this article solely because of the excellent diagram in the Measurements section on the
right side of the page.&lt;sup id="fnref:Pillars"&gt;&lt;a class="footnote-ref" href="#fn:Pillars"&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;The diagram in the Measurements section correlates very closely to what I believe are the four
pillars of software quality: Reliability, Maintainability, Efficiency, and Security.  The
diagram then shows how their pillars relate to other attributes: Application Architecture
Standards, Coding Practices, Complexity, Documentation, Portability, and Technical/Functional
Volumes.  From there, it provides more lists of how to break things down, with many references
to other articles.  In short, it is a great place to start from.&lt;/p&gt;
&lt;h2 id="measuring-software-quality"&gt;Measuring Software Quality&lt;a class="headerlink" href="#measuring-software-quality" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Before proceeding to talk about the pillars themselves, I feel strongly that we need to
discuss the categories that I use for measuring the metrics talked about in the Wikipedia
article.  My intention is that by talking about the metrics before discussing each of the
pillars, you can start building a mental model of how to apply them to your projects as you
are reading about them.  From my point of view, making that mental transition from something
abstract that you read about to something concrete that applies to your work is
essential to serious forward momentum on software quality.&lt;/p&gt;
&lt;p&gt;These metrics typically fall into two categories: seldom violated metrics and positive
momentum metrics.&lt;/p&gt;
&lt;p&gt;The seldom violated metrics category contains rules that define rules that are pivotal to the
quality of your project.  Each rule are a combination of a given metric and a maximum
or minimum weighed against that metric.  As a guideline, teams should only ignore
these rules on a case by case basis after providing a reason that is good, defensible, and
documented.
Examples of such metrics are Service Level Agreements (SLAs), Static Code Analysis
(SCA) results, and Test Failure Rates.  Examples of rules are “the TP99 for the X
API is Y millisecond” or “all PMD warnings (Java SCA tool) must be following with
a minimal of suppressions”.&lt;/p&gt;
&lt;p&gt;Furthermore, to make these rules useful and to keep your
team honest, your team needs to publish the selected metrics, with a description of what the
metrics are, how your team measures those metrics, and why your team is measuring them.&lt;/p&gt;
&lt;p&gt;The positive momentum metrics category is usually reserved for metrics that are being
introduced to an already existing project.  When introducing software quality metrics into an
already existing project, it is not realistic to expect those metrics to be adhered to in an
instant.  It is more realistic to expect positive momentum towards the goal
until the point when your team achieves it, at which point is moves to the desired seldom
violated metrics category.  As such, a measure of the momentum of these metrics is used, and is
hopefully in a positive direction. Similar to the previous category, your team should publish
information about the selected metrics, with the added information on when your team feels
they will translate it from the positive momentum category to the seldom violated category.&lt;/p&gt;
&lt;p&gt;Being consistent on these chosen metrics is very important.  While dropping a metric looks
better on any reporting in the short term, it usually negatively impacts the software quality,
perhaps in a way that is not obvious until later. Adding a new metric will show lower the
measured quality in the short term, but increases the measured quality in the long
term.  Your team can negate the short term impact by paying the immediate cost of making the
new metric a seldom violated metric, but that has to be weighed against the other priorities
for your project.  As with everything, it is a balancing act that needs to be negotiated with
your team.&lt;/p&gt;
&lt;h2 id="exploring-the-four-pillars"&gt;Exploring The Four Pillars&lt;a class="headerlink" href="#exploring-the-four-pillars" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having established that S.M.A.R.T. requirements and the two categories for metrics
from the previous sections are useful in measuring software quality, the focus of the article
can return to the guidelines: the four pillars.  Each one of these pillars will look at
your software project from a different angle, with the goal of providing a set of data points
to formulate a coherent measurement of software quality for that project.&lt;/p&gt;
&lt;p&gt;In the following sections, I strive to describe each of the four pillars, providing a jumping
off point to another article that describes that pillar in a more comprehensive manner.  I
firmly believe that by providing metrics for each pillar that are specific to your project,
with each of those metrics properly categorized into the two measurement categories documented
above, that your team will take a decent step forward in clearly defining software quality for
your project.&lt;/p&gt;
&lt;h3 id="reliability"&gt;Reliability&lt;a class="headerlink" href="#reliability" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The essence of this pillar can be broken down into two questions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the software do the task that it is supposed to do?&lt;/li&gt;
&lt;li&gt;Does the software execute that task in a consistent manner?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Reliability is one of the areas in which “pure” testing shines.  A lot of the tests that
SDEs, SDETs, and testers are asked to write specifically verify if a given object does
what it is supposed to do.  Unit tests determine whether an individual software unit, such as
a class, performs they way it is supposed to.  Functional tests or integration tests take that
a step higher, determining whether a group of related software units do what they are supposed
to do.  Another step higher are the scenario tests, which determine whether the software
project, as a whole, responds properly to various use cases or scenarios that are considered
critical to its operation.  Finally, end-to-end tests or acceptance tests determine whether or
not a group of projects respond properly from an end user’s perspective.&lt;/p&gt;
&lt;p&gt;This pattern is so widely used, any search for
&lt;a href="https://www.bing.com/images/search?q=test+pyramid"&gt;test pyramid&lt;/a&gt;,
will find many variations of the same theme. Different articles on the subject will stress
different points about the pyramid, but they will all generally look like this:&lt;/p&gt;
&lt;p&gt;&lt;img alt="test pyramid" src="https://jackdewinter.github.io/images/quality-1/test-pyramid.png"/&gt;&lt;/p&gt;
&lt;p&gt;This pyramid, or other similar pyramids, are interpreted by authors to indicate a specific
things about the tests, to highlight the position of their article.  Some of these
interpretations are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An article on test volume will typically stress that ~70-80% of the tests should be at the unit test level, ~10-15% at the functional test level, ~5-10% at the scenario level, and ~1-3% at the end-to-end level.&lt;/li&gt;
&lt;li&gt;An article on test frequency will typically stress that tests near the bottom of the pyramid should complete within 60 seconds and be executed every time the source code is checked in.  Tests near the top of the pyramid may take minutes or hours and should be executed once a week.&lt;/li&gt;
&lt;li&gt;An article on test fragility will typically stress that tests near the bottom of the pyramid are closer to their components, the expectation is that they will not fail.  Tests near the top of the pyramid require more orchestration between projects and teams, and therefore, are more likely to failure do to environmental or other reasons.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;While all of these interpretations have merit, the critical point for me is the issue of
boiling down that information to a small number of bite sized observations that can be easily
measured and communicated. In the upcoming article &lt;code&gt;Software Quality: Reliability&lt;/code&gt;, I will
delve more into breaking the Reliability pillar into S.M.A.R.T. requirements and I provide
suggestions on how it can be measured.&lt;/p&gt;
&lt;h3 id="maintainability"&gt;Maintainability&lt;a class="headerlink" href="#maintainability" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The essence of this pillar can be broken down into one question:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If you are asked to change the software to fix a bug or introduce a new feature, how easy is it to change the software, how many surprises do you expect to encounter, and how confident will you be about the change afterwards?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The best, and most comedic, form of asking this question is captured by this cartoon
from &lt;a href="https://www.osnews.com/"&gt;OSNews&lt;/a&gt;:&lt;/p&gt;
&lt;p&gt;&lt;img alt="WTFs per minute" src="https://mk0osnewswb2dmu4h0a.kinstacdn.com/images/comics/wtfm.jpg"/&gt;&lt;/p&gt;
&lt;p&gt;Maintainability is a single pillar that encompasses the most diverse types of processes and
measurements of any of the pillars.  The reason for this is that maintainability is often a
word that is used without a lot of provided context.  For me, a good way to think about
maintainability is that it is the cleanliness of your project.  Different people will have
different experiences, and after asking different people about how “clean” the project is,
the collected answers will almost certainly by different.&lt;/p&gt;
&lt;p&gt;Try this in your office with your colleagues.  Point to a given area of your office and ask
2-5 people how clean a given area, such as your desk is.  Instead of accepting a single
answer, dig in a bit as to why they answered the way they did.  Most likely, you will
get as many distinct answers as people that you talk to.  This exercise illustrates how
hard it is to give a good answer to how maintainable software a given piece of software is.&lt;/p&gt;
&lt;p&gt;The best way to provide metrics for maintainability is usually with various Static Code
Analysis tools.  Almost every mature language has at least one tool to do this, and each tool
usually measures a fair number of metrics.  These metrics will use established (and sometimes
experimental) industry practices to look at the source code of your project and determine
if there are issues that can be addressed.  In addition to those metrics, those same tools
often look for “problematic” and “sloppy” code.  Problematic code is usually some manner of
pattern that a fair number of experts have agreed is a bad thing, such as appending to a
string within a loop.  Sloppy code is usually things like having a variable or a parameter
that is not being used, or a forgotten comment on a public method.&lt;/p&gt;
&lt;p&gt;In addition to Static Code Analysis, teams must continue to strive to have a good set of
documentation on what the project is doing, and regularly maintain that documentation.  While
the “correctness” of the documentation is harder to measure than source code, it is pivotal
for a project. How much of the information on the various projects that your team supports
is in the head of one or two individuals?  What is going to happen if they leave the team
or leave the company.&lt;/p&gt;
&lt;p&gt;Your team should not need volumes of information on every decision that was made, but as a
team, it is imperative to document the major decisions that affect the flow of the project.
It is also a good idea to have solid documentation on building, deploying, and executing
the project. Imagine yourself as a new team member looking at the software project and any
documentation, and honestly ask yourself “How much would I want to run away from that project?”
If the honest answer from each member of the team is something similar to “I’m good”, you
probably have a decent level of documentation.&lt;/p&gt;
&lt;h4 id="a-note-on-static-code-analysis"&gt;A Note On Static Code Analysis&lt;a class="headerlink" href="#a-note-on-static-code-analysis" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Before delving deeper into maintainability, I want to take a minute to talk about Static Code
Analysis.
Typically, Static Code Analysis is used as a gatekeeper for maintainability, and as such,
any suggestions should be strictly followed.  However, Static Code Analysis tends to be an
outlier to the gatekeeper rule in that the metrics need to be “bent” every so often. This
“bending” is accomplished using some form of suppression specified by the Analyzer itself.&lt;/p&gt;
&lt;p&gt;Static Code Analyzers tend to fall into two main categories: style and correctness.&lt;/p&gt;
&lt;p&gt;Any warnings that are generated by a style analyzer should be addressed without fail.
In terms of stylistics, there are very few times where deviating from a common style are
beneficial, and as such should be avoided.  As stylistics can vary from person to
person when writing code, it is useful to supplement the style analyzer with an IDE
plugin that will reformat the source code to meet the team’s stylistics, with the Static
Code Analyzer acting as a backstop in case the IDE formatting fails.&lt;/p&gt;
&lt;p&gt;Warnings generated by correctness analyzers are more likely to require bending.  Most
correctness analyzers are based on rules that are normally correct, but do have exceptions.
As such, your team should deal with these exception by having a follow up rule on when
it is acceptable to suppress the exceptions, and specifically on a case-by-case basis.
It is also acceptable to suppress the exception after generating a future requirement to
address the exception, if your team is diligent on following up with these requests.&lt;/p&gt;
&lt;p&gt;In both cases, it is important to remember that SCAs are used to help your team
keep the project’s maintainability at a healthy level.&lt;/p&gt;
&lt;h4 id="back-to-maintainability"&gt;Back to Maintainability&lt;a class="headerlink" href="#back-to-maintainability" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;In the upcoming article &lt;code&gt;Software Quality: Maintainability&lt;/code&gt;, I will delve more into breaking
the Maintainability pillar into S.M.A.R.T. requirements and I provide suggestions on how it can
be measured.  I will do this by presenting the 4-5 metrics that I consider to be useful as
well as both patterns and anti-patterns to avoid. [ED: Need to rephrase that last sentence.]&lt;/p&gt;
&lt;h3 id="efficiency"&gt;Efficiency&lt;a class="headerlink" href="#efficiency" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The essence of this pillar can be broken down into one question:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Does the software execute that task in a timely manner?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Similar to my analogy of maintainability being the cleanliness of your software, efficiency
is whether or not your software is executing “fast enough”.  Coming up with an answer to a
question on whether or not something is “fast enough” is usually pretty easy.  But when
you ask for a definition of what “fast enough” means, that is when people start to have issues
coming up with a solid answer.  In my experience, a large part of the reason for that
vagueness is usually not having a good set of requirements.&lt;/p&gt;
&lt;p&gt;As an example, let’s figure out what “fast enough” means for two different video games that
my family plays: Civilization and Rocket League.&lt;/p&gt;
&lt;p&gt;For the game Civilization (in multiplayer mode), the big delays in the game are the human
interactions and decisions required before a player ends their turn.  It is
also very important that all of the information get conveyed between turns so that the
multiplayer server can accurately record actions in a fair and just manner.  For this game,
“fast enough” for the software is largely dwarfed by the delays that the players introduce.
However, if we have a game with 12 players, 2 of them human and the other 10 using the game’s
AI players, then we can start to formulate what “fast enough” is for the AI players.  It
really depends on the context.&lt;/p&gt;
&lt;p&gt;Rocket League is a different story.
&lt;a href="https://en.wikipedia.org/wiki/Rocket_League"&gt;Rocket League&lt;/a&gt;
is a sequel to the game “Supersonic Acrobatic Rocket-Powered Battle-Cars” released in 2008.
In this game, you play a game of arena soccer using rocket powered cars, each match consisting
of a series of games between teams of 1-3 players.  Unless there is a LAN tournament between
professional teams, it is very rare for more than one player to be in the immediate vicinity
of their teammates, and often players are from different states/provinces and even countries.
For the client software on the player’s computers, “fast enough” is measured by latency and
packet loss.  With each player’s action being relayed to the server and then back out to the
other players, any packet loss or increase in latency will impact the server’s reaction to
various inputs from the player’s controllers.  For this type of game, “fast enough” depends
on a good network connection and a server that is able to process many actions per second.&lt;/p&gt;
&lt;p&gt;As you can see from the video game example, efficiency greatly depends on what the requirements
of the software are.  In the upcoming article &lt;code&gt;Software Quality: Efficiency&lt;/code&gt;, I will delve
more into breaking the Efficiency pillar into S.M.A.R.T. requirements and I provide
suggestions on how it can be measured.&lt;/p&gt;
&lt;h3 id="security"&gt;Security&lt;a class="headerlink" href="#security" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The essence of this pillar can be broken down into one question:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;How easy is it for a third party to perform malicious actions with your software?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;That is one dramatic question.  “Perform malicious actions.”  Wow!  I have read all sorts
of articles on various news sites about those, but surely they cannot affect my software?
That is usually one of the first reactions of a lot of software developers.  Just 10
minutes with a security researcher can open your eyes to what is possible.&lt;/p&gt;
&lt;p&gt;To understand this better, pretend that your software project is on a slide, being viewed
through a microscope.  If you look at the slide without the microscope, you just see your
software on the slide, pretty much the same as any other slide.  However, if you increase your
magnification by one order of magnitude, you see that your project includes your source code
and components developed by other people.  You may be following proper security practices, but
did they?&lt;/p&gt;
&lt;p&gt;Another order of magnitude down, and you are looking at the low level instructions for your
project and any included components.  Once the component was assembled, could a third party
have added some malicious code to that component, executing normally until they activate it?
Was that malicious code in their from the beginning?  Or maybe it is a vulnerability at the
source code, machine code, or machine levels?  Someone can make a small change to a component
to utilize that vulnerability with little effort if they know what they are doing.&lt;/p&gt;
&lt;p&gt;Reversing our direction, if we expand outwards instead of inwards, we have containerization.
Containerization solutions, such as &lt;a href="https://www.docker.com/resources/what-container"&gt;Docker&lt;/a&gt;,
provides a complete computing environment to execute your software within.  Popular with back
end development, you encapsulate your software with it’s intended operating system platform,
reducing the number of platform’s you need to design your software for to 1.  But with
containerization, we also have to ask the same questions of the platform as we did with the
software.  How secure is the operating system that the container uses as it’s base?&lt;/p&gt;
&lt;p&gt;In today’s world of software development, where componentization is key, the software you
write is not the only place where security issues can be introduced.  However, there are
proactive steps you can take to reduce the vectors than users can
follow to use your software maliciously.
In the upcoming article &lt;code&gt;Software Quality: Security&lt;/code&gt;, I will delve more into breaking
the Security pillar into S.M.A.R.T. requirements and I provide suggestions on how they it
be measured.&lt;/p&gt;
&lt;h2 id="back-to-requirements"&gt;Back To Requirements&lt;a class="headerlink" href="#back-to-requirements" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having explored the 4 pillars, it is important to bring the discussion back to the definition
of good requirements.  Using the information from each of the individual pillar articles in
concert with the information on S.M.A.R.T. terminology, your team can request requirements
that are more focused.  As any focused requirements will be Specific (the S. in S.M.A.R.T.),
it is reasonable to expect that any impact on our 4 pillars will be noted.  Asking for this
change will almost guarantee some negotiations with the team’s stakeholders.&lt;/p&gt;
&lt;p&gt;In my experience, when your team asks for more focused goals from your stakeholders, there
will typically be some pushback from those stakeholders at the beginning.  If your team
has had some requirements mishaps in the past, highlight each mishap and how the ensuing
loss of time and focus could have been avoided usually sways stakeholders.  Don’t point
fingers, but simply point out something like:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hey, when we did the X requirement, we all had a different idea on what to fix, and as such,it took X hours of meeting and Y hours of coding and testing to figure out it was the wrong thing.  We just want to help tune the requirements process a bit to help everyone try and avoid that waste.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Most stakeholders are being asked to have their teams do the maximum amount of work possible
in the shortest amount of time. By asking that question in such simple manner, you are asking
if you can spend a small amount of time up front to hopefully eliminate any such missteps.
Most stakeholders will grab on to that as a way for them to look good and for the team to
look good, a win-win.&lt;/p&gt;
&lt;h3 id="what-will-these-requirements-look-like"&gt;What will these requirements look like?&lt;a class="headerlink" href="#what-will-these-requirements-look-like" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The requirements will typically come in two main categories.  The first category, requirements
focused on fixing bugs or adding features, will typically be the bulk of the requirements.
Each requirement should outline any negative impact it will have on any of the metrics.  If
nothing is added on negative impacts, the assumption is that the impact will be neutral or
positive.&lt;/p&gt;
&lt;p&gt;A good example of this is a requirement to add a new feature to the project.  The requirement
should be clearly stated using S.M.A.R.T. terminology, because it will remove any
ambiguity in the requirements.  As any source code added without tests would impact any
reliability metrics, reliability tests should be added to meet any seldom violated
metrics for your project.  In similar ways for the other 3 pillars, it is assumed that any
source code added will be a step forward or neutral in terms of quality, not backward.&lt;/p&gt;
&lt;p&gt;At some point in your project, you should expect that at least a few of the requirements
will appear in the the second category: requirements specifically targeted at one or more of
the pillars.  These requirements allow your team to focus on some aspect of your project where
your team feels that the quality can be improved.  The big caveat with these
requirements is to be mindful of the Achievable and Time-Related aspects of S.M.A.R.T.
requirements.  Make sure that whatever the goal of these requirements are, they are things
that won’t go on forever and are not pipe dreams.&lt;/p&gt;
&lt;p&gt;A good example of this is wanting to improve the efficiency of your project or processes.
Without a good requirements that is Specific, Achievable and Time-Related, this can go on
forever. A bad requirement would state something like “Make the project build faster”.  A good
requirement might state something like “Reduce the unit test time from 20 seconds to
under 15 seconds”, timeboxed to 4 hours.  The good requirement has good guard rails on it
to keep it from exploding on someone who picks up that work.&lt;/p&gt;
&lt;h2 id="publishing-software-quality"&gt;Publishing Software Quality&lt;a class="headerlink" href="#publishing-software-quality" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having gone through the previous sections and any related articles, you should have a
better idea on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;how to write better requirements to ask for software quality to be improved&lt;/li&gt;
&lt;li&gt;what metrics I recommend to use for each of the four pillars&lt;/li&gt;
&lt;li&gt;how to measure those metrics and integrate them into your projects&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Using this information as tools, your team can improve the quality of the project at it’s own
pace, be that either an immediate focus or a long term focus for your project.&lt;/p&gt;
&lt;p&gt;For any metrics that are in the seldom violated category, the best way to approach them is
to make them gatekeeper metrics for your project.  It should be possible to execute a great
many of the gatekeeper metrics before a commit happens, which is optimal.  For the remaining
metrics in the seldom violated category and metrics in the the positive momentum category,
your team should publish those metrics with every commit or push, giving the submitter that
needed feedback.&lt;/p&gt;
&lt;p&gt;In addition, publishing the metrics to some kind of data store allows your team to
determine how the project quality is trending over time, allowing any stakeholders or project
members to observe any potential software quality issues and take steps to deal with them.
Even for certain seldom violated metrics, it can be useful to track how they are trending,
even if they are trending above the gatekeeper lines set for the project.&lt;/p&gt;
&lt;p&gt;If your team does not publish those metrics in some form, the only data point they have for
the project is a binary one: it passes or it does not.  From my experience, that binary
metric is often a false positive that burns teams due to a lack of information.&lt;/p&gt;
&lt;h2 id="what-does-software-quality-mean-to-me"&gt;What Does Software Quality Mean To Me?&lt;a class="headerlink" href="#what-does-software-quality-mean-to-me" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Software quality means each software project has a plan.  When requirements come in to the
project, they are detailed using the S.M.A.R.T. terminology.  If not specifically geared
towards a given software quality pillar, each requirement may specify what kind of impact it
has on one or more of the pillars.  If not specified, it is assumed that it has a neutral or
positive effect on all of the software quality pillars.  The goals are also specific, not
overly broad, and realistically achieved within a given time frame.&lt;/p&gt;
&lt;p&gt;Software quality means that metrics are well thought out for each project.  Each metric is
both defensible and reasonable for that project and that team.  Any metrics that are not being
used as gatekeepers are published so they can be tracked over time.  For additional benefit,
non-binary gatekeeper metrics are also published, to further improve the project and the
quality of the project.&lt;/p&gt;
&lt;p&gt;Software quality means ensuring that software projects are reliable.  Projects have well
thought out tests that are performed at many levels to ensure that the project’s components
work together to meet the project requirements as well as verify the correctness of the
components themselves.  These tests are executed frequently, and a large number of them are
used as gatekeepers, trying to ensure that only reliable changes are made to the project.
When a project is released, the scenario coverage is 100% and the code coverage is either
at 100% or whatever percentage the team has negotiated and documented for their project.&lt;/p&gt;
&lt;p&gt;Software quality means ensuring that software projects are maintainable.  This entails
sufficient documentation of project goals, architecture, design, and current state. The
documentation is coupled with Static Code Analysis to measure a number of maintainability
metrics and to gatekeep on most of them, ensuring that the project moves in a positive
direction to a higher quality project.&lt;/p&gt;
&lt;p&gt;Software quality means ensuring that software projects and their processes are efficient.
Team process to administrate and maintain the software and the software itself do not have to
be blindingly fast, but they need to be as efficient as they need to be for that project and
for that team.  They do not need to be fast as lightning, only fast enough for the software
project itself.&lt;/p&gt;
&lt;p&gt;Software quality means ensuring that software projects are secure.  If third party components
are used for the project, those components need to be monitored for vulnerabilities, and
any issues that arise must be addressed quickly.  Steps are taken, at a level that is
appropriate for the type of software project, to reduce the possible ways that an user can use
the software project do something malicious.&lt;/p&gt;
&lt;p&gt;To me, software quality is about the journey, continuously improving quality and showing
that progress, while adding new features and fixing bugs at the same time.&lt;/p&gt;
&lt;h2 id="wrapping-it-up"&gt;Wrapping It Up&lt;a class="headerlink" href="#wrapping-it-up" title="Permanent link"&gt;¶&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To put it succinctly, software quality for a project is about having a common nomenclature
describing the various pillars of quality, having a common way of measuring against each of
those pillars, and the publishing of those measures.  &lt;/p&gt;
&lt;p&gt;Therefore, from my point of view, software quality is not a single metric but a collection of
metrics and a philosophy.  That philosophy is that your team can only really answer that
question by having clearly defined goals for your project and it’s quality metrics, and
steering the project towards those goals.  &lt;/p&gt;
&lt;p&gt;Does every project need to be super high quality? No, not even close.  But I firmly believe
that each project needs to have a solid understanding of what level of software quality they
have in order to negotiate the definition of “good enough” for each project.&lt;/p&gt;
&lt;div class="footnote"&gt;
&lt;hr/&gt;
&lt;ol&gt;
&lt;li id="fn:SDET"&gt;
&lt;p&gt;In the United States, where I currently live, I am a Software Development Engineer in Test or SDET.  I do not have an engineering degree.  In any other country, including my native Canada, I am a Software Developer in Test or SDT. &lt;a class="footnote-backref" href="#fnref:SDET" title="Jump back to footnote 1 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:SDE"&gt;
&lt;p&gt;In the United States, where I currently live, a Software Development Engineer or SDE is the same as a Software Developer in any other country. &lt;a class="footnote-backref" href="#fnref:SDE" title="Jump back to footnote 2 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:Pillars"&gt;
&lt;p&gt;Based on my experience, where the article breaks out &lt;code&gt;Size&lt;/code&gt; as it’s own pillar, I would place it in the Maintainability section. Similarly, while I can understand why they place &lt;code&gt;Indentifying Critical Programming Errors&lt;/code&gt; in its own section, I would most likely fold half of the items into the Maintainability section and half of them into the Reliability section. To be clear, I agree with the content they present, it is just the organization that I disagree with on two small points. &lt;a class="footnote-backref" href="#fnref:Pillars" title="Jump back to footnote 3 in the text"&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</content><category term="Software Quality"></category><category term="measuring software quality"></category><category term="software reliability"></category><category term="software maintainability"></category><category term="software efficiency"></category><category term="software security"></category></entry></feed>